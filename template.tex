
\documentclass[twoside]{article}
\usepackage[colorlinks,linkcolor=black]{hyperref}
\usepackage{xeCJK}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{amsmath, amsthm}
\usepackage{listings,xcolor}
\usepackage{geometry}
\usepackage{fontspec}
\setsansfont{FiraCode-Medium}
\setmonofont[Mapping={}]{FiraCode-Medium}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\geometry{left=2.5cm,right=2.5cm,top=2.5cm,bottom=2.5cm}
\lstset{
    language    = c++,
    breaklines  = true,
    captionpos  = b,
    tabsize     = 4,
    numbers     = left,
    columns     = fullflexible,
    keepspaces  = true,
    commentstyle = \color[RGB]{0,128,0},
    keywordstyle = \color[RGB]{0,0,255},
    basicstyle   = \small\ttfamily,
    rulesepcolor = \color{red!20!green!20!blue!20},
    showstringspaces = false,
}
\title{模板之用了就秃}
\author{So Like Coding? You Baldy}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[C]{模板之用了就秃, So Like Coding? You Baldy}
\begin{document}\small
\begin{titlepage}
\begin{center}
\includegraphics[width=0.75\textwidth]{logo.jpg} \\ [2cm]
\HRule \\ [1cm]
\textbf{\Huge{模板之用了就秃}} \\ [0.5cm]
\HRule \\ [2cm]
\textbf{\Huge{WUST}} \\ [1cm]
\LARGE{So Like Coding? You Baldy}
\vfill
\Large{\today}
\end{center}
\clearpage
\end{titlepage}
\tableofcontents\clearpage
\pagestyle{fancy}
\lfoot{}
\cfoot{\thepage}\rfoot{}
\setcounter{section}{-1}
\setcounter{page}{1}
\clearpage\section{Header}
\subsection{pbds}
\subsubsection{head}
\begin{lstlisting}
#include <bits/extc++.h>
#pragma comment(linker, "/STACK:102400000,102400000")
using namespace __gnu_pbds; // tree, gp_hash_table, trie
using namespace __gnu_cxx; // rope
tree<TYPE, null_type, less<>, rb_tree_tag, tree_order_statistics_node_update> tr;
// 可并堆
#include <ext/pb_ds/priority_queue.hpp>
using namespace __gnu_pbds;
__gnu_pbds::priority_queue<int,greater<int>,pairing_heap_tag> q[maxn];
//q[i].join(q[j]) 将j堆并入i\end{lstlisting}
\subsection{FastIO}
\subsubsection{快速IO}
\begin{lstlisting}
// 适用于正负整数
template <class T>
inline bool scan(T &ret){
    char c;
    int sgn;
    if (c = getchar(), c == EOF) return 0; //EOF
    while (c != '-' && (c < '0' || c > '9')) c = getchar();
    sgn = (c == '-') ? -1 : 1;
    ret = (c == '-') ? 0 : (c - '0');
    while (c = getchar(), c >= '0' && c <= '9') ret = ret * 10 + (c - '0');
    ret *= sgn;
    return 1;
}

template <class T>
inline void write(int x, int digit=10) {
    static int sta[35];
    int top = 0;
    do {
      sta[top++] = x % digit, x /= digit;
    } while (x);
    while (top) putchar(sta[--top] + 48);
}

inline int read() {
    int x = 0;
    char ch = getchar();
    while (ch > '9' || ch < '0')ch = getchar();
    while (ch >= '0' && ch <= '9') {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x;
}\end{lstlisting}
\subsubsection{快速幂}
\begin{lstlisting}
// 精确快速乘
ll mul(ll a, ll b, ll mod) {
    a %= mod; b %= mod;
    ll res = 0;
    while (b > 0) {
        if (b & 1) {
            res = (res + a);
            if (res >= mod) res -= mod;
        }
        a = (a + a);
        if (a >= mod) a -= mod;
        b >>= 1;
    }
    return res;
}

// O(1)快速乘
ll mul(ll a, ll b, ll M) { return (a * b - (ll)((long double)a * b / M) * M + M) % M; }

//int128
ll ans = ((__int128) a * b) % p;

// 10进制快速幂，直接读入%s,c 预处理字符串len
char c[1000005];
int len;
ll qp(ll a) {
    len --;
    a %= mod;
    ll s = a;
    ll res = 1;
    while (len >= 0) {
        ll cur = s;
        for (int i = 1; i <= c[len] - '0'; ++i) {
            res = res * s % mod;
        }
        for (int i = 1; i < 10; ++i) {
            cur = cur * s % mod;
        }
        s = cur;
        len --;
    }
    return res;
}\end{lstlisting}
\subsubsection{Python读入}
\begin{lstlisting}
// python一行读入
a,b = map(int, input().split())

a = []
for i in input().split():
    a.append(int(i))


f.write('{0} {1}\n'.format(1, 2))\end{lstlisting}
\subsubsection{特殊IO}
\begin{lstlisting}
// 代替gets
scanf("%[^\n]%*c", ss)

// 高精分数输出
void print(ll x, ll y, int need) { // need 表示小数位数
    int a[need];
    printf("%lld.", x / y);
    ll t = x % y;
    for (int i = 0; i < need; i++) {
        t *= 10;
        a[i] = t / y;
        t = t % y;
    }
    if (t * 10 / y >= 5)a[need - 1]++;
    int i = need - 1;
    while (a[i] == 10) {
        a[i] = 0;
        a[--i]++;
    }
    for (int i = 0; i < need; i++) putchar(a[i]);
    putchar('\n');
}

// type mx
// int 10
// int64 19
// int128 38
template<class T, int g = 10>
void print(T x) {
    vector<char> a(38);
    if (x < 0) {x = -x;putchar('-');}
    if (x == 0) {putchar('0');return;}
    int tot = 0;
    while (x > 0) {
        a[tot++] = x % g;
        x /= 10;
    }
    for (int i = tot - 1; i >= 0; --i) putchar('0' + a[i]);
}\end{lstlisting}
\subsection{header}
\begin{lstlisting}
// Editor -> Live Templates
// add template group acm
// add template main
// C++ Declaration

#include <bits/stdc++.h>
#define ll long long
#define x first
#define y second
#define sz size()
#define all(x) x.begin(), x.end()
using namespace std;

typedef pair<int, int> pii;
typedef vector<int> vi;
typedef vector<long long> vl;

template <class T>
inline bool scan(T &ret){
    char c;
    int sgn;
    if (c = getchar(), c == EOF) return 0; //EOF
    while (c != '-' && (c < '0' || c > '9')) c = getchar();
    sgn = (c == '-') ? -1 : 1;
    ret = (c == '-') ? 0 : (c - '0');
    while (c = getchar(), c >= '0' && c <= '9') ret = ret * 10 + (c - '0');
    ret *= sgn;
    return 1;
}

const ll mod = 1e9+7;
const int maxn = $MAXN$;
const int inf = 0x3f3f3f3f;

ll qp(ll x, ll n, ll mod = ::mod) {
    ll res = 1; x %= mod;
    while (n > 0) {
        if (n & 1) res = res * x % mod;
        x = x * x % mod;
        n >>= 1;
    }
    return res;
}

int main(int argc, char* argv[]) {
    $END$
    return 0;
}

// C++ Expression debug
freopen("data.in","r",stdin);
freopen("data.out","w",stdout);
clock_t ST = clock();
cerr << "time: " << ((clock()-ST)*1000.0 / CLOCKS_PER_SEC) << "ms" << endl;


// C++ Expression tkase
int T;
scanf("%d", &T);
for (int kase = 1; kase <= T; ++kase) { 
$END$
}\end{lstlisting}
\subsubsection{comp}
\begin{lstlisting}
// 1 create directory comp
// 2 create directory comp/test
// 3 create duipai.cpp
// add text

#include<bits/stdc++.h>
using namespace std;
int main(){
    int i;
  for (i=1;;i++){
        printf("The result of No. %d Case is:  ",i);
        system("python3 rand.py");
        system("./std < test/data.in > test/std.out");
        system("./my < test/data.in > test/my.out");
        if (system("diff test/std.out test/my.out")){
            printf("Wrong Answer\n");
            return 0;
        }
        else printf("Accepted\n");
    }
    return 0;
}


// 4 create duipai.sh
#!/bin/bash
g++ std.cpp -o std
g++ my.cpp -o my
python3 rand.py
./a.out

// 5 create rand.py
# coding=utf-8
from random import randint, choice, shuffle
# with open("../cmake-build-debug/data.in", "w") as f:
with open("test/data.in", "w") as f:
    n = randint(1, 10)
    m = randint(1, 10)
    f.write(f"{n} {m}")

// 6 terminal: g++ duipai.cpp
// 7 terminal: sudo chmod 777 duipai.sh
// 8 add my.cpp and std.cpp
// 9 ./duipai.sh

\end{lstlisting}
\subsubsection{vim}
\begin{lstlisting}
syntax on
set nu
set tabstop=4
set shiftwidth=4
set background=dark

map <C-A> ggVG"+y
map <F5> :call Run()<CR>
func! Run()
	exec "w"
	exec "!g++ -Wall % -o %<"
	exec "!./%<"
endfunc\end{lstlisting}
\clearpage\section{Math}
\subsection{群论}
\subsubsection{普通筛}
\begin{lstlisting}
int prim[maxn], tot;
bool v[maxn];
void init() {
    for (int i = 2; i < maxn; ++i) {
        if (!v[i]) prim[++tot] = i;
        for (int j = i + i; j < maxn && j <= (ll)i * i; j += i) v[j] = 1;
    }
}\end{lstlisting}
\subsubsection{线性筛}
\begin{lstlisting}
int mn[maxn], prim[maxprime];
int tot = 0;
void init() {
    for (int i = 2; i < maxn; ++i) {
        if (!mn[i]) prim[++tot] = i, mn[i] = i;
        for (int j = 1; j <= tot && i * prim[j] < maxn; ++j) {
            mn[i * prim[j]] = prim[j];
            if (!(i % prim[j])) break;
        }
    }
}

// 素数个数表
// 10 4
// 1e5 9592 (1e4)
// 2e5 17984 (2e4)
// 5e5 41538 (5e4)
// 1e6 78498 (8e4)
// 2e6 148933 (1.5e5)
// 1e7 664579 (7e5)
// 3e7 1857859 (2e6)
// 1e8 5761455 (6e6)\end{lstlisting}
\subsubsection{Pollard Rho}
\begin{lstlisting}
typedef pair<ll, ll> PLL;
namespace Factor {
    const int N = 1010000;
    ll C, fac[10010], a[1001000];
    int cnt, prime[N], p[N], psize, _cnt;
    ll _e[100], _pr[100];
    vector<ll> d;

    // 快速乘
    inline ll mul(ll a, ll b, ll p) {
        if (p <= 1000000000) return a * b % p;
        else if (p <= 1000000000000ll) return (((a * (b >> 20) % p) << 20) + (a * (b & ((1 << 20) - 1)))) % p;
        else {
            ll d = (ll) floor(a * (long double) b / p + 0.5);
            ll ret = (a * b - d * p) % p;
            if (ret < 0) ret += p;
            return ret;
        }
    }

    // 素数筛
    void prime_table() {
        int i, j, tot, t1;
        for (i = 1; i <= psize; i++) p[i] = i;
        for (i = 2, tot = 0; i <= psize; i++) {
            if (p[i] == i) prime[++tot] = i;
            for (j = 1; j <= tot && (t1 = prime[j] * i) <= psize; j++) {
                p[t1] = prime[j];
                if (i % prime[j] == 0) break;
            }
        }
    }

    void init(int ps) {
        psize = ps;
        prime_table();
    }

    // 快速幂
    ll powl(ll a, ll n, ll p) {
        ll ans = 1;
        for (; n; n >>= 1) {
            if (n & 1) ans = mul(ans, a, p);
            a = mul(a, a, p);
        }
        return ans;
    }

    bool witness(ll a, ll n) {
        int t = 0;
        ll u = n - 1;
        for (; ~u & 1; u >>= 1) t++;
        ll x = powl(a, u, n), _x = 0;
        for (; t; t--) {
            _x = mul(x, x, n);
            if (_x == 1 && x != 1 && x != n - 1) return 1;
            x = _x;
        }
        return _x != 1;
    }

    // n 是否为素数
    bool miller(ll n) {
        if (n < 2) return 0;
        if (n <= psize) return p[n] == n;
        if (~n & 1) return 0;
        for (int j = 0; j <= 7; j++) if (witness(rand() % (n - 1) + 1, n)) return 0;
        return 1;
    }

    ll gcd(ll a, ll b) {
        ll ret = 1;
        while (a != 0) {
            if ((~a & 1) && (~b & 1)) ret <<= 1, a >>= 1, b >>= 1;
            else if (~a & 1) a >>= 1;
            else if (~b & 1) b >>= 1;
            else {
                if (a < b) swap(a, b);
                a -= b;
            }
        }
        return ret * b;
    }

    // 求 n 的一个素因子
    ll rho(ll n) {
        for (;;) {
            ll X = rand() % n, Y, Z, T = 1, *lY = a, *lX = lY;
            int tmp = 20;
            C = rand() % 10 + 3;
            X = mul(X, X, n) + C;
            *(lY++) = X;
            lX++;
            Y = mul(X, X, n) + C;
            *(lY++) = Y;
            for (; X != Y;) {
                ll t = X - Y + n;
                Z = mul(T, t, n);
                if (Z == 0) return gcd(T, n);
                tmp--;
                if (tmp == 0) {
                    tmp = 20;
                    Z = gcd(Z, n);
                    if (Z != 1 && Z != n) return Z;
                }
                T = Z;
                Y = *(lY++) = mul(Y, Y, n) + C;
                Y = *(lY++) = mul(Y, Y, n) + C;
                X = *(lX++);
            }
        }
    }

    void _factor(ll n) {
        for (int i = 0; i < cnt; i++) {
            if (n % fac[i] == 0) n /= fac[i], fac[cnt++] = fac[i];
        }
        if (n <= psize) {
            for (; n != 1; n /= p[n]) fac[cnt++] = p[n];
            return;
        }
        if (miller(n)) fac[cnt++] = n;
        else {
            ll x = rho(n);
            _factor(x);
            _factor(n / x);
        }
    }

    void dfs(ll x, int dep) {
        if (dep == _cnt) d.push_back(x);
        else {
            dfs(x, dep + 1);
            for (int i = 1; i <= _e[dep]; i++) dfs(x *= _pr[dep], dep + 1);
        }
    }

    void norm() {
        sort(fac, fac + cnt);
        _cnt = 0;
        for (int i = 0; i < cnt; ++i)
            if (i == 0 || fac[i] != fac[i - 1]) _pr[_cnt] = fac[i], _e[_cnt++] = 1;
            else _e[_cnt - 1]++;
    }

    vector<ll> getd() {
        d.clear();
        dfs(1, 0);
        return d;
    }

    // 返回所有因子
    vector<ll> factor(ll n) {
        cnt = 0;
        _factor(n);
        norm();
        return getd();
    }

    // 返回所有素因子
    vector<PLL> factorG(ll n) {
        cnt = 0;
        _factor(n);
        norm();
        vector<PLL> d;
        for (int i = 0; i < _cnt; ++i) d.push_back(make_pair(_pr[i], _e[i]));
        return d;
    }

    // a 是否为 p 的原根
    bool is_primitive(ll a, ll p) {
        vector<PLL> D = factorG(p - 1);
        for (int i = 0; i < (int) D.size(); ++i) if (powl(a, (p - 1) / D[i].first, p) == 1) return 0;
        return 1;
    }

    // a 关于 g 的阶
    int findorder(ll a, ll p) {
        vector<PLL> D = factorG(p - 1);
        int t = p - 1;
        for (int i = 0; i < (int) D.size(); ++i) {
            while (t % D[i].first == 0 && powl(a, t / D[i].first, p) == 1) t /= D[i].first;
        }
        return t;
    }
}\end{lstlisting}
\subsubsection{解乘法逆元}
\begin{lstlisting}
void exgcd(ll a, ll b, ll c, ll d, ll &x, ll &y) {
    ll z = (a + b - 1) / b;
    if (z <= c / d) {
        x = z;
        y = 1;
        return;
    }
    a -= (z - 1) * b; c -= (z - 1) * d;
    exgcd(d, c, b, a, y, x);
    x += (z - 1) * y;
}

// 求 a/b mod p = x mod p，优先 b 小
pair<ll, ll> invInv(ll p, ll x) {
    ll b, y;
    exgcd(p, x, p, x - 1, b, y);
    return {b * x - p * y, b};
}\end{lstlisting}
\subsubsection{EulerPhi}
\begin{lstlisting}
//计算欧拉phi函数，phi(n)且与n互素的正整数个数

//单点欧拉 O(sqrt(n))
ll euler(ll n) {
    ll rea = n;
    for (ll i = 2; i * i <= n; i++)
        if (n % i == 0) {
            rea = rea - rea / i;
            while (n % i == 0) n /= i;
        }
    if (n > 1) rea = rea - rea / n;
    return rea;
}


// maxn 为根号最值
// maxprime 为 maxn 内素数个数
// 素数线筛 + 单点求值
int prim[maxprime], cnt;
bool v[maxn];
void init() {
    v[0] = v[1] = 1;
    for (int i = 2; i < maxn; i++) {
        if (!v[i]) prim[++cnt] = i;
        for (int j = 1; j <= cnt && i * prim[j] < maxn; j++) {
            v[i * prim[j]] = 1;
            if (!(i % prim[j])) break;
        }
    }
}
ll phi(ll n) {
    ll rea = n;
    for (ll i = 1; prim[i] * prim[i] <= n; i++)
        if (n % prim[i] == 0) {
            rea = rea - rea / n;
            while (n % prim[i] == 0) n /= prim[i];
        }
    if (n > 1) rea = rea - rea / n;
    return rea;
}


// 线筛素数+欧拉函数
int phi[maxn], prim[maxprime], cnt;
bool v[maxn];
void init() {
    phi[1] = 1;
    for (int i = 2; i < maxn; ++i) {
        if (!v[i]) prim[++cnt] = i, phi[i] = i - 1;
        for (int j = 1; j <= cnt; ++j) {
            if (i * prim[j] >= maxn) break;
            v[i * prim[j]] = 1;
            if (i % prim[j] == 0) {
                phi[i * prim[j]] = phi[i] * prim[j]; break;
            } else phi[i * prim[j]] = phi[i] * phi[prim[j]];
        }
    }
}\end{lstlisting}
\subsubsection{求素因子}
\begin{lstlisting}
vector<pair<ll, int> > getFactors(ll x) {
    vector<pair<ll, int>> fact;
    for (int i = 1; prim[i] <= x / prim[i]; i++) {
        if (x % prim[i] == 0) {
            fact.emplace_back(prim[i], 0);
            while (x % prim[i] == 0) fact.back().second++, x /= prim[i];
        }
    }
    if (x != 1) fact.emplace_back(x, 1);
    return fact;
}\end{lstlisting}
\subsubsection{gcd}
\begin{lstlisting}
ll gcd(ll a,ll b) {while(b^=a^=b^=a%=b);return a;}

ll gcd(ll a,ll b){ return b==0?a:gcd(b,a%b); }

ll exgcd(ll a, ll b, ll &x, ll &y) {
    ll d = a;
    if (b) d = exgcd(b, a % b, y, x), y -= x * (a / b);
    else x = 1, y = 0;
    return d;
}

// ax + by = c
// x = x + k*dx
// y = y - k*dx
// 当x和y都非负时返回1，x，y即为当前最小非负整数解（优先x）
bool solve(ll a, ll b, ll c, ll &x, ll &y, ll &dx, ll &dy) {
    x = y = dx = dy = 0;
    if (a == 0 && b == 0) return 0;
    ll x0, y0;
    ll d = exgcd(a, b, x0, y0);
    if (c % d != 0) return 0;
    dx = b / d, dy = a / d;
    x = (x0 % dx * ((c / d) % dx) % dx + dx) % dx;
    y = (c - a * x) / b;
    // 删掉这一句返回x的最小非负整数解
    if (y < 0) return 0;
    return 1;
}\end{lstlisting}
\subsubsection{区间筛}
\begin{lstlisting}
bool f[maxlen];
bool sieve[maxn];

// maxn 至少为 sqrt(R)，预处理
void init() {
    for (int i = 2; i < maxn; i++) sieve[i] = true;
    for (int i = 2; i * i < maxn; i++) {
        if (sieve[i]) {
            for (int j = i * 2; j < maxn; j += i) {
                sieve[j] = false;
            }
        }
    }
}
// 计算 [L,R] 素性，f[i] 为 1 表示 i+L 为素数
void cal(ll L, ll R) {
    int len = R - L + 1;
    for (int i = 0; i < len; i++) f[i] = true;
    if (1 - L >= 0) f[1 - L] = false;
    for (ll i = 2; i * i < R; i++) {
        if (sieve[i]) {
            for (ll j = max(1ll * 2, (L - 1 + i) / i) * i; j <= R; j += i) f[j - L] = false;
        }
    }
}\end{lstlisting}
\subsubsection{欧拉降幂}
\begin{lstlisting}
const int maxn = 1e7+50;

int prim[maxn], vis[maxn];
int tot, phi[maxn];
struct node {
    ll res;
    bool v;
};

node qpow(ll A, ll B, ll C) {
    ll re = 1;
    bool flag = true;
    while (B) {
        if (B & 1) {
            if ((re *= A) >= C) flag = 0;
            re = re % C;
        }
        B = B >> 1;
        if (B) {
            if (A >= C) flag = 0;
            A %= C;
            if ((A *= A) >= C) flag = 0;
            A %= C;
        }
    }
    return node{re, flag};
}

void init(int n) {
    phi[1] = 1;
    for (int i = 2; i <= n; i++) {
        if (!vis[i]) {
            prim[++tot] = i;
            phi[i] = i - 1;
        }
        for (int j = 1; j <= tot && prim[j] * i <= n; j++) {
            vis[i * prim[j]] = 1;
            if (i % prim[j] == 0) {
                phi[i * prim[j]] = phi[i] * prim[j];
                break;
            } else phi[i * prim[j]] = phi[i] * (prim[j] - 1);
        }

    }
}


inline ll Euler(ll x) {
    if (x < maxn) return phi[x];
    return 0;
}

node f(ll a, ll k, ll p) {
    if (p == 1) return node{0, 0};
    if (k == 0) return node{a % p, a < p};
    ll ep = Euler(p);
    node tmp = f(a, k - 1, ep);
    if (__gcd(a, p) == 1)return qpow(a, tmp.res, p);
    if (!tmp.v) {
        tmp.res += ep;
    }
    return qpow(a, tmp.res, p);
}

int main() {
    ll a, k, p;
    init(1e7+2);
    int T;
    scanf("%d", &T);
    for (int kase = 1; kase <= T; ++kase) {
        // k次a次方模p的值
        scanf("%lld%lld%lld", &a, &k, &p);
        if (k == 0) printf("%lld\n", 1 % p);
        else printf("%lld\n", f(a, k - 1, p).res);
    }
    return 0;
}\end{lstlisting}
\subsubsection{dirichlet}
\begin{lstlisting}
#define poly vector<int>

// mod need to be prim
namespace dirichlet {
    int inv[maxn], cnt[maxn];
    bool vis[maxn];
    void init(int n) {
        cnt[1] = 1;
        for (int i = 2; i <= n; ++i) {
            if (!vis[i]) {
                cnt[i] = 1;
                for (int j = 2, k = i * j; k <= n; ++j, k += i) {
                    vis[k] = true;
                    if (!cnt[k] && cnt[j]) cnt[k] = cnt[j] + 1;
                }
            }
        }
        inv[1] = 1;
        // no need to n (1e6 need 128)
        for (int i = 2; i <= n; ++i) inv[i] = 1ll * (mod - mod / i) * inv[mod % i] % mod;
    }

    // no need to init, nlogn
    poly mul(poly a, poly b) {
        int n = max(a.size(), b.size()) - 1;
        while ((int)a.size() <= n) a.push_back(0);
        while ((int)b.size() <= n) b.push_back(0);
        poly d(n + 1);
        for (int i = 1; i <= n; ++i) {
            for (int j = 1, k = i; k <= n; k += i, ++j) d[k] = (d[k] + 1ll * a[i] * b[j]) % mod;
        }
        return d;
    }

    // nlogn
    poly qp(poly a, int k) {
        k %= mod;
        if (k < 0) k += mod;
        int n = a.size() - 1;
        poly g(n + 1);
        poly tf = a;
        for (int i = 1; i <= n; ++i) a[i] = 1ll * a[i] * cnt[i] % mod * k % mod;
        for (int i = 1; i <= n; ++i) {
            int v = g[i];
            g[i] = 1ll * g[i] * inv[cnt[i]] % mod + (i == 1);
            for (int j = 2, t = i + i; t <= n; ++j, t += i)
                g[t] = (g[t] + 1ll * g[i] * a[j]) % mod;
            for (int j = 2, t = i + i; t <= n; ++j, t += i)
                g[t] = (g[t] + 1ll * (mod - tf[j]) * v) % mod;
        }
        return g;
    }

    // nlogn
    inline poly ln(const poly& a) {
        int n = a.size() - 1;
        poly b(n + 1);
        for (int i = 2; i <= n; ++i) b[i] = 1ll * a[i] * cnt[i] % mod;
        for (int i = 2; i <= n; ++i) {
            for (int j = 2, k = i * j; k <= n; ++j, k += i) b[k] = (b[k] - 1ll * b[i] * a[j]) % mod;
            b[i] = 1ll * b[i] * inv[cnt[i]] % mod;
            if (b[i] < 0) b[i] += mod;
        }
        return b;
    }

    // nlogn
    inline poly exp(poly a) {
        int n = a.size() - 1;
        poly b(n + 1);
        for (int i = 2; i <= n; ++i) a[i] = 1ll * a[i] * cnt[i] % mod;
        b[1] = 1;
        for (int i = 1; i <= n; ++i) {
            b[i] = 1ll * b[i] * inv[cnt[i]] % mod;
            for (int j = 2, k = i * j; k <= n; ++j, k += i) b[k] = (b[k] + 1ll * b[i] * a[j]) % mod;
        }
        return b;
    }
}
using namespace dirichlet;\end{lstlisting}
\subsection{同余}
\subsubsection{逆元}
\begin{lstlisting}
/*
1.费马小定理
条件:mod为素数
*/
ll inv(ll x) { return qp(x, mod - 2); }

/*
2.扩展欧几里得
条件:gcd(a,mod)==1
如果gcd(a,mod)!=1 返回-1
*/
ll inv(ll a, ll p) {
    ll g, x, y;
    g = exgcd(a, p, x, y);
    return g == 1 ? (x + p) % p : -1;
}

/*
3.公式
a/b%mod=c
->a%(b*mod)/b=c
*/

/*
4.逆元打表
p是模
p要求是奇素数
*/
ll inv[maxn];

void getinv(int n, ll p) {
    inv[1] = 1;
    for (int i = 2; i <= n; i++) inv[i] = (p - p / i) * inv[p % i] % p;
}

// log逆元
ll dlog(ll g, ll b, ll p) {
    ll m = sqrt(p - 1);
    map<ll, ll> powers;
    for (long j = 0; j < m; j++) powers[qp(g, j, p)] = j;
    long gm = qp(g, -m + 2 * (p - 1), p);
    for (int i = 0; i < m; i++) {
        if (powers[b]) return i * m + powers[b];
        b = b * gm % p;
    }
    return -1;
}\end{lstlisting}
\subsubsection{中国剩余定理}
\begin{lstlisting}
void exgcd(ll a, ll b, ll &x, ll &y) {
    if (b) exgcd(b, a % b, y, x), y -= x * (a / b);
    else x = 1, y = 0;
}

// x % m[i] = a[i]
ll crt(const vector<ll>& m, const vector<ll>& a) {
    ll M = 1, ans = 0;
    int n = a.size();
    for (int i = 0; i < n; i++) M *= m[i];
    for (int i = 0; i < n; i++) {
        ll x = 0, y = 0, Mi = M / m[i];
        exgcd(Mi, m[i], x, y);
        ans = (ans + Mi % M * x % M * a[i] % M + M) % M;
    }
    if (ans < 0) ans += M;
    return ans;
}\end{lstlisting}
\subsubsection{扩展中国剩余定理}
\begin{lstlisting}
ll exgcd(ll a, ll b, ll &x, ll &y) {
    ll d = a;
    if (b) d = exgcd(b, a % b, y, x), y -= x * (a / b);
    else x = 1, y = 0;
    return d;
}

// x % m[i] = a[i]
ll excrt(const vector<ll> &m, const vector<ll> &a) {
    ll M = m[0], R = a[0];
    int n = a.size();
    for (int i = 1; i < n; i++) {
        ll x = 0, y = 0, d = exgcd(M, m[i], x, y);
        if ((R - a[i]) % d) return -1;
//        x = mul((R - a[i]) / d, x, m[i]);
        x = (R - a[i]) / d * x % m[i];
        R -= M * x;
        M = M / d * m[i];
        R %= M;
    }
    if (R < 0) R += M;
    return R;
}\end{lstlisting}
\subsubsection{BSGS}
\begin{lstlisting}
// 求 a^x = b % p
int BSGS(int a, int b, int p) {
    map<int, int> hash;
    b %= p;
    int t = (int) sqrt(p) + 1;
    for (int j = 0; j < t; j++) {
        int val = 1ll * b * qp(a, j, p) % p;
        hash[val] = j;
    }
    a = qp(a, t, p);
    if (a == 0) return b == 0 ? 1 : -1;
    for (int i = 0; i <= t; i++) {
        int val = qp(a, i, p);
        int j = hash.find(val) == hash.end() ? -1 : hash[val];
        if (j >= 0 && i * t - j >= 0) return i * t - j;
    }
    return -1;
}\end{lstlisting}
\subsubsection{exBSGS}
\begin{lstlisting}
unordered_map<int, int> Hash;

int exBSGS(int a, int b, int p) {
    a %= p, b %= p;
    if (b == 1) return 0;
    if (!b && !a) return 1;
    if (!a) return -1;
    if (!b) {
        int ret = 0, d;
        while ((d = __gcd(a, p)) != 1) {
            ++ret, p /= d;
            if (p == 1) return ret;
        }
        return -1;
    }
    int ret = 0, A = a, B = b, P = p, C = 1, d;
    while ((d = __gcd(A, P)) != 1) {
        if (B % d) return -1;
        P /= d, B /= d;
        C = 1ll * C * (A / d) % P;
        ++ret;
        if (C == B) return ret;
    }
    Hash.clear();
    int f = 1, t = sqrt(P) + 1;
    for (int i = 0; i < t; i++) {
        Hash[1ll * f * B % P] = i;
        f = 1ll * f * A % P;
    }
    int tf = f;
    f = 1ll * f * C % P;
    for (int i = 1; i <= t; i++) {
        if (Hash.find(f) != Hash.end()) return ret + i * t - Hash[f];
        f = 1ll * f * tf % P;
    }
    return -1;
}\end{lstlisting}
\subsubsection{模素数二次同余方程}
\begin{lstlisting}
// 要求模为素数，输入n, mod，返回 x^2 % mod = n，可解任意一元二次方程

bool Legendre(ll a, ll p) {
    return qp(a, p - 1 >> 1, p) == 1;
}

ll modsqr(ll a, ll p) {
    ll x;
    ll i, k, b;
    if (p == 2) x = a % p;
    else if (p % 4 == 3) x = qp(a, p + 1 >> 2, p);
    else {
        for (b = 1; Legendre(b, p); ++b);
        i = p - 1 >> 1;
        k = 0;
        do {
            i >>= 1;
            k >>= 1;
            if (!((1LL * qp(a, i, p) * qp(b, k, p) + 1) % p)) k += p - 1 >> 1;
        } while (!(i & 1));
        x = 1ll * qp(a, i + 1 >> 1, p) * qp(b, k >> 1, p) % p;
    }
    return min(x, p - x);
//    if(p-x<x) x=p-x;
//    if(x==p-x) printf("%d\n",x);
//    else printf("%d %d\n",x,p-x);
}\end{lstlisting}
\subsection{线代}
\subsubsection{线性基}
\begin{lstlisting}
struct Base {
#define TYPE ll
    static const int len = 64;
    bool rel; int sz;
    TYPE a[len];

    void init() {
        rel = sz = 0;
        memset(a, 0, sizeof a);
    }

    TYPE &operator[](int x) {
        return a[x];
    }

    TYPE operator[](int x) const {
        return a[x];
    }


    void ins(ll x) {
        for(int i = 63; i >= 0; i --) {
            if((x >> i) & 1) {
                if(!d[i]) return void(d[i] = x);
                x ^= d[i];
            }
        }
    }

    void insert(TYPE t) {
        for (int i = len - 1; i >= 0; --i) {
            if (!(t >> i & 1)) continue;
            if (a[i]) t ^= a[i];
            else {
                for (int j = 0; j < i; ++j) if (t >> j & 1) t ^= a[j];
                for (int j = i+1; j < len; ++j) if (a[j] >> i & 1) a[j] ^= t;
                a[i] = t;
                ++sz;
                return;
            }
        }
        rel = true;
    }

    bool check(TYPE x) {
        for (int i = len - 1; i >= 0; i--)
            if ((x >> i) & 1) {
                if (a[i]) x ^= a[i];
                else return false;
            }
        return true;
    }
    TYPE mx() {
        TYPE res = 0;
        for (int i = len - 1; i >= 0; --i) {
            if ((res ^ (a[i])) > res) res ^= a[i];
        }
        return res;
    }
//    vector<TYPE> v;
//    void basis() {for (int i = 0; i < len; ++i) if (a[i]) v.push_back(a[i]);}
//    TYPE k_th(TYPE k) {
//        k -= rel;
//        if(k >= (((TYPE)1) << sz)) return -1;
//        TYPE ans = 0;
//        for(int i = 0; i < (int)v.size(); i ++) if(k & (((TYPE)1) << i)) ans ^= v[i];
//        return ans;
//    }
//    void init()
//    {
//        sz = 0;
//        for(int i = 0; i < len; i ++) if(a[i])
//                for(int j = 0; j < i; j ++)
//                    if(a[i] & (1ll << j)) a[i] ^= a[j];
//        for(int i = 0; i < len; i ++) if(a[i]) a[sz ++] = a[i];
//    }
    friend Base intersection(const Base &a, const Base &b) {
        Base ans = {}, c = b, d = b;
        for (int i = 0; i < len; i++) {
            TYPE x = a[i];
            if (!x)continue;
            int j = i;
            TYPE T = 0;
            for (; j >= 0; --j) {
                if ((x >> j) & 1)
                    if (c[j]) {
                        x ^= c[j];
                        T ^= d[j];
                    }
                    else break;
            }
            if (!x)ans[i] = T;
            else {
                c[j] = x;
                d[j] = T;
            }
        }
        return ans;
    }

#undef TYPE
};

// 前缀线性基
struct LinearBasis {
    int f[20], g[20];

    void ins(int x, int idx) {
        for (int i = 19; ~i; i--) {
            if ((x >> i) & 1) {
                if (f[i]) {
                    if (g[i] <= idx) {
                        x ^= f[i];
                        f[i] ^= x;
                        swap(g[i], idx);
                    }
                    else x ^= f[i];
                } else {
                    f[i] = x;
                    g[i] = idx;
                    break;
                }
            }
        }
    }

    int query(int l) {
        int res = 0;
        for (int i = 19; ~i; i--)
            if (g[i] >= l)
                res = max(res, res ^ f[i]);
        return res;
    }
} base[maxn];\end{lstlisting}
\subsubsection{高斯消元}
\begin{lstlisting}
int n;
double b[maxn], c[maxn][maxn];
//c：系数矩阵，b：常数

void guass() {
    for (int i = 1; i <= n; i++) {
        for (int j = i; j <= n; j++)
            if (fabs(c[j][i]) > eps) {
                for (int k = 1; k <= n; k++) swap(c[i][k], c[j][k]);
                swap(b[i], b[j]);
            }
        for (int j = 1; j <= n; j++) {
            if (i == j) continue;
            double rate = c[j][i] / c[i][i];
            for (int k = i; k <= n; k++) c[j][k] -= c[i][k] * rate;
            b[j] -= b[i] * rate;
        }
    }
}\end{lstlisting}
\subsubsection{BM}
\begin{lstlisting}
//Berlekamp-Massey
typedef vector<int> VI;
namespace linear_seq
{
#define rep(i,a,n) for (int i=a;i<n;i++)
#define SZ(x) ((int)(x).size())
#define pb(x) push_back(x)
    const ll mod=1e9+7;
    ll powmod(ll a,ll b){ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}
    const int N=10010;
    ll res[N],base[N],_c[N],_md[N];
    vector<int> Md;
    void mul(ll *a,ll *b,int k)
    {
        rep(i,0,k+k) _c[i]=0;
        rep(i,0,k) if (a[i]) rep(j,0,k) _c[i+j]=(_c[i+j]+a[i]*b[j])%mod;
        for (int i=k+k-1;i>=k;i--) if (_c[i])
                rep(j,0,SZ(Md)) _c[i-k+Md[j]]=(_c[i-k+Md[j]]-_c[i]*_md[Md[j]])%mod;
        rep(i,0,k) a[i]=_c[i];
    }
    int solve(ll n,VI a,VI b){
        ll ans=0,pnt=0;
        int k=SZ(a);
        assert(SZ(a)==SZ(b));
        rep(i,0,k) _md[k-1-i]=-a[i];_md[k]=1;
        Md.clear();
        rep(i,0,k) if (_md[i]!=0) Md.push_back(i);
        rep(i,0,k) res[i]=base[i]=0;
        res[0]=1;
        while ((1ll<<pnt)<=n) pnt++;
        for (int p=pnt;p>=0;p--) {
            mul(res,res,k);
            if ((n>>p)&1) {
                for (int i=k-1;i>=0;i--) res[i+1]=res[i];res[0]=0;
                rep(j,0,SZ(Md)) res[Md[j]]=(res[Md[j]]-res[k]*_md[Md[j]])%mod;
            }
        }
        rep(i,0,k) ans=(ans+res[i]*b[i])%mod;
        if (ans<0) ans+=mod;
        return ans;
    }
    VI BM(VI s){
        VI C(1,1),B(1,1);
        int L=0,m=1,b=1;
        rep(n,0,SZ(s)){
            ll d=0;
            rep(i,0,L+1) d=(d+(ll)C[i]*s[n-i])%mod;
            if(d==0) ++m;
            else if(2*L<=n){
                VI T=C;
                ll c=mod-d*powmod(b,mod-2)%mod;
                while (SZ(C)<SZ(B)+m) C.pb(0);
                rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod;
                L=n+1-L; B=T; b=d; m=1;
            } else {
                ll c=mod-d*powmod(b,mod-2)%mod;
                while (SZ(C)<SZ(B)+m) C.pb(0);
                rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod;
                ++m;
            }
        }
        return C;
    }
    int gao(VI a,ll n)
    {
        VI c=BM(a);
        c.erase(c.begin());
        rep(i,0,SZ(c)) c[i]=(mod-c[i])%mod;
        return solve(n,c,VI(a.begin(),a.begin()+SZ(c)));
    }
};//linear_seq::gao(VI{},n-1)\end{lstlisting}
\subsubsection{exBM}
\begin{lstlisting}
// given first m items init[0..m-1] and coefficents trans[0..m-1] or
// given first 2 *m items init[0..2m-1], it will compute trans[0..m-1]
// for you. trans[0..m] should be given as that
//      init[m] = sum_{i=0}^{m-1} init[i] * trans[i]
struct LinearRecurrence
{
    using int64 = long long;
    using vec = std::vector<int64>;

    static void extand(vec& a, size_t d, int64 value = 0)
    {
        if (d <= a.size()) return;
        a.resize(d, value);
    }
    static vec BerlekampMassey(const vec& s, int64 mod)
    {
        std::function<int64(int64)> inverse = [&](int64 a) {
            return a == 1 ? 1 : (int64)(mod - mod / a) * inverse(mod % a) % mod;
        };
        vec A = {1}, B = {1};
        int64 b = s[0];
        for (size_t i = 1, m = 1; i < s.size(); ++i, m++)
        {
            int64 d = 0;
            for (size_t j = 0; j < A.size(); ++j)
            {
                d += A[j] * s[i - j] % mod;
            }
            if (!(d %= mod)) continue;
            if (2 * (A.size() - 1) <= i)
            {
                auto temp = A;
                extand(A, B.size() + m);
                int64 coef = d * inverse(b) % mod;
                for (size_t j = 0; j < B.size(); ++j)
                {
                    A[j + m] -= coef * B[j] % mod;
                    if (A[j + m] < 0) A[j + m] += mod;
                }
                B = temp, b = d, m = 0;
            }
            else
            {
                extand(A, B.size() + m);
                int64 coef = d * inverse(b) % mod;
                for (size_t j = 0; j < B.size(); ++j)
                {
                    A[j + m] -= coef * B[j] % mod;
                    if (A[j + m] < 0) A[j + m] += mod;
                }
            }
        }
        return A;
    }
    static void exgcd(int64 a, int64 b, int64& g, int64& x, int64& y)
    {
        if (!b)
            x = 1, y = 0, g = a;
        else
        {
            exgcd(b, a % b, g, y, x);
            y -= x * (a / b);
        }
    }
    static int64 crt(const vec& c, const vec& m)
    {
        int n = c.size();
        int64 M = 1, ans = 0;
        for (int i = 0; i < n; ++i) M *= m[i];
        for (int i = 0; i < n; ++i)
        {
            int64 x, y, g, tm = M / m[i];
            exgcd(tm, m[i], g, x, y);
            ans = (ans + tm * x * c[i] % M) % M;
        }
        return (ans + M) % M;
    }
    static vec ReedsSloane(const vec& s, int64 mod)
    {
        auto inverse = [](int64 a, int64 m) {
            int64 d, x, y;
            exgcd(a, m, d, x, y);
            return d == 1 ? (x % m + m) % m : -1;
        };
        auto L = [](const vec& a, const vec& b) {
            int da = (a.size() > 1 || (a.size() == 1 && a[0])) ? a.size() - 1 : -1000;
            int db = (b.size() > 1 || (b.size() == 1 && b[0])) ? b.size() - 1 : -1000;
            return std::max(da, db + 1);
        };
        auto prime_power = [&](const vec& s, int64 mod, int64 p, int64 e) {
            // linear feedback shift register mod p^e, p is prime
            std::vector<vec> a(e), b(e), an(e), bn(e), ao(e), bo(e);
            vec t(e), u(e), r(e), to(e, 1), uo(e), pw(e + 1);
            ;
            pw[0] = 1;
            for (int i = pw[0] = 1; i <= e; ++i) pw[i] = pw[i - 1] * p;
            for (int64 i = 0; i < e; ++i)
            {
                a[i] = {pw[i]}, an[i] = {pw[i]};
                b[i] = {0}, bn[i] = {s[0] * pw[i] % mod};
                t[i] = s[0] * pw[i] % mod;
                if (t[i] == 0)
                {
                    t[i] = 1, u[i] = e;
                }
                else
                {
                    for (u[i] = 0; t[i] % p == 0; t[i] /= p, ++u[i])
                        ;
                }
            }
            for (size_t k = 1; k < s.size(); ++k)
            {
                for (int g = 0; g < e; ++g)
                {
                    if (L(an[g], bn[g]) > L(a[g], b[g]))
                    {
                        ao[g] = a[e - 1 - u[g]];
                        bo[g] = b[e - 1 - u[g]];
                        to[g] = t[e - 1 - u[g]];
                        uo[g] = u[e - 1 - u[g]];
                        r[g] = k - 1;
                    }
                }
                a = an, b = bn;
                for (int o = 0; o < e; ++o)
                {
                    int64 d = 0;
                    for (size_t i = 0; i < a[o].size() && i <= k; ++i)
                    {
                        d = (d + a[o][i] * s[k - i]) % mod;
                    }
                    if (d == 0)
                    {
                        t[o] = 1, u[o] = e;
                    }
                    else
                    {
                        for (u[o] = 0, t[o] = d; t[o] % p == 0; t[o] /= p, ++u[o])
                            ;
                        int g = e - 1 - u[o];
                        if (L(a[g], b[g]) == 0)
                        {
                            extand(bn[o], k + 1);
                            bn[o][k] = (bn[o][k] + d) % mod;
                        }
                        else
                        {
                            int64 coef = t[o] * inverse(to[g], mod) % mod * pw[u[o] - uo[g]] % mod;
                            int m = k - r[g];
                            extand(an[o], ao[g].size() + m);
                            extand(bn[o], bo[g].size() + m);
                            for (size_t i = 0; i < ao[g].size(); ++i)
                            {
                                an[o][i + m] -= coef * ao[g][i] % mod;
                                if (an[o][i + m] < 0) an[o][i + m] += mod;
                            }
                            while (an[o].size() && an[o].back() == 0) an[o].pop_back();
                            for (size_t i = 0; i < bo[g].size(); ++i)
                            {
                                bn[o][i + m] -= coef * bo[g][i] % mod;
                                if (bn[o][i + m] < 0) bn[o][i + m] -= mod;
                            }
                            while (bn[o].size() && bn[o].back() == 0) bn[o].pop_back();
                        }
                    }
                }
            }
            return std::make_pair(an[0], bn[0]);
        };

        std::vector<std::tuple<int64, int64, int>> fac;
        for (int64 i = 2; i * i <= mod; ++i)
        {
            if (mod % i == 0)
            {
                int64 cnt = 0, pw = 1;
                while (mod % i == 0) mod /= i, ++cnt, pw *= i;
                fac.emplace_back(pw, i, cnt);
            }
        }
        if (mod > 1) fac.emplace_back(mod, mod, 1);
        std::vector<vec> as;
        size_t n = 0;
        for (auto&& x : fac)
        {
            int64 mod, p, e;
            vec a, b;
            std::tie(mod, p, e) = x;
            auto ss = s;
            for (auto&& x : ss) x %= mod;
            std::tie(a, b) = prime_power(ss, mod, p, e);
            as.emplace_back(a);
            n = std::max(n, a.size());
        }
        vec a(n), c(as.size()), m(as.size());
        for (size_t i = 0; i < n; ++i)
        {
            for (size_t j = 0; j < as.size(); ++j)
            {
                m[j] = std::get<0>(fac[j]);
                c[j] = i < as[j].size() ? as[j][i] : 0;
            }
            a[i] = crt(c, m);
        }
        return a;
    }

    LinearRecurrence(const vec& s, const vec& c, int64 mod) : init(s), trans(c), mod(mod), m(s.size()) {}
    LinearRecurrence(const vec& s, int64 mod, bool is_prime = true) : mod(mod)
    {
        vec A;
        if (is_prime)
            A = BerlekampMassey(s, mod);
        else
            A = ReedsSloane(s, mod);
        if (A.empty()) A = {0};
        m = A.size() - 1;
        trans.resize(m);
        for (int i = 0; i < m; ++i)
        {
            trans[i] = (mod - A[i + 1]) % mod;
        }
        std::reverse(trans.begin(), trans.end());
        init = {s.begin(), s.begin() + m};
    }
    int64 calc(int64 n)
    {
        if (mod == 1) return 0;
        if (n < m) return init[n];
        vec v(m), u(m << 1);
        int msk = !!n;
        for (int64 m = n; m > 1; m >>= 1) msk <<= 1;
        v[0] = 1 % mod;
        for (int x = 0; msk; msk >>= 1, x <<= 1)
        {
            std::fill_n(u.begin(), m * 2, 0);
            x |= !!(n & msk);
            if (x < m)
                u[x] = 1 % mod;
            else
            { // can be optimized by fft/ntt
                for (int i = 0; i < m; ++i)
                {
                    for (int j = 0, t = i + (x & 1); j < m; ++j, ++t)
                    {
                        u[t] = (u[t] + v[i] * v[j]) % mod;
                    }
                }
                for (int i = m * 2 - 1; i >= m; --i)
                {
                    for (int j = 0, t = i - m; j < m; ++j, ++t)
                    {
                        u[t] = (u[t] + trans[j] * u[i]) % mod;
                    }
                }
            }
            v = {u.begin(), u.begin() + m};
        }
        int64 ret = 0;
        for (int i = 0; i < m; ++i)
        {
            ret = (ret + v[i] * init[i]) % mod;
        }
        return ret;
    }

    vec init, trans;
    int64 mod;
    int m;
};\end{lstlisting}
\subsection{组合数学}
\subsubsection{Lucas}
\begin{lstlisting}
const int maxn = 1e6 + 10;

ll fac[maxn], inv[maxn], facinv[maxn];

void init() {
    fac[0] = inv[0] = facinv[0] = 1;
    fac[1] = inv[1] = facinv[1] = 1;
    for (int i = 2; i < maxn; i++) {
        fac[i] = fac[i - 1] * i % mod;
        inv[i] = mod - mod / i * inv[mod % i] % mod;
        facinv[i] = facinv[i - 1] * inv[i] % mod;
    }
}

ll C(int n, int k) {
    if (k > n || k < 0) return 0;
    return fac[n] * facinv[k] % mod * facinv[n - k] % mod;
}

ll lucas(ll n, ll m) {
    ll res = 1;
    while (n && m) {
        res = res * C(n % mod, m % mod) % mod;
        n /= mod;
        m /= mod;
    }
    return res;
}\end{lstlisting}
\subsubsection{exLucas}
\begin{lstlisting}
typedef long long ll;

ll p, n, m;

ll exgcd(ll a, ll b, ll &x, ll &y)
{
	if(!b) { x = 1; y = 0; return a; }
	ll res = exgcd(b, a % b, x, y), t;
	t = x, x = y, y = t - a / b * y;
	return res;
}

ll qp(ll a, ll n, ll mod)
{
	ll ans = 1, base = a;
	for(; n; n >>= 1, (base *= base) %= mod) if(n & 1) (ans *= base) %= mod;
	return ans; 
}

ll fac(ll n, ll a, ll b)
{
	if(!n) return 1;
	ll res = 1;
	for(ll i = 2; i <= b; i ++) 
		if(i % a) (res *= i) %= b;
	res = qp(res, n / b, b);
	for(ll i = 2; i <= n % b; i ++)
		if(i % a) (res *= i) %= b;
	return res * fac(n / a, a, b) % b;
}

ll inv(ll n, ll mod) 
{
	ll x, y;
	exgcd(n, mod, x, y);
	return (x += mod) > mod ? x - mod : x;
}

ll CRT(ll b, ll mod) { return b * inv(p / mod, mod) % p * (p / mod) % p; }

ll C(ll n, ll m, ll a, ll b)
{
	ll up = fac(n, a, b), d1 = fac(m, a, b), d2 = fac(n - m, a, b);
	ll k = 0;
	for(ll i = n; i; i /= a) k += i / a;
	for(ll i = m; i; i /= a) k -= i / a;
	for(ll i = n - m; i; i /= a) k -= i / a;
	return up * inv(d1, b) % b * inv(d2, b) % b * qp(a, k, b) % b; 
}

ll exlucas(ll n, ll m)
{
	ll res = 0, tmp = p, b;
	int lim = sqrt(p) + 5;
	for(int i = 2; i <= lim; i ++) if(tmp % i == 0)
	{
		b = 1;
		while(tmp % i == 0) tmp /= i, b *= i;
		(res += CRT(C(n, m, i, b), b)) %= p;
	}
	if(tmp > 1) (res += CRT(C(n, m, tmp, tmp), tmp)) %= p;
	return res;
}\end{lstlisting}
\subsubsection{递推组合数}
\begin{lstlisting}
// ---
// $0 \leq m \leq n \leq 1000$
// ---
const int maxn = 1010;
ll C[maxn][maxn];
void init() {
    C[0][0] = 1;
    for (int i = 1; i < maxn; i++)
    {
        C[i][0] = 1;
        for (int j = 1; j <= i; j++) C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;
    }
}

// ---
// $0 \leq m \leq n \leq 10^5$, 模$p$为素数
// ---
const int maxn = 100010;
ll f[maxn];
ll inv[maxn]; // 阶乘的逆元
void CalFact() {
    f[0] = 1;
    for (int i = 1; i < maxn; i++) f[i] = (f[i - 1] * i) % p;
    inv[maxn - 1] = qp(f[maxn - 1], p - 2);
    for (int i = maxn - 2; ~i; i--) inv[i] = inv[i + 1] * (i + 1) % p;
}
ll C(int n, int m) { return f[n] * inv[m] % p * inv[n - m] % p; }\end{lstlisting}
\subsubsection{小模数组合数}
\begin{lstlisting}
// ---
// $p$小$n$,$m$大
// ---

const int NICO = 100000+10;
const int MOD  = 99991;
ll f[NICO];  

ll Lucas(ll a,ll k) 
{  
    ll res = 1;  
    while(a && k)  
    {  
        ll a1 = a % MOD;
        ll b1 = k % MOD;  
        if(a1 < b1) return 0;
        res = res*f[a1]*qp(f[b1]*f[a1-b1]%MOD,MOD-2)%MOD;
        a /= MOD;  
        k /= MOD;  
    }  
    return res;  
}  

void init()  
{  
    f[0] = 1;
    for(int i=1;i<=MOD;i++) 
    { 
        f[i] = f[i-1]*i%MOD;    
    }
}  

int main()  
{  
    init();
    cout << Lucas(5,2) << endl;
}\end{lstlisting}
\subsubsection{大模数组合数}
\begin{lstlisting}
// ---
// $n$,$m$小$p$大
// ---
map<int, ll> m;

const int MOD = 1e9+7;
void fun(int n, int k) {
    for (int i = 2; i <= sqrt(n * 1.0); i++) {
        while (n % i == 0) {
            n /= i;
            m[i] += k;
        }
    }
    if (n > 1) {
        m[n] += k;
    }
}

ll C(ll a, ll b) {
    if (a < b || a < 0 || b < 0)
        return 0;
    m.clear();
    ll ret = 1;
    b = min(a - b, b);
    for (int i = 0; i < b; i++) {
        fun(a - i, 1);
    }
    for (int i = b; i >= 1; i--) {
        fun(i, -1);
    }
    for (__typeof(m.begin()) it = m.begin(); it != m.end(); it++) {
        if ((*it).second != 0) {
            ret *= qp((*it).first, (*it).second);
            ret %= MOD;
        }
    }
    return ret;
}

int main(int argc,char *argv[])
{
    ll a, b;
    while (scanf("%lld%lld", &a, &b) != EOF) {
        printf("%lld\n", C(a, b));
    }
    return 0;
}\end{lstlisting}
\subsection{多项式}
\subsubsection{FFT}
\begin{lstlisting}
// maxn 至少是大于m+n的2次方数
// m+n 2e5 maxn (1<<18)+50
// m+n 4e5 maxn (1<<19)+50
// m+n 2e6 maxn (1<<21)+50

// 普通fft
#include <bits/stdc++.h>

using namespace std;
typedef long long ll;

struct Complex {
    double r, i;

    Complex(double r, double i) : r(r), i(i) {}
    Complex() {}
    inline Complex operator+(const Complex &rhs) const { return Complex(r + rhs.r, i + rhs.i); }
    inline Complex operator-(const Complex &rhs) const { return Complex(r - rhs.r, i - rhs.i); }
    inline Complex operator*(const Complex &rhs) const { return Complex(r * rhs.r - i * rhs.i, r * rhs.i + i * rhs.r); }
    inline void operator/=(const double &x) { r /= x, i /= x; }
    inline void operator*=(const Complex &rhs) { *this = Complex(r * rhs.r - i * rhs.i, r * rhs.i + i * rhs.r); }
    inline void operator+=(const Complex &rhs) { r += rhs.r, i += rhs.i; }
};

const int maxn = 4e6 + 6;
#define PI 3.14159265354
int pos[maxn];

void init(const int &n) {
    for (int i = 0, j = 0; i < n; ++i) {
        pos[i] = j;
        for (int l = n >> 1; (j ^= l) < l; l >>= 1);
    }
}

void transform(Complex *a, const int &n, bool inverse) {
    for (int i = 0; i < n; ++i) if (i > pos[i]) std::swap(a[i], a[pos[i]]);
    for (int l = 2; l <= n; l <<= 1) {
        int m = l / 2;
        Complex omega = {cos(2 * PI / l), inverse ? -sin(2 * PI / l) : sin(2 * PI / l)};
        for (Complex *p = a; p != a + n; p += l) {
            Complex x = {1, 0};
            for (int i = 0; i < m; ++i, x *= omega) {
                Complex t = x * p[m + i];
                p[m + i] = p[i] - t;
                p[i] += t;
            }
        }
    }
}

void dft(Complex *a, const int &n) { transform(a, n, 0); }

void idft(Complex *a, const int &n) {
    transform(a, n, 1);
    for (int i = 0; i < n; ++i) a[i] /= n;
}

Complex A[maxn], B[maxn], C[maxn];

void FFT(int n, int m) {// len(A),len(B)
    int cnt = 1;
    while (cnt <= (n + m)) cnt <<= 1;
    init(cnt);
    dft(A, cnt);
    dft(B, cnt);
    for (int i = 0; i < cnt; i++) C[i] = A[i] * B[i];
    idft(C, cnt);
    for (int i = 0; i <= n + m; i++) C[i].r = ll(C[i].r + 0.01);
}

int main() {
    int n, m, tem;
    cin >> n >> m;
    for (int i = 0; i <= n; i++) scanf("%d", &tem), A[i].r = tem;
    for (int i = 0; i <= m; i++) scanf("%d", &tem), B[i].r = tem;
    FFT(n, m);
    for (int i = 0; i <= n + m; i++) printf("%lld ", ll(C[i].r));
    cout << "\n";
}

// 两次变换
#define ld double
const ld PI = acosl(-1);
struct cplx {
    ld a, b;
    cplx(ld a = 0, ld b = 0) : a(a), b(b) {}
    const cplx operator+(const cplx &c) const { return cplx(a + c.a, b + c.b); }
    const cplx operator-(const cplx &c) const { return cplx(a - c.a, b - c.b); }
    const cplx operator*(const cplx &c) const { return cplx(a * c.a - b * c.b, a * c.b + b * c.a); }
    const cplx operator/(const ld &x) const { return cplx(a / x, b / x); }
    const cplx conj() const { return cplx(a, -b); }
};
int rev[maxn];
cplx w[maxn];
cplx f[maxn];
void prepare(int &n) {
    int sz = __builtin_ctz(n);
    for (int i = 1; i < n; ++i) rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (sz - 1));
    w[0] = 0, w[1] = 1, sz = 1;
    while (1 << sz < n) {
        cplx w_n = cplx(cosl(2 * PI / (1 << (sz + 1))), sinl(2 * PI / (1 << (sz + 1))));
        for (int i = 1 << (sz - 1); i < (1 << sz); ++i) {
            w[i << 1] = w[i], w[i << 1 | 1] = w[i] * w_n;
        }
        ++sz;
    }
}
void fft(cplx *a, int n) {
    for (int i = 1; i < n - 1; ++i) if (i < rev[i]) swap(a[i], a[rev[i]]);
    for (int h = 1; h < n; h <<= 1) {
        for (int s = 0; s < n; s += h << 1) {
            for (int i = 0; i < h; ++i) {
                cplx &u = a[s + i], &v = a[s + i + h], t = v * w[h + i];
                v = u - t, u = u + t;
            }
        }
    }
}
template<class T>
vector<T> multiply(const vector<T> &a, const vector<T> &b) {
    int n = a.size(), m = b.size(), sz = 1;
    while (sz < n + m - 1) sz <<= 1;
    prepare(sz);
    for (int i = 0; i < sz; ++i) f[i] = cplx(i < n ? a[i] : 0, i < m ? b[i] : 0);
    fft(f, sz);
    for (int i = 0; i <= (sz >> 1); ++i) {
        int j = (sz - i) & (sz - 1);
        cplx x = (f[i] * f[i] - (f[j] * f[j]).conj()) * cplx(0, -0.25);
        f[j] = x, f[i] = x.conj();
    }
    fft(f, sz);
    vector<T> c(n + m - 1);
    for (int i = 0; i < n + m - 1; ++i) {
        c[i] = ((T) (f[i].a / sz + 0.3));
    }
    return c;
}
#undef ld\end{lstlisting}
\subsubsection{NTT}
\begin{lstlisting}
const static int N = 4e6 + 6;
typedef long long ll;
ll pos[N];
const ll mod = 998244353, root = 3;
inline ll fastpow(ll a, ll b) {
    ll ans = 1;
    for (;b;a=a*a%mod,b>>=1) if(b&1)ans=ans*a%mod;
    return ans;
}
inline void exgcd(ll a,ll b,ll &g,ll &x,ll &y) {
    if (!b) g=a,x=1,y=0;
    else exgcd(b,a%b,g,y,x),y-=x*(a/b);
}
inline ll inv(ll a) {
   ll g,x,y;
    exgcd(a,mod,g,x,y);
    return (x%mod+mod)%mod;
}
void init(const int &n) {
    for (int i = 0,j=0; i < n; ++i) {
        pos[i]=j;for (int l = n >> 1; (j ^= l) < l; l >>= 1);
    }
}
void transform(ll *a, const int &n, bool inverse) {
    for (int i=0; i<n;++i) if(i>pos[i]) swap(a[i],a[pos[i]]);
    for (int l=2; l<=n;l<<=1) {
        int m=l/2;ll omega=fastpow(inverse?inv(root):root,(mod-1)/l);
        for (ll *p=a;p!=a+n;p+=l) {
            ll x=1;
            for (int i=0;i<m;++i,x=x*omega%mod) {
                ll t=x*p[m+i]%mod;
                p[m+i]=(p[i]-t+mod)%mod;(p[i]+=t)%=mod;
            }
        }
    }
}
void dft(ll *a, const int &n) {
    transform(a,n,0); 
}
void idft(ll *a, const int &n) {
    const ll INV=inv(n);
    transform(a,n,1);
    for (int i=0;i<n;i++) a[i]=a[i]*INV % mod;
}
const int maxn=4e6+6;
ll a[maxn],b[maxn],c[maxn],pic[maxn],pec[maxn],plc[maxn],ppc[maxn];
int INV[maxn];
void poly_inv(int n,ll *a,ll *b) {
	if(n==1) {b[0]=inv(a[0]);return;}
	poly_inv((n+1)/2,a,b);
	int cnt=1;while(cnt<=n*2) cnt<<=1;init(cnt);
	copy(a,a+n,pic);fill(pic+n,pic+cnt,0);fill(b+n,b+cnt,0);dft(pic,cnt);dft(b,cnt);
	for(int i=0;i<cnt;i++) (b[i]*=(2ll-pic[i]*b[i])%mod)%=mod;
	for(int i=0;i<cnt;i++) b[i]=(b[i]+mod)%mod;
	idft(b,cnt);fill(b+n,b+cnt,0);
}
void poly_ln(int n,ll *a,ll *b) { //G'=F'/F
    poly_inv(n,a,b);
    int cnt=1;while(cnt<=n*2-3) cnt<<=1;init(cnt);
    for(int i=0;i<n-1;i++) plc[i]=a[i+1]*(i+1)%mod;
    fill(plc+n-1,plc+cnt,0);fill(b+n,b+cnt,0);dft(plc,cnt);dft(b,cnt);
    for(int i=0;i<cnt;i++) b[i]=plc[i]*b[i]%mod;
	idft(b,cnt);for(int i=n-1;i>=1;i--) b[i]=b[i-1]*INV[i]%mod;b[0]=0;
	fill(b+n,b+cnt,0);
}
void poly_exp(int n,ll *a,ll *b) {
	if(n==1) {b[0]=1;return;}
	poly_exp((n+1)/2,a,b);poly_ln(n,b,pec);
	int cnt=1;while(cnt<=n*2-2) cnt<<=1;init(cnt);
	for(int i=0;i<n;i++) pec[i]=(-pec[i]+a[i])%mod;pec[0]+=1;
	dft(pec,cnt);dft(b,cnt);
	for(int i=0;i<cnt;i++) b[i]=(b[i]*pec[i])%mod;
	idft(b,cnt);fill(b+n,b+cnt,0);
}
void poly_pow(int n,ll *a,ll *b,ll k) {
	poly_ln(n,a,ppc);
	for(int i=0;i<n;i++) ppc[i]*=k;
	poly_exp(n,ppc,b);
}
char buff[maxn];
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
    int n;cin>>n>>buff;
	INV[1]=1;for(int i=2;i<n;++i) INV[i]=(mod-mod/i)*INV[mod%i]%mod;
    ll k=0;
    for(int i=0;buff[i];i++) k=(k*10+buff[i]-'0')%mod;
    for(int i=0;i<n;i++) cin>>a[i];
    poly_pow(n,a,b,k);
    for(int i=0;i<n;i++) cout<<b[i]<<' ';
}\end{lstlisting}
\subsubsection{MTT}
\begin{lstlisting}
const int maxn = 262144;
int mod = 1e9+7;

namespace MTT {
    struct comp {
        double x, y;
        comp(double x_ = 0, double y_ = 0): x(x_), y(y_) {}
    };
    inline comp operator + (const comp& a, const comp& b) { return comp(a.x + b.x, a.y + b.y); }
    inline comp operator - (const comp& a, const comp& b) { return comp(a.x - b.x, a.y - b.y); }
    inline comp operator * (const comp& a, const comp& b) { return comp(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); }
    inline comp conj(const comp& a) { return comp(a.x, -a.y); }

    const double PI = acosl(-1);
    comp w[maxn + 5];
    int bitrev[maxn + 5];
    int N, L;

    void fft(vector<comp>& a) {
        for (int i = 0; i < N; ++i) if (i < bitrev[i]) swap(a[i], a[bitrev[i]]);
        for (int i = 2, lyc = N >> 1; i <= N; i <<= 1, lyc >>= 1) {
            for (int j = 0; j < N; j += i) {
                int pl = j, pr = j + (i >> 1), p = 0;
                for (int k = 0; k < (i >> 1); ++k) {
                    comp tmp = a[pr] * w[p];
                    a[pr] = a[pl] - tmp, a[pl] = a[pl] + tmp;
                    ++ pl, ++ pr, p += lyc;
                }
            }
        }
    }

    inline void fft_prepare() {
        for (int i = 0; i < N; ++i) bitrev[i] = bitrev[i >> 1] >> 1 | ((i & 1) << (L - 1));
        for (int i = 0; i < N; ++i) w[i] = comp(cos(2 * PI * i / N), sin(2 * PI * i / N));
    }

    // if max ans is n+m, n=n+m+1
    void init(int n) {
        L = 0;
        while ((1 << L) < n) ++ L;
        N = 1 << L;
        fft_prepare();
    }

    inline vector<int> conv(vector<int> x, vector<int> y) {
        vector<comp> a(N + 5), b(N + 5);
        vector<comp> dfta(N + 5), dftb(N + 5), dftc(N + 5), dftd(N + 5);
        for (int i = 0; i < (int)x.size(); ++i) {
            if ((x[i] %= mod) < 0) x[i] += mod;
            a[i] = comp(x[i] & 32767, x[i] >> 15);
        }
        for (int i = 0; i < (int)y.size(); ++i) {
            if ((y[i] %= mod) < 0) y[i] += mod;
            b[i] = comp(y[i] & 32767, y[i] >> 15);
        }
        fft(a), fft(b);
        for (int i = 0; i < N; ++i) {
            int j = (N - i) & (N - 1);
            comp da = (a[i] + conj(a[j])) * comp(0.5, 0);
            comp db = (a[i] - conj(a[j])) * comp(0, -0.5);
            comp dc = (b[i] + conj(b[j])) * comp(0.5, 0);
            comp dd = (b[i] - conj(b[j])) * comp(0, -0.5);
            dfta[j] = da * dc;
            dftb[j] = da * dd;
            dftc[j] = db * dc;
            dftd[j] = db * dd;
        }
        for (int i = 0; i < N; ++i) a[i] = dfta[i] + dftb[i] * comp(0, 1);
        for (int i = 0; i < N; ++i) b[i] = dftc[i] + dftd[i] * comp(0, 1);
        fft(a), fft(b);
        vector<int> z(N);
        for (int i = 0; i < N; ++i) {
            int da = (ll)(a[i].x / N + 0.5) % mod;
            int db = (ll)(a[i].y / N + 0.5) % mod;
            int dc = (ll)(b[i].x / N + 0.5) % mod;
            int dd = (ll)(b[i].y / N + 0.5) % mod;
            z[i] = (da + ((ll)(db + dc) << 15) + ((ll)dd << 30)) % mod;
            if (z[i] < 0) z[i] += mod;
        }
        while (!z.empty() && z.back() == 0) z.pop_back();
        return z;
    }
}

int main(int argc, char* argv[]) {
    int n, m;
    R(n, m);
    VI a(n + 5), b(m + 5);
    MTT::init(n + m + 1);
    for (int i = 0; i <= n; ++i) R(a[i]);
    for (int i = 0; i <= m; ++i) R(b[i]);
    auto res = MTT::conv(a, b);
    while (res.size() < (n + m + 1)) res.push_back(0);
    W(res);
    return 0;
}\end{lstlisting}
\subsubsection{FWT}
\begin{lstlisting}
//FWT 完后需要先模一遍
template<typename T>
void fwt(ll a[], int n, T f) {
    for (int d = 1; d < n; d *= 2)
        for (int i = 0, t = d * 2; i < n; i += t)
            for(int j = 0; j < d; j ++)
                f(a[i + j], a[i + j + d]);
}

void AND(ll& a, ll& b) { a += b; }
void OR(ll& a, ll& b) { b += a; }
void XOR (ll& a, ll& b) {
    ll x = a, y = b;
    a = (x + y) % mod;
    b = (x - y + mod) % mod;
}
void rAND(ll& a, ll& b) { a -= b; }
void rOR(ll& a, ll& b) { b -= a; }
void rXOR(ll& a, ll& b) {
    static ll INV2 = (mod + 1) / 2;
    ll x = a, y = b;
    a = (x + y) * INV2 % mod;
    b = (x - y + mod) * INV2 % mod;
}

//FWT 子集卷积 i与j=0，i或j为k
a[popcount(x)][x] = A[x]
b[popcount(x)][x] = B[x]
fwt(a[i]) fwt(b[i])
c[i + j][x] += a[i][x] * b[j][x]
rfwt(c[i])
ans[x] = c[popcount(x)][x]\end{lstlisting}
\subsubsection{杜教筛}
\begin{lstlisting}
const int maxn=3e6+5;

unordered_map<int,ll> Mmu;
unordered_map<int,ll> Mphi;
ll mu[maxn],phi[maxn],prim[maxn],pcnt,mn[maxn];
void get_T() {
    phi[1]=mu[1]=1;
    for(int i=2;i<maxn;i++) {
        if(!mn[i]) {
            mn[i]=i;prim[++pcnt]=i;
            phi[i]=i-1;mu[i]=-1;
        }
        for(int j=1;j<=pcnt&&i*prim[j]<maxn;j++) {
            mn[i*prim[j]]=prim[j];
            if(i%prim[j]==0) {
                phi[i*prim[j]]=phi[i]*prim[j];
                break;
            }
            mu[i*prim[j]]=-mu[i];
            phi[i*prim[j]]=phi[i]*(prim[j]-1);
        }
    }
    for(int i=1;i<maxn;i++)
        mu[i]+=mu[i-1],phi[i]+=phi[i-1];
}
ll Smu(int n) {
    if(n==1) return 1;
    if(n<maxn) return mu[n];
    if(Mmu.find(n)!=Mmu.end()) return Mmu[n];
    ll ans=0;
    for(int l=2,r;l<=n;l=r+1) {
        r=min(n,n/(n/l));
        ans+=Smu(n/l)*(r-l+1);
    }
    return Mmu[n]=1-ans;
}
ll Sphi(int n) {
    if(n==1) return 1;
    if(n<maxn) return phi[n];
    if(Mphi.find(n)!=Mphi.end()) return Mphi[n];
    ll ans=0;
    for(int l=2,r;l<=n;l=r+1) {
        r=min(n,n/(n/l));
        ans+=Sphi(n/l)*(r-l+1);
    }
    return Mphi[n]=1ll*n*(n+1)/2-ans;
}
int main() {
    get_T();
    int T;cin>>T;while(T--) {
        int n;cin>>n;
        cout<<Sphi(n)<<' '<<Smu(n)<<endl;
    }
    return 0;
}\end{lstlisting}
\subsubsection{min25}
\begin{lstlisting}
const int maxn=1e6+5;
int primer[maxn],pcnt;
bool insp[maxn];
ll fsum1[maxn],fsum2[maxn];
const int mod=1e9+7,INV6=166666668;
void sieve() {
	for(int i=2;i<maxn;i++) {
		if(!insp[i]) {
			primer[++pcnt]=i;
			fsum1[pcnt]=(fsum1[pcnt-1]+i)%mod;
			fsum2[pcnt]=(fsum2[pcnt-1]+1ll*i*i)%mod;
		}
		for(int j=1;j<=pcnt&&primer[j]*i<maxn;j++) {
			insp[i*primer[j]]=1;
			if(i%primer[j]==0) break;
		}
	}
}

// Let g(j,m) be the sum of f'(i) for all i which is not greater
// than m and is prime or the min pri-factor of i > p[j] 
// We got that g(j,m)=g(j−1,m)−f'(p[j])*( g(j−1,m/p[j])−\sum_{i=1}^{j−1}f'(p[i]) )
// g(0,m) = \sum_{i=2}^m f'(j)
// Here f'(j) is a function whose value equals f(j) when j is prime 
// and f'(j) is an acompletely multiplicative function
// We can use DP to calc g(j,{n/1,n/2,...,n/n}) (sqrt(n) situation in total)
// So g(j,m) equals to the sum of f(i) for all primer i which not greater than m
//  when p[j]*p[j] > m
int id1[maxn],id2[maxn],tot=0;
ll val[maxn],n,g1[maxn],g2[maxn];
//index of n/1,n/2....n/n
inline int getid(ll m) {
	if(m<=n/m) return id1[m];
	return id2[n/m];
}
void init() {
	for(ll l=1,r;l<=n;l=r+1) {
		r=n/(n/l);ll w=n/l;
		val[++tot]=w;
		if(w<=n/w) id1[w]=tot;
		else id2[n/w]=tot;
		w%=mod;
		g1[tot]=w*(w+1)/2%mod;
		g2[tot]=w*(w+1)%mod*(2ll*w+1)%mod*INV6%mod;
		g1[tot]=(g1[tot]-1+mod)%mod;
		g2[tot]=(g2[tot]-1+mod)%mod;
	}
	// Start DP
	for(int i=1;1ll*primer[i]*primer[i]<=n;i++) {
		for(int j=1;j<=tot&&1ll*primer[i]*primer[i]<=val[j];j++) {
			int k=getid(val[j]/primer[i]);
			g1[j]=(g1[j]-1ll*primer[i]*(g1[k]-fsum1[i-1]+mod)%mod+mod)%mod;
			g2[j]=(g2[j]-1ll*primer[i]*primer[i]%mod*(g2[k]-fsum2[i-1]+mod)%mod+mod)%mod;
		}
	}	
}
ll getS(ll m,int k) {
	if(m<primer[k]) return 0;
	ll res=(g2[getid(m)]-g1[getid(m)]-fsum2[k-1]+fsum1[k-1])%mod;
	for(int i=k;1ll*primer[i]*primer[i]<=m;i++) {
		for(ll pie=primer[i],pie1=pie*primer[i];pie1<=m;pie=pie1,pie1*=primer[i]){
			ll t1=pie%mod,t2=pie1%mod;
			res=(res+t1*(t1-1)%mod*getS(m/pie,i+1)%mod+t2*(t2-1)%mod)%mod;
		}
	}
	return (res+mod)%mod;
}
int main() {
    sieve();cin>>n;	
    init();
    // for(int i=1;i<=10;i++) cout<<g1[i]<<endl;
    // cout<<g1[1]<<endl;
    cout<<(getS(n,1)+1)%mod<<endl;
    return 0;
}\end{lstlisting}
\subsection{Others}
\subsubsection{公式}
\begin{enumerate}
\item 约数定理：若$n=\prod_{i=1}^kp_i^{a_i}$，则

\begin{enumerate}
\item 约数个数$f(n)=\prod_{i=1}^k(a_i+1)$
\item 约数和$g(n)=\prod_{i=1}^k(\sum_{j=0}^{a_i}p_i^j)$
\end{enumerate}

\item 小于$n$且互素的数之和为$n\varphi(n)/2$

\item 若$\gcd(n,i)=1$，则$\gcd(n,n-i)=1(1\leq i\leq n)$

\item 错排公式：$D(n)=(n-1)(D(n-2)+D(n-1))=\sum_{i=2}^n\frac{(-1)^kn!}{k!}=[\frac{n!}{e}+0.5]$

\item 部分错排公式：n + m 个数中 m 个数必须错排求排列数
\begin{enumerate}
\item 1 dp[i] = n*dp[i−1]+(i−1)*(dp[i−1]+dp[i−2]);
\item 2 dp[0] = n!;
\item 3 dp[1] = n*n!;
\item dp[m] 为所求解
\end{enumerate}


\item 海伦公式：$S =\sqrt{p(p−a)(p−b)(p−c)}$，其中$p=\frac{(a+b+c)}{2}$
\item 求$C(n,k)$中素因子$P$的个数：
把$n$转化为$P$进制，并记它每个位上的和为$S1$
把$n-k$，$k$做同样的处理，得到$S2$，$S3$
则答案为：$\frac{S2+S3-S1}{P-1}$

\item 威尔逊定理：$p\ is\ prime\ \Rightarrow (p-1)!\equiv-1\pmod p$

\item 欧拉定理：$\gcd(a,n)=1\Rightarrow a^{\varphi(n)}\equiv1\pmod n$

\item 欧拉定理推广：$\gcd(n,p)=1\Rightarrow a^n\equiv a^{n\%\varphi(p)}\pmod p$

\item 模的幂公式：$a ^ n \pmod {m} = 
\begin{cases}
a ^ n \mod m & n < \varphi(m)\\
a ^ {n \% \varphi(m) + \varphi(m)} \mod m & n \ge \varphi(m)
\end{cases}
$

\item 素数定理：对于不大于$n$的素数个数$\pi(n)$，$\lim\limits_{n\to\infty}\pi(n)=\frac{n}{\ln n}$

\item 位数公式：正整数$x$的位数$N=\log_{10}(n)+1$

\item 斯特灵公式$n!\approx\sqrt{2\pi n}(\frac{n}{e})^n$

\item 设$a>1,m,n>0$,则$\gcd(a^m-1,a^n-1)=a^{\gcd(m,n)}-1$

\item 设$a>b,\gcd(a,b)=1$,则$\gcd(a^m-b^m,a^n-b^n)=a^{\gcd(m,n)}-b^{\gcd(m,n)}$

$$
G=\gcd(C_n^1,C_n^2,...,C_n^{n-1})=
\begin{cases}
	n, & \text{$n$ is prime} \\
	1, & \text{$n$ has multy prime factors} \\
	p, & \text{$n$ has single prime factor $p$}
\end{cases}
$$

$\gcd(Fib(m),Fib(n))=Fib(\gcd(m,n))$

\item 求和公式：

\begin{enumerate}
\item $\sum k=\frac{n(n+1)}{2}$
\item $\sum 2k-1=n^2$
\item $\sum k^2=\frac{n(n+1)(2n+1)}{6}$
\item $\sum (2k-1)^2=\frac{n(4n^2-1)}{3}$
\item $\sum k^3=(\frac{n(n+1)}{2})^2$
\item $\sum (2k-1)^3=n^2(2n^2-1)$
\item $\sum k^4=\frac{n(n+1)(2n+1)(3n^2+3n-1)}{30}$
\item $\sum k^5=\frac{n^2(n+1)^2(2n^2+2n-1)}{12}$
\item $\sum k(k+1)=\frac{n(n+1)(n+2)}{3}$
\item $\sum k(k+1)(k+2)=\frac{n(n+1)(n+2)(n+3)}{4}$
\item $\sum k(k+1)(k+2)(k+3)=\frac{n(n+1)(n+2)(n+3)(n+4)}{5}$
\end{enumerate}

\item 若$\gcd(m,n)=1$,则:

\begin{enumerate}
\item 最大不能组合的数为$m*n-m-n$
\item 不能组合数个数$N=\frac{(m-1)(n-1)}{2}$
\end{enumerate}

\item $(n+1)lcm(C_n^0,C_n^1,...,C_n^{n-1},C_n^{n})=lcm(1,2,...,n+1)$

\item 若$p$为素数，则$(x+y+...+w)^p\equiv x^p+y^p+...+w^p\pmod p$

\item 卡特兰数：1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012

$h(0)=h(1)=1,h(n)=\frac{(4n-2)h(n-1)}{n+1}=\frac{C_{2n}^n}{n+1}=C_{2n}^n-C_{2n}^{n-1}$

\item 伯努利数：$B_n = -\frac{1}{n+1} \sum_{i=0}^{n-1} C_{n+1}^i B_i$

$$\sum_{i=1}^n i^k = \frac{1}{k+1} \sum_{i=1}^{k+1}C_{k+1}^i B_{k+1-i}(n+1)^i$$

\item 二项式反演：$$f_n = \sum_{i = 0} ^ n (-1) ^ i \binom{n}{i} g_i \Leftrightarrow g_n = \sum_{i = 0} ^ n (-1) ^ i \binom{n}{i} f_i$$
$$f_n = \sum_{i = 0} ^ n \binom{n}{i} g_i \Leftrightarrow g_n = \sum_{i = 0} ^ n (-1) ^ {n - i} \binom{n}{i} f_i$$

\item 莫比乌斯反演:
\begin{enumerate}
\item 令$f(d)=\sum_{i=1}^{n}\sum_{j=1}^{m}[gcd(i,j)=d]$
\item $F(n)=\sum_{n|d}f(d)=\lfloor\frac{N}{n}\rfloor\lfloor\frac{M}{n}\rfloor$
\item 有$f(n)=\sum_{n|d}\mu(\lfloor\frac{d}{n}\rfloor)F(d)$
\item $\phi(n)=\sum_{d|n}d*\mu(n/d)$
\end{enumerate}


\item 2的n次方，在pow时可以精确输出最大$2^1023$，pow(2,1023)

\item FFT常用素数

\begin{tabular}{cccc}
    \hline
    $r⋅2^k+1$&$r$&$k$&$g$\\
    \hline
    3&1&1&2\\
    5&1&2&2\\
    17&1&4&3\\
    97&3&5&5\\
    193&3&6&5\\
    257&1&8&3\\
    7681&15&9&17\\
    12289&3&12&11\\
    40961&5&13&3\\
    65537&1&16&3\\
    786433&3&18&10\\
    5767169&11&19&3\\
    7340033&7&20&3\\
    23068673&11&21&3\\
    104857601&25&22&3\\
    167772161&5&25&3\\
    469762049&7&26&3\\
    998244353&119&23&3\\
    1004535809&479&21&3\\
    2013265921&15&27&31\\
    2281701377&17&27&3\\
    3221225473&3&30&5\\
    75161927681&35&31&3\\
    77309411329&9&33&7\\
    206158430209&3&36&22\\
    2061584302081&15&37&7\\
    2748779069441&5&39&3\\
    6597069766657&3&41&5\\
    39582418599937&9&42&5\\
    79164837199873&9&43&5\\
    263882790666241&15&44&7\\
    1231453023109121&35&45&3\\
    1337006139375617&19&46&3\\
    3799912185593857&27&47&5\\
    4222124650659841&15&48&19\\
    7881299347898369&7&50&6\\
    31525197391593473&7&52&3\\
    180143985094819841&5&55&6\\
    1945555039024054273&27&56&5\\
    4179340454199820289&29&57&3\\
    \hline
\end{tabular}

\end{enumerate}
\subsection{高数}
\subsubsection{拉格朗日插值}
\begin{lstlisting}
const int maxn = 1e5 + 10;
int x[maxn], y[maxn];
int qp(int a, int n) {
	ll ans = 1, base = a;
	for(; n; (base *= base) %= mod, n >>= 1) if(n & 1) (ans *= base) %= mod;
	return ans;
}

int lagrange(int n, int *x, int *y, int xi) {
	int ans = 0;
	for(int i = 0; i <= n; i ++) {
		int s1 = 1, s2 = 1;
		for(int j = 0; j <= n; j ++) if(i != j) {
			s1 = 1ll * s1 * (xi - x[j]) % mod;
			s2 = 1ll * s2 * (x[i] - x[j]) % mod;
		}
		ans = (1ll * ans + 1ll * y[i] * s1 % mod * qp(s2, mod - 2) % mod) % mod;
	}
	return (ans + mod) % mod;
}\end{lstlisting}
\subsubsection{拉格朗日插值(连续取值)}
\begin{lstlisting}
int x[maxn], y[maxn];
int s1[maxn], s2[maxn], ifac[maxn];

//如果x的取值是连续一段，可以做到O(n)求解
int lagrange(int n, int *x, int *y, int xi) {
	int ans = 0;
	s1[0] = (xi - x[0]) % mod, s2[n + 1] = 1;
	for(int i = 1; i <= n; i ++) s1[i] = 1ll * s1[i - 1] * (xi - x[i]) % mod;
	for(int i = n; i >= 0; i --) s2[i] = 1ll * s2[i + 1] * (xi - x[i]) % mod;
	ifac[0] = ifac[1] = 1;
	for(int i = 2; i <= n; i ++) ifac[i] = -1ll * mod / i * ifac[mod % i] % mod;
	for(int i = 2; i <= n; i ++) ifac[i] = 1ll * ifac[i] * ifac[i - 1] % mod;
	for(int i = 0; i <= n; i ++)
		(ans += 1ll * y[i] * (i == 0 ? 1 : s1[i - 1]) % mod * s2[i + 1] % mod * ifac[i] % mod * (((n - i) & 1) ? -1 : 1) * ifac[n - i] % mod) %= mod;
	return (ans + mod) % mod;
}\end{lstlisting}
\subsubsection{辛普森积分}
\begin{lstlisting}
typedef double ld;
ld a, b, c, d;
inline ld f(ld x) { return (c * x + d) / (a * x + b); }
inline ld simpson(ld l, ld r, ld fl, ld fr, ld fm) { return (r - l) * (fl + fr + 4 * fm) / 6; }

inline ld asr(ld l, ld r, ld eps, ld fl, ld fr, ld fm) {
    ld flm = f((l + (l + r) / 2) / 2), frm = f((r + (l + r) / 2) / 2);
    ld L = simpson(l, (l + r) / 2, fl, fm, flm), R = simpson((l + r) / 2, r, fm, fr, frm), A = simpson(l, r, fl, fr, fm);
    if (fabs(L + R - A) <= 15 * eps) return L + R + (L + R - A) / 15;
    return asr(l, (l + r) / 2, eps / 2, fl, fm, flm) + asr((l + r) / 2, r, eps / 2, fm, fr, frm);
}

inline ld cal(ld l, ld r) { return asr(l, r, 1e-10, f(l), f(r), f((l + r) / 2)); }\end{lstlisting}
\clearpage\section{Graph Theory}
\subsection{路径}
\subsubsection{Dijkstra}
\begin{lstlisting}
const int maxn = 1e5 + 10;
const int inf = 0x3f3f3f3f;

int head[maxn], dis[maxn], cnt, n;

struct Edge { int nex,to,w; }edge[20*maxn];

void add(int u,int v,int w)
{
    edge[++cnt].nex=head[u];
    edge[cnt].w=w;
    edge[cnt].to=v;
    head[u]=cnt;
}

void dijkstra(int s)
{
    priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > que;
    memset(dis, 0x3f, sizeof dis);
    que.push({0, s}); dis[s] = 0;
    while(!que.empty())
    {
        auto f = que.top(); que.pop();
        int u = f.second, d = f.first;
        if(d != dis[u]) continue;
        for(int i = head[u]; ~i; i = edge[i].nex)
        {
            int v = edge[i].to, w = edge[i].w;
            if(dis[u] + w < dis[v])
            {
                dis[v] = dis[u] + w;
                que.push({dis[v], v});
            }
        }
    }
}\end{lstlisting}
\subsubsection{Euler Path}
\begin{lstlisting}
int S[N << 1], top;
Edge edges[N << 1];
set<int> G[N];

void DFS(int u) {
    S[top++] = u;
    for (int eid: G[u]) 
    {
        int v = edges[eid].get_other(u);
        G[u].erase(eid);
        G[v].erase(eid);
        DFS(v);
        return;
    }
}

void fleury(int start) 
{
    int u = start;
    top = 0; path.clear();
    S[top++] = u;
    while (top) 
    {
        u = S[--top];
        if (!G[u].empty())
            DFS(u);
        else path.push_back(u);
    }
}\end{lstlisting}
\subsubsection{K shortest Path(Astar)}
\begin{lstlisting}
// 有向图 k 短路
const int N = 1010, M = 10010, inf = 1e9+50;
int n, m;
int g[N], h[N], v[M<<1], w[M<<1], nxt[M<<1], ed, d[N], vis[N], ans[N];
typedef pair<int, int> P;
priority_queue<P, vector<P>, greater<P> > Q;
void add(int x, int y, int z) {
    v[++ed] = x, w[ed] = z, nxt[ed] = g[y], g[y] = ed;
    v[++ed] = y, w[ed] = z, nxt[ed] = h[x], h[x] = ed;
}

int KthShortest(int S, int T, int k) {
    int x;
    for (int i = 1; i <= k; ++i) ans[i] = -1;
    for (int i = 1; i <= n; ++i) d[i] = inf;
    Q.push(P(d[T] = 0, T));
    while (!Q.empty()) {
        P t = Q.top(); Q.pop();
        if (d[t.second] < t.first) continue;
        for (int i = g[x = t.second]; i; i = nxt[i]) {
            if (d[x] + w[i] < d[v[i]]) Q.push(P(d[v[i]] = d[x] + w[i], v[i]));
        }
    }
    if (d[S] < inf) Q.push(P(d[S], S));
    while (!Q.empty()) {
        P t = Q.top(); Q.pop(); vis[x = t.second] ++;
        if (x == T && vis[T] <= k) ans[vis[T]] = t.first;
        if (vis[T] > k) break;
        if (vis[x] <= k) for (int i = h[x]; i; i = nxt[i]) {
            Q.push(P(t.first - d[x] + d[v[i]] + w[i], v[i]));
        }
    }
    return ans[k];
}\end{lstlisting}
\subsubsection{K shortest Path(可持久化可并堆)}
\begin{lstlisting}
#include <bits/stdc++.h>
#include<ext/pb_ds/priority_queue.hpp>

using namespace std;

const int N = '';
const int M = '';
const int logM = 20;
const int inf = 0x3f3f3f3f;

int n, m, k, S, T;

struct Edge{ int nex, to, w; };

struct Graph
{
    int head[N], cnt;
    Edge edge[M];
    void init(int n) { for(int i = 0; i <= n; i ++) head[i] = 0; cnt = 0; }
    void addedge(int u, int v, int val) { edge[++ cnt].nex = head[u], edge[cnt].to = v, edge[cnt].w = val, head[u] = cnt; }
}g, rg;

int dis[N];

void dijkstra()
{
    priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > que;
    memset(dis, inf, sizeof dis);
    que.push({0, T}); dis[T] = 0;
    const int *head = rg.head; const Edge *edge = rg.edge;
    while(!que.empty())
    {
        auto f = que.top(); que.pop();
        int u = f.second, d = f.first;
        if(d != dis[u]) continue;
        for(int i = head[u]; i; i = edge[i].nex)
        {
            int v = edge[i].to, w = edge[i].w;
            if(dis[u] + w < dis[v]) { dis[v] = dis[u] + w; que.push({dis[v], v}); }
        }
    }
}

bool tree_edge[M], vis[N];
int fa[N], st[N], top;

void dfs(int u)
{
    vis[u] = true;
    st[++ top] = u;
    for(int i = rg.head[u]; i; i = rg.edge[i].nex)
    {
        int v = rg.edge[i].to;
        if(!vis[v] && dis[v] == dis[u] + rg.edge[i].w)
        {
            fa[v] = u;
            tree_edge[i] = true;
            dfs(v);
        }
    }
}

namespace LT
{
    int son[M * logM][2];
    int ht[M * logM], val[M * logM], id[M * logM];
    int tot;

    int newnode(int _val, int _id, int _dis = 0)
    {
        int now = ++ tot;
        val[now] = _val, id[now] = _id;
        ht[now] = _dis, son[now][0] = son[now][1] = 0;
        return now;
    }

    int _copy(int ori)
    {
        int now = ++tot;
        val[now] = val[ori], id[now] = id[ori];
        ht[now] = ht[ori], son[now][0] = son[ori][0], son[now][1] = son[ori][1];
        return now;
    }

    int merge(int a, int b)
    {
        if(!a || !b) return a | b;
        if(val[a] > val[b]) swap(a, b);
        int now = _copy(a);
        son[now][1] = merge(son[now][1], b);
        if(ht[son[now][0]] < ht[son[now][1]]) swap(son[now][0], son[now][1]);
        ht[now] = ht[son[now][1]] + 1;
        return now;
    }

    void insert(int &rt, int val, int id) { rt = merge(newnode(val, id), rt); }
}

int rt[M];

void build_heap()
{
    for(int i = 1; i <= top; i ++)
    {
        int u = st[i];
        rt[u] = rt[fa[u]];
        for(int i = g.head[u]; i; i = g.edge[i].nex)
        {
            int v = g.edge[i].to;
            if(!tree_edge[i] && dis[v] != inf) LT::insert(rt[u], dis[v] - dis[u] + g.edge[i].w, v);
        }
    }
}

int solve(int k)
{
    if(k == 1) return dis[S];
    __gnu_pbds::priority_queue<pair<int, int>, greater<pair<int, int> > > que;
    que.push({dis[S] + LT::val[rt[S]], rt[S]});
    while(!que.empty())
    {
        pair<int, int> f = que.top(); que.pop();
        if((--k) == 1) return f.first;
        int v = f.first, u = f.second;
        int lc = LT::son[u][0], rc = LT::son[u][1], o = LT::id[u];
        if(rt[o]) que.push({v + LT::val[rt[o]], rt[o]});
        if(lc) que.push({v + LT::val[lc] - LT::val[u], lc});
        if(rc) que.push({v + LT::val[rc] - LT::val[u], rc});
    }
    return -1;
}

void init()
{
    g.init(n), rg.init(n);
    memset(rt, 0, sizeof rt);
    memset(tree_edge, 0, sizeof tree_edge);
    top = LT::tot = 0;
}

void getans()
{
    //input S-T
    init();
    dijkstra();
    dfs(T);
    build_heap();
    cout << solve(k);
}
\end{lstlisting}
\subsection{生成树}
\subsubsection{Matrix Tree}
\begin{lstlisting}
const int N = 305;
const int mod = 1e9 + 7;

int n, m, a[N][N];

int Gauss(int n) {
    int ans = 1;
    for (int i = 1; i <= n; i++) {
        for (int k = i + 1; k <= n; k++) {
            while (a[k][i]) {
                int d = a[i][i] / a[k][i];
                for (int j = i; j <= n; j++) {
                    a[i][j] = (a[i][j] - 1LL * d * a[k][j] % mod + mod) % mod;
                }
                std::swap(a[i], a[k]);
                ans = -ans;
            }
        }
        ans = 1LL * ans * a[i][i] % mod;
    }
    return (ans % mod + mod) % mod;
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; i++) {
        int u, v;
        scanf("%d%d", &u, &v);
        a[u][v]--, a[v][u]--;
        a[u][u]++, a[v][v]++;
    }
    printf("%d\n", Gauss(n - 1));
    return 0;
}\end{lstlisting}
\subsubsection{Steiner Tree}
\begin{lstlisting}
/*BZOJ:4774
无向图G从1-n进行编号，选择一些边，使对于1<=i<=d,i号点和n-i+1号点连通，最小化选出的所有边权值和。
1. 枚举子树形态 $dp[S][i] = min(dp[s]+dp[S \ xor \  s])$
2. 按照边进行松弛 $dp[S][i] = min(dp[S][j]+w[j][i])$
其中$S$为选取的子集，$s$ 和$S\ xor\ s$为$S$的状态划分。第二类转移方程可以通过跑一次最短路进行松弛。
本题需要再做一次子集dp，因为不成对的点可能不连通。
*/
#include <bits/stdc++.h>

using namespace std;

const int maxn = 1e4 + 10;
const int inf = 0x3f3f3f3f;

int head[maxn], cnt;
struct Edge {int nex, to, w; }edge[maxn<<1];

void add(int u, int v, int w)
{
    edge[cnt].nex = head[u];
    edge[cnt].to = v;
    edge[cnt].w = w;
    head[u] = cnt++;
}

int f[1<<10][maxn], ans[20];
bool in[maxn];

queue<int> que;

void spfa(int S)
{
    while(!que.empty())
    {
        int u = que.front(); que.pop();
        in[u] = false;
        for(int i = head[u]; ~i; i = edge[i].nex)
        {
            int v = edge[i].to;
            if(f[S][v] > f[S][u] + edge[i].w)
            {
                f[S][v] = f[S][u] + edge[i].w;
                if(!in[v]) que.push(v), in[v] = true;
            }
        }
    }
}

int Steiner_Tree(int n, int d)
{
    memset(f, 0x3f, sizeof f);
    for(int i = 1; i <= d; i++)
        f[1 << (i - 1)][i] = f[1 << (d + i - 1)][n - i + 1] = 0;
    int lim = 1<<(d<<1);
    for(int S = 1; S < lim; S++)
    {
        for(int i = 1; i <= n; i++)
        {
            for(int s = (S - 1) & S; s; s = (s - 1) & S)
                f[S][i] = min(f[S][i], f[s][i] + f[S ^ s][i]);
            if(f[S][i] != inf) que.push(i), in[i] = true;
        }
        spfa(S);
    }
    lim = 1<<d;
    memset(ans, 0x3f, sizeof ans);
    for(int S = 1; S < lim; S++)
        for(int i = 1; i <= n; i++)
            ans[S] = min(ans[S], f[S^(S<<d)][i]);
    for(int S = 1; S < lim; S++)
        for(int s = (S - 1) & S; s; s = (s - 1) & S)
            ans[S] = min(ans[S], ans[s] + ans[S ^ s]);
    return ans[lim - 1] == inf ? -1 : ans[lim - 1];
}

int main()
{
    int n, m, d, u, v, w;
    scanf("%d%d%d", &n, &m, &d);
    memset(head, 0xff, sizeof head);
    while(m--)
    {
        scanf("%d%d%d", &u, &v, &w);
        add(u, v, w);
        add(v, u, w);
    }
    printf("%d\n", Steiner_Tree(n, d));
    return 0;
}\end{lstlisting}
\subsubsection{最小树形图}
\begin{lstlisting}
const int INF = 0x3f3f3f3f;
const int maxn = 10000;
const int maxm = 10000;

struct Edge{int u,v,cost; } edge[maxm];

int pre[maxn], id[maxn], vis[maxn], in[maxn];

int zhuliu(int root, int n, int m)
{
	int res=0, u, v;
	for(;;)
	{
		for(int i=0; i<n; i++) in[i] = INF;
		for(int i=0; i<m; i++) if(edge[i].u != edge[i].v && edge[i].cost < in[edge[i].v])
		{
			pre[edge[i].v] = edge[i].u;
			in[edge[i].v] = edge[i].cost;
		}
		for(int i=0; i<n; i++) if(i != root && in[i] ==INF) return -1;
		int tn=0;
		memset(id, 0xff, sizeof id);
		memset(vis, 0xff, sizeof vis);
		in[root] = 0;
		for(int i=0; i<n;i++)
		{
			res += in[i];
			v = i;
			while( vis[v] != i && id[v] == -1 && v!= root) vis[v] = i, v = pre[v];
			if(v != root && id[v] == -1) 
			{ 
				for(int u = pre[v]; u != v; u = pre[u]) id[u] = tn;
				id[v] = tn++;
			}
		}
		if(tn == 0) break;
		for(int i=0; i<n; i++) if(id[i] == -1) id[i] = tn++;
		for(int i=0; i<m; )
		{
			v = edge[i].v;
			edge[i].u = id[edge[i].u];
			edge[i].v = id[edge[i].v];
			if(edge[i].u != edge[i].v) edge[i++].cost -= in[v];
			else swap(edge[i], edge[--m]);
		}
		n = tn;
		root = id[root];
	}
	return res;
}
\end{lstlisting}
\subsection{连通性}
\subsubsection{割点}
\begin{lstlisting}
const int maxn = 1e4 + 10;

vector<int> edge[maxn];
int n, dfn[maxn], low[maxn], cnt = 0;
bool vis[maxn], cut[maxn];

void Tarjan(int u, int fa)
{
    dfn[u] = low[u] = ++cnt;
    vis[u] = true;
    int children = 0;
    for (int i = 0; i < edge[u].size(); i++)
    {
        int v = edge[u][i];
        if (v != fa && vis[v])
            low[u] = min(low[u], dfn[v]);
        else if (!vis[v])
        {
            Tarjan(v, u);
            children++;
            low[u] = min(low[u], low[v]);
            if (fa == -1 && children > 1) //若u是根节点且子节点数大于1
                cut[u] = true;    //u是割点
            else if (fa != -1 && low[v] >= dfn[u])    //若u不是根节点且v不能访问到u的父节点
                cut[u] = true;    //u是割点
        }
    }
}\end{lstlisting}
\subsubsection{桥}
\begin{lstlisting}
const int maxn = 1e4 + 10;

vector<int> edge[maxn];
int n, dfn[maxn], low[maxn], father[maxn], cnt = 0;
bool bridge[maxn][maxn];

void Tarjan(int u, int fa)
{
    dfn[u] = low[u] = ++cnt;
    for (int i = 0; i < edge[u].size(); i++)
    {
        int v = edge[u][i];
        if (!dfn[v])    //未访问节点v
        {
            Tarjan(v, u);
            low[u] = min(low[u], low[v]);
            if (low[v] > dfn[u]) //节点v到达祖先必须经过(u,v)
                bridge[u][v] = bridge[v][u] = true;    //(u,v)是桥
        } 
        else if (fa != v)    //u的父节点不是v，（u,v)不存在重边
            low[u] = min(low[u], dfn[v]);
    }
}\end{lstlisting}
\subsubsection{强连通分量}
\begin{lstlisting}
const int maxn=1000+10;

vector<int> edge[maxn];

int dfn[maxn], low[maxn];
int stack[maxn], index, tot;
int belong[maxn], inde[maxn], outde[maxn], scc;
bool vis[maxn];

void add(int u, int v)
{
	edge[u].push_back(v);
	edge[v].push_back(u);
}

void Tarjan(int u)
{
    dfn[u] = low[u] = ++tot;
    stack[++index] = u;
    vis[u] = true;
    int v;
    for(int i = 0;i < edge[u].size(); i++)
    {
        v=edge[u][i];
        if(!dfn[v])
        {
            Tarjan(v);
            low[u] = min(low[v], low[u]);
        }
        else if(vis[v]) low[u] = min(low[v], dfn[u]);
    }
    if(dfn[u] == low[u])
    {
        scc++;
        do
        {
            v = stack[index--];
            vis[v] = false;
            belong[v] = scc;
        }while(v != u);
    }
}\end{lstlisting}
\subsubsection{点双联通分量}
\begin{lstlisting}
const int maxn = 10000 + 10;

struct Edge{ int u, v; };
vector<int> G[maxn], bcc[maxn];

int dfn[maxn], low[maxn], bccno[maxn], idx, bcc_cnt, bridge;
bool iscut[maxn];

stack<Edge> st;

void dfs(int u, int pre)
{
	dfn[u] = low[u] = ++idx;
	int child = 0;
	for(auto v : G[u])
	{
		if(v == pre) continue;
		if(!dfn[v])
		{
			child ++;
			st.push({u, v});
			dfs(v, u);
			low[u] = min(low[u], low[v]);
			if(low[v] >= dfn[u])
			{
				iscut[u] = true;
				bcc[++bcc_cnt].clear();
				Edge x;
				do
				{
					x = st.top(); st.pop();
					if(bccno[x.u] != bcc_cnt) { bcc[bcc_cnt].push_back(x.u); bccno[x.u] = bcc_cnt; }
					if(bccno[x.v] != bcc_cnt) { bcc[bcc_cnt].push_back(x.v); bccno[x.v] = bcc_cnt; }
				} while(x.u != u || x.v != v);
			}
			if(low[v] > dfn[u]) ++ bridge;
		}
		else if(dfn[v] < dfn[u])
		{
			st.push({u, v});
			low[u] = min(low[u], dfn[v]);
		}
	}
	if(pre < 0 && child == 1) iscut[u] = 0;
}

void find_bcc(int n)
{
	memset(dfn, 0, sizeof dfn);
	memset(iscut, 0, sizeof iscut);
	memset(bccno, 0, sizeof bccno);
	for(int i = 1; i <= bcc_cnt; i ++) bcc[i].clear();
	idx = bcc_cnt = bridge = 0;
	for(int i = 0; i < n; i ++) if(!dfn[i]) dfs(i, -1);
}
\end{lstlisting}
\subsubsection{边双联通分量}
\begin{lstlisting}
const int maxn = 10000 + 10;

int low[maxn], dfn[maxn], head[maxn], cnt, idx;
int cutEdge[maxn << 2];
struct  Edge { int nex, v; }edge[maxn << 2];

void add(int u, int v) { edge[cnt].nex = head[u], edge[cnt].v = v, head[u] = cnt ++; }

void dfs(int u, int pre)
{
	low[u] = dfn[u] = ++idx;
	for(int i = head[u]; ~i; i = edge[i].nex)
	{
		int v = edge[i].v;
		if(v == pre) continue;
		if(!dfn[v])
		{
			dfs(v, u);
			low[u] = min(low[u], low[v]);
			if(low[v] > dfn[u]) cutEdge[i] = cutEdge[i ^ 1] = 1;
		}
		else if(dfn[v] < dfn[u]) low[u] = min(low[u], dfn[v]);
	}
}

int n, m;
vector<int> edge[maxn];
int dfn[maxn], low[maxn], idx;
int st[maxn], stsz;
// 标号特性：子节点标号大于父节点
int inWhichGroup[maxn], groupNow, groupRt[maxn];
int fa[maxn];

void dfs(int u, int fa) {
    ::fa[u] = fa;
    dfn[u] = low[u] = ++idx, st[++stsz] = u;
    int firstToVisFa = 1;
    for (auto v : edge[u]) {
        if (v != fa || !firstToVisFa) {
            if (!dfn[v]) {
                dfs(v, u);
                low[u] = min(low[u], low[v]);
            } else low[u] = min(low[u], dfn[v]);
        } else firstToVisFa = 0;
    }
    if (dfn[u] == low[u]) {
        ++groupNow;
        groupRt[groupNow] = u;
        do {
            inWhichGroup[st[stsz]] = groupNow;
        } while (st[stsz --] != u);
    }
}\end{lstlisting}
\subsection{图匹配}
\begin{enumerate}
\item 二分图中的最大匹配数=最小点覆盖数
\item 最小路径覆盖=最小路径覆盖＝｜G｜－最大匹配数
\item 二分图最大独立集=顶点数-最小点覆盖
\item 二分图的最大团=补图的最大独立集
\end{enumerate}\subsubsection{Hungary Algorithm}
\begin{lstlisting}
const int maxn = 150;

int n;
int edge[maxn][maxn];
int linker[maxn];
bool vis[maxn];

bool path(int u)
{
    for (int v = 1; v <= n; v++)
    {
        if (edge[u][v] && !vis[v])
        {
            vis[v] = true;
            if (linker[v] == -1 || path(linker[v]))
            {
                linker[v] = u;
                return true;
            }
        }
    }
    return false;
}

int hungary()
{
    int res = 0;
    memset(linker, 0xff, sizeof(linker));
    for (int i = 1; i <= n; i++)
    {
        memset(vis, false, sizeof(vis));
        res += path(i);
    }
    return res;
}\end{lstlisting}
\subsubsection{Hopcroft-karp Algorithm}
\begin{lstlisting}
//复杂度O(n^0.5*m)
struct Hopcroft {
#define maxn 100005
#define maxm 100005
#define INF 0x3f3f3f3f
    struct Edge { int v, next; } edge[maxm];
    int nx, cnt, dis;
    int first[maxn];
    int xlink[maxn], ylink[maxn];
    int dx[maxn], dy[maxn];
    int vis[maxn];

    void init(int n) {
        cnt = 0;
        for (int i = 0; i <= n; ++i) first[i] = ylink[i] = xlink[i] = -1;
        nx = n + 1;
    }

    void add_edge(int u, int v) {
        edge[cnt].v = v, edge[cnt].next = first[u], first[u] = cnt++;
    }

    int bfs() {
        queue<int> q;
        dis = INF;
        for (int i = 0; i < nx; ++i) dx[i] = dy[i] = -1;
        for (int i = 0; i < nx; i++) {
            if (xlink[i] == -1) {
                q.push(i);
                dx[i] = 0;
            }
        }
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            if (dx[u] > dis) break;
            for (int e = first[u]; e != -1; e = edge[e].next) {
                int v = edge[e].v;
                if (dy[v] == -1) {
                    dy[v] = dx[u] + 1;
                    if (ylink[v] == -1) dis = dy[v];
                    else {
                        dx[ylink[v]] = dy[v] + 1;
                        q.push(ylink[v]);
                    }
                }
            }
        }
        return dis != INF;
    }

    int find(int u) {
        for (int e = first[u]; e != -1; e = edge[e].next) {
            int v = edge[e].v;
            if (!vis[v] && dy[v] == dx[u] + 1) {
                vis[v] = 1;
                if (ylink[v] != -1 && dy[v] == dis) continue;
                if (ylink[v] == -1 || find(ylink[v])) {
                    xlink[u] = v, ylink[v] = u;
                    return 1;
                }
            }
        }
        return 0;
    }

    int maxmatch() {
        int ans = 0;
        for (int i = 0; i < nx; ++i) vis[i] = 0;
        while (bfs()) {
            for (int i = 0; i < nx; ++i) vis[i] = 0;
            for (int i = 0; i < nx; i++)
                if (xlink[i] == -1)
                    ans += find(i);
        }
        return ans;
    }

#undef maxn
#undef maxm
} solve;\end{lstlisting}
\subsubsection{二分图多重匹配}
\begin{lstlisting}
const int maxn = 1e2 + 5;//左边最大点数
const int maxm = 1e2 + 5;//右边最大点数
int graph[maxn][maxm], vis[maxm];//图G和增广路访问标记
int match[maxm][maxn];//左边元素与右边元素第n次匹配
int nx, ny, m;//左边点数，右边点数,边数
int vol[maxm];//右边点多重匹配可容纳值
int cnt[maxm];//右边点已匹配值

bool find_path(int u)//找增广路
{
    for (int i = 0; i < ny; i++)//注意，这里节点是从0开始编号，题目有时是从1开始编号
    {
        if (graph[u][i] && !vis[i])//不在增广路
        {
            vis[i] = 1;//放进增广路
            if (cnt[i] < vol[i])//如果当前已匹配数量小于可容纳量，则直接匹配
            {
                match[i][cnt[i]++] = u;
                return true;
            }
            for (int j = 0; j < cnt[i]; j++)
            {
                if (find_path(match[i][j]))//如果先前已匹配右边的点能另外找到增广路，则此点仍可匹配
                {
                    match[i][j] = u;
                    return true;
                }
            }
        }
    }
    return false;
}

int max_match()//计算多重匹配的最大匹配数
{
    int res = 0;
    memset(match, -1, sizeof(match));
    memset(cnt, 0, sizeof(cnt));
    for (int i = 0; i < nx; i++)
    {
        memset(vis, 0, sizeof(vis));
        if (find_path(i)) res++;
    }
    return res;
}

bool all_match()//判断左边的点是否都与右边的点匹配了
{
    memset(cnt, 0, sizeof(cnt));
    for (int i = 0; i < nx; i++)
    {
        memset(vis, 0, sizeof(vis));
        if (!find_path(i)) return false;
    }
    return true;
}\end{lstlisting}
\subsubsection{二分图最大权匹配(KM算法)}
\begin{lstlisting}
int n;
int cost[maxn][maxn];
int lx[maxn], ly[maxn], match[maxn], slack[maxn];
int Prev[maxn];
bool vy[maxn];
const int INF = 0X3f3f3f3f;

void augment(int root) {
    fill(vy + 1, vy + n + 1, false);
    fill(slack + 1, slack + n + 1, INF);
    int py;
    match[py = 0] = root;
    do {
        vy[py] = true;
        int x = match[py], yy;
        int delta = INF;
        for (int y = 1; y <= n; y++) {
            if (!vy[y]) {
                if (lx[x] + ly[y] - cost[x][y] < slack[y])
                    slack[y] = lx[x] + ly[y] - cost[x][y], Prev[y] = py;
                if (slack[y] < delta) delta = slack[y], yy = y;
            }
        }
        for (int y = 0; y <= n; y++) {
            if (vy[y])
                lx[match[y]] -= delta, ly[y] += delta;
            else
                slack[y] -= delta;
        }
        py = yy;
    } while (match[py] != -1);
    do {
        int pre = Prev[py];
        match[py] = match[pre], py = pre;
    } while (py);
}

int KM() {
    for (int i = 1; i <= n; i++) {
        lx[i] = ly[i] = 0;
        match[i] = -1;
        for (int j = 1; j <= n; j++) lx[i] = max(lx[i], cost[i][j]);
    }
    int answer = 0;
    for (int root = 1; root <= n; root++) augment(root);
    for (int i = 1; i <= n; i++) answer += lx[i], answer += ly[i];
    return answer;
}\end{lstlisting}
\subsubsection{一般图匹配带花树}
\begin{lstlisting}
//一般图匹配，带花树算法
const int maxn = 1000 + 10;

struct Edmond
{
    vector<int> edge[maxn];
    queue<int> que;

    int n, pre[maxn], type[maxn], link[maxn], nex[maxn], vis[maxn];

    void init(int n)
    {
        this->n = n;
        for (int i = 0; i <= n; i++) edge[i].clear();
        memset(link, 0, sizeof(link));
    }

    void add(int u, int v)
    {
        edge[u].push_back(v);
        edge[v].push_back(u);
    }

    int Find(int x)
    {
        return x == pre[x] ? x : pre[x] = Find(pre[x]);
    }

    void combine(int x, int lca)    //如果找到奇环，对当前点x和找到的
    {
        while (x != lca)
        {
            int u = link[x], v = nex[u];
            if (Find(v) != lca) nex[v] = u;
            if (type[u] == 1) type[u] = 2, que.push(u);
            pre[Find(x)] = Find(u);
            pre[Find(u)] = Find(v);
            x = v;
        }
    }

    void contrack(int x, int y)
    {
        int lca = x;
        memset(vis, 0, sizeof(vis));
        for (int i = x; i; i = nex[link[i]])
        {
            i = Find(i);
            vis[i] = 1;
        }
        for (int i = y; i; i = nex[link[i]])
        {
            i = Find(i);
            if (vis[i])
            {
                lca = i;
                break;
            }
        }
        if (lca != Find(x)) nex[x] = y;
        if (lca != Find(y)) nex[y] = x;
        combine(x, lca);
        combine(y, lca);
    }

    void bfs(int s)
    {
        memset(type, 0, sizeof(type));
        memset(nex, 0, sizeof(nex));
        for (int i = 1; i <= n; i++) pre[i] = i;
        while (!que.empty()) que.pop();
        que.push(s);
        type[s] = 2;
        while (!que.empty())
        {
            int x = que.front();
            que.pop();
            for (int i = 0; i < edge[x].size(); i++)
            {
                int y = edge[x][i];
                if (Find(x) == Find(y) || link[x] == y || type[y] == 1) continue;
                if (type[y] == 2) contrack(x, y);
                else if (link[y])
                {
                    nex[y] = x;
                    type[y] = 1;
                    type[link[y]] = 2;
                    que.push(link[y]);
                } else
                {
                    nex[y] = x;
                    int pos = y, u = nex[pos], v = link[u];
                    while (pos)
                    {
                        link[pos] = u;
                        link[u] = pos;
                        pos = v;
                        u = nex[pos];
                        v = link[u];
                    }
                    return;
                }
            }
        }
    }

    int maxmatch()
    {
        for (int i = 1; i <= n; i++) if (!link[i]) bfs(i);
        int ans = 0;
        for (int i = 1; i <= n; i++) if (link[i]) ans++;
        return ans / 2;
    }
}ans;\end{lstlisting}
\subsection{网络流}
\subsubsection{Dinic}
\begin{lstlisting}
const int MAX_V = 1000 + 10;
const int INF = 0x3f3f3f3f;

//用于表示边的结构体（终点，流量，反向边）
struct edge{int to, cap, rev;};

vector<edge> G[MAX_V];	//图的邻接表表示
int level[MAX_V];	//顶点到源点的距离标号
int iter[MAX_V];	//当前弧

void add(int from, int to, int cap)
{
	G[from].push_back((edge){to, cap, (int)G[to].size()});
	G[to].push_back((edge){from, 0, (int)G[from].size() - 1});
}

//计算从源点出发的距离标号
void bfs(int s)
{
	memset(level, -1, sizeof(level));
	queue<int> que;
	level[s] = 0;
	que.push(s);
	while(!que.empty())
	{
		int v = que.front(); que.pop();
		for(int i = 0; i < G[v].size(); i++)
		{
			edge &e = G[v][i];
			if(e.cap > 0 && level[e.to] < 0)
			{
				level[e.to] = level[v] + 1;
				que.push(e.to);
			}
		}
	}
}

//通过DFS寻找增广路
int dfs(int v, int t, int f)
{
	if(v == t) return f;
	for(int &i = iter[v]; i<G[v].size(); i++)
	{
		edge &e = G[v][i];
		if(e.cap > 0 && level[v] < level[e.to])
		{
			int d = dfs(e.to, t, min(f, e.cap));
			if(d > 0)
			{
				e.cap -= d;
				G[e.to][e.rev].cap += d;
				return d;
			}
		}
	}
	return 0;
}

//求解从s到t的最大流
int max_flow(int s, int t)
{
	int flow = 0;
	for(;;)
	{
		bfs(s);
		if(level[t] < 0) return flow;
		memset(iter, 0, sizeof(iter));
		int f;
		while((f = dfs(s,t,INF)) > 0) flow += f;
	}
}\end{lstlisting}
\subsubsection{ISAP}
\begin{lstlisting}
struct Edge {
  int from, to, cap, flow;
  Edge(int u, int v, int c, int f) : from(u), to(v), cap(c), flow(f) {}
};

bool operator<(const Edge& a, const Edge& b) {
  return a.from < b.from || (a.from == b.from && a.to < b.to);
}

struct ISAP {
  int n, m, s, t;
  vector<Edge> edges;
  vector<int> G[maxn];
  bool vis[maxn];
  int d[maxn];
  int cur[maxn];
  int p[maxn];
  int num[maxn];

  void AddEdge(int from, int to, int cap) {
    edges.push_back(Edge(from, to, cap, 0));
    edges.push_back(Edge(to, from, 0, 0));
    m = edges.size();
    G[from].push_back(m - 2);
    G[to].push_back(m - 1);
  }

  bool BFS() {
    memset(vis, 0, sizeof(vis));
    queue<int> Q;
    Q.push(t);
    vis[t] = 1;
    d[t] = 0;
    while (!Q.empty()) {
      int x = Q.front();
      Q.pop();
      for (int i = 0; i < G[x].size(); i++) {
        Edge& e = edges[G[x][i] ^ 1];
        if (!vis[e.from] && e.cap > e.flow) {
          vis[e.from] = 1;
          d[e.from] = d[x] + 1;
          Q.push(e.from);
        }
      }
    }
    return vis[s];
  }

  void init(int n) {
    this->n = n;
    for (int i = 0; i < n; i++) G[i].clear();
    edges.clear();
  }

  int Augment() {
    int x = t, a = INF;
    while (x != s) {
      Edge& e = edges[p[x]];
      a = min(a, e.cap - e.flow);
      x = edges[p[x]].from;
    }
    x = t;
    while (x != s) {
      edges[p[x]].flow += a;
      edges[p[x] ^ 1].flow -= a;
      x = edges[p[x]].from;
    }
    return a;
  }

  int Maxflow(int s, int t) {
    this->s = s;
    this->t = t;
    int flow = 0;
    BFS();
    memset(num, 0, sizeof(num));
    for (int i = 0; i < n; i++) num[d[i]]++;
    int x = s;
    memset(cur, 0, sizeof(cur));
    while (d[s] < n) {
      if (x == t) {
        flow += Augment();
        x = s;
      }
      int ok = 0;
      for (int i = cur[x]; i < G[x].size(); i++) {
        Edge& e = edges[G[x][i]];
        if (e.cap > e.flow && d[x] == d[e.to] + 1) {
          ok = 1;
          p[e.to] = G[x][i];
          cur[x] = i;
          x = e.to;
          break;
        }
      }
      if (!ok) {
        int m = n - 1;
        for (int i = 0; i < G[x].size(); i++) {
          Edge& e = edges[G[x][i]];
          if (e.cap > e.flow) m = min(m, d[e.to]);
        }
        if (--num[d[x]] == 0) break;
        num[d[x] = m + 1]++;
        cur[x] = 0;
        if (x != s) x = edges[p[x]].from;
      }
    }
    return flow;
  }
};\end{lstlisting}
\subsubsection{MCMF}
\begin{lstlisting}
const int maxn = 10000 + 10;
const int inf = 0x3f3f3f3f;

struct Edge { int from, to, cap, flow, cost; };

struct MCMF
{
	int n, m;
	vector<Edge> edges;
	vector<int> G[maxn];
	bool inq[maxn];
	int dis[maxn], path[maxn], a[maxn];

	void init(int n)
	{
		this->n = n;
		for(int i = 0;i <= n;i ++)
			G[i].clear();
		edges.clear();
	}

	void addEdge(int from, int to, int cap, int cost)
	{
		edges.push_back(Edge{from, to, cap, 0, cost});
		edges.push_back(Edge{to, from, 0, 0, -cost});
		m = edges.size();
		G[from].push_back(m - 2);
		G[to].push_back(m - 1);
	}

	bool Bellman_Ford(int s, int t, int& flow, int& cost)
	{
		for(int i = 0; i<= n; i++) dis[i] = inf;
		memset(inq, 0, sizeof inq);
		dis[s]=0, inq[s]=true, path[s]=0, a[s]=inf;
		queue<int> Q;
		Q.push(s);
		while(!Q.empty())
		{
			int u = Q.front(); Q.pop();
			inq[u] = false;
			for(int i = 0; i < G[u].size(); i++)
			{
				Edge& e = edges[G[u][i]];
				if(e.cap > e.flow && dis[e.to] > dis[u] + e.cost)
				{
					dis[e.to] = dis[u] + e.cost;
					path[e.to] = G[u][i];
					a[e.to] = min(a[u], e.cap - e.flow);
					if(!inq[e.to])
					{
						Q.push(e.to);
						inq[e.to] = true;
					}
				}
			}
		}
		if(dis[t] == inf) return false;		//求最小费用最大流
		//if(1ll * dis[t] * a[t] > 0) return false; 求可行流最小费用，因此当费用增量大于0时不继续增加流量
		flow += a[t];
		cost += dis[t] * a[t];
		for(int u = t; u != s; u = edges[path[u]].from)
		{
			edges[path[u]].flow += a[t];
			edges[path[u] ^ 1].flow -= a[t];
		}
		return true;
	}

	int mincostMaxFlow(int s, int t)
	{
		int flow = 0, cost = 0;
		while(Bellman_Ford(s, t, flow, cost));
		return cost;
	}
};
\end{lstlisting}
\subsubsection{Trick}
\subsubsection*{建模技巧}


\indent

\textbf{二分图带权最大独立集}。给出一个二分图，每个结点上有一个正权值。要求选出一些点，使得这些点之间没有边相连，且权值和最大。

\indent

\textbf{解：}在二分图的基础上添加源点$S$和汇点$T$，然后从$S$向所有$X$集合中的点连一条边，所有$Y$集合中的点向$T$连一条边，容量均为该点的权值。$X$结点与$Y$结点之间的边的容量均为无穷大。这样，对于图中的任意一个割，将割中的边对应的结点删掉就是一个符合要求的解，权和为所有权减去割的容量。因此，只需要求出最小割，就能求出最大权和。

\indent

\textbf{公平分配问题}。把$m$个任务分配给$n$个处理器。其中每个任务有两个候选处理器，可以任选一个分配。要求所有处理器中，任务数最多的那个处理器所分配的任务数尽量少。不同任务的候选处理器集$\lbrace p_1 , p_2 \rbrace$保证不同。

\indent

\textbf{解：}本题有一个比较明显的二分图模型，即$X$结点是任务，$Y$结点是处理器。二分答案$x$，然后构图，首先从源点$S$出发向所有的任务结点引一条边，容量等于$1$，然后从每个任务结点出发引两条边，分别到达它所能分配到的两个处理器结点，容量为$1$，最后从每个处理器结点出发引一条边到汇点$T$，容量为$x$，表示选择该处理器的任务不能超过$x$。这样网络中的每个单位流量都是从$S$流到一个任务结点，再到处理器结点，最后到汇点$T$。只有当网络中的总流量等于$m$时才意味着所有任务都选择了一个处理器。这样，我们通过$O(\log m)$次最大流便算出了答案。

\indent

\textbf{区间$k$覆盖问题}。数轴上有一些带权值的左闭右开区间。选出权和尽量大的一些区间，使得任意一个数最多被k个区间覆盖。

\indent

\textbf{解：}本题可以用最小费用流解决，构图方法是把每个数作为一个结点，然后对于权值为$w$的区间$[u,v)$加边$u→v$，容量为$1$，费用为$-w$。再对所有相邻的点加边$i→i+1$，容量为$k$，费用为$0$。最后，求最左点到最右点的最小费用最大流即可，其中每个流量对应一组互不相交的区间。如果数值范围太大，可以先进行离散化。

\indent

\textbf{最大闭合子图}。给定带权图$G$（权值可正可负），求一个权和最大的点集，使得起点在该点集中的任意弧，终点也在该点集中。

\indent

\textbf{解：}新增附加源$s$和附加汇$t$，从$s$向所有正权点引一条边，容量为权值；从所有负权点向汇点引一条边，容量为权值的相反数。求出最小割以后，$S - \lbrace s \rbrace$就是最大闭合子图。

\indent

\textbf{最大密度子图}。给出一个无向图，找一个点集，使得这些点之间的边数除以点数的值（称为子图的密度）最大。

\indent

\textbf{解：}如果两个端点都选了，就必然要选边，这就是一种推导。如果把每个点和每条边都看成新图中的结点，可以把问题转化为最大闭合子图。

\indent

\textbf{无源汇有上下界可行流：}附加源$S$和汇$T$；对于边$(u, v, min, max)$，记$d[u]-=min, d[v]+=max$，并添加弧$(u, v, max - min)$；对于流量不平衡的点$u$，设多余流量为$W$,如果$W>0$，添加弧$S->u:W$，否则若$W<0$，添加弧$u->T:-W$，求改造后的网络$S-T$最大流即可，当且仅当所有附加弧满载时原图有可行流。

\indent

\textbf{有源汇有上下界可行流：}建$t->s$，容量为inf，然后和无源汇相同。

\indent

\textbf{有源汇有上下界最大/最小流：}与上面相同，跑完可行流$S->T$后去掉边$t->s$，最大流为加$s->t$，最小流为$G[s][t].cap-max_flow(t,s)$。

\subsubsection{Stoer Wagner}
\begin{lstlisting}
#define INF 100000000
bool vis[maxn], com[maxn];
int mp[maxn][maxn], w[maxn], s, t;

int maxadj(int n, int v) {
    int CUT = 0;
    memset(vis, 0, sizeof vis);
    memset(w, 0, sizeof w);
    for (int i = 0; i < n; ++i) {
        int num = 0, mx = -INF;
        for (int j = 0; j < v; ++j) {
            if (!com[j] && !vis[j] && w[j] > mx) {
                mx = w[j];
                num = j;
            }
        }
        vis[num] = 1;
        s = t;
        t = num;
        CUT = w[t];
        for (int j = 0; j < v; ++j) {
            if (!com[j] && !vis[j]) w[j] += mp[num][j];
        }
    }
    return CUT;
}

int stoer(int v) {
    int mincut = INF;
    int n = v;
    memset(com, 0, sizeof com);
    for (int i = 0; i < v - 1; ++i) {
        int cut;
        s = 0, t = 0;
        cut = maxadj(n, v);
        n --;
        if (cut < mincut) mincut = cut;
        com[t] = 1;
        for (int j = 0; j < v; ++j) {
            if (!com[j]) {
                mp[j][s] += mp[j][t];
                mp[s][j] += mp[t][j];
            }
        }
    }
    return mincut;
}\end{lstlisting}
\subsubsection{ZKW费用流}
\begin{lstlisting}
struct MCMF
{
    int last[maxn], dis[maxn], cnt, ans;
    int s, t;
    bool vis[maxn];
    struct edge { int from, to, cap, w, op, nex; } e[500000 + 10];
 
    void init(int S, int T)
    {
        s = S, t = T;
        cnt = 0, ans = 0;
        memset(vis, 0, sizeof vis);
        memset(dis, 0, sizeof dis);
        memset(last, 0, sizeof last);
    }
 
    void add(int u, int v, int cap, int cost)
    {
        e[++ cnt] = { u, v, cap, cost, cnt + 1, last[u] };
        last[u] = cnt;
        e[++ cnt] = { v, u, 0, -cost, cnt - 1, last[v] };
        last[v] = cnt;
    }
 
    int dfs(int x, int maxf)
    {
        if(x == t || maxf == 0) return maxf;
        int ret = 0;
        vis[x] = 1;
        for(int i = last[x]; i; i = e[i].nex)
            if(e[i].cap && dis[e[i].to] + e[i].w == dis[x] && !vis[e[i].to])
            {
                int f = dfs(e[i].to, min(e[i].cap, maxf - ret));
                ans += f * e[i].w;
                e[i].cap -= f;
                e[e[i].op].cap += f;
                ret += f;
                if(ret == maxf) break;
            }
        return ret;
    }
 
    bool change()
    {
        int mn = inf;
        for(int i = 0; i <= t; i ++)
            if(vis[i])
                for(int j = last[i]; j; j = e[j].nex)
                    if(!vis[e[j].to] && e[j].cap) mn = min(mn, -dis[i] + e[j].w + dis[e[j].to]);
        if(mn == inf) return false;
        for(int i = 0; i <= t; i ++) if(vis[i]) dis[i] += mn;
        return true;
    }
 
    void zkw()
    {
        do
        {
            for(int i = 0; i <= t; i ++) vis[i] = 0;
            while(dfs(s, inf)) for(int i = 0; i <= t; i ++) vis[i] = 0;
        }
        while(change());
    }
}ans;
\end{lstlisting}
\subsection{Others}
\subsubsection{拓扑排序}
\begin{lstlisting}
const int maxn = 1e5 + 10;

vector<int> edge[maxn];
int indegree[maxn];

void add(int u, int v)
{
    edge[u].push_back(v);
    indegree[v]++;
}

void Toposort(int n)
{
    queue<int> que;
    for (int i = 1; i <= n; i++)
        if (!indegree[i]) que.push(i);    //将图中没有前驱，即入度为0的点加入队列
    while (!que.empty())
    {
        int u = que.front();
        que.pop();
        indegree[u] = -1;    //从图中删去此顶点	
        for (int i = 0; i < edge[u].size(); i++)
        {
            int v = edge[u][i];
            indegree[v]--;    //删去图中以u为尾的弧
            if (!indegree[v]) que.push(v);    //将新增的当前入度为0的点压入队列中
        }
    }
}\end{lstlisting}
\subsubsection{2-SAT}
\begin{lstlisting}
/*2-SAT连边含义：选A必选B
    点$x_i$表示选，$x_i'$表示不选
    1.必选$x_i$，等价于$x_i=1$：$x_i'→x_i$
    2.必不选$x_i$，等价于$x_i=0$，$x_i→x_i'$
    3.$x_i$与$x_j$中至少选择一个，等价于$x_iORx_j=1$，连边$x_i'→x_j$,$x_j'→x_i$
    4.$x_i$与$x_j$不都选，等价于$x_iANDx_j=0$，连边$x_i→x_j',x_j→x_i'$
    5.$x_i$与$x_j$情况相同，等价于$x_iXORx_j=0$，连边$x_i→x_j$,$x_i'→x_j'$,$x_j→x_i$,$x_j'→x_i'$
    6.$x_i$与$x_j$情况相反，等价于$x_iXORx_j=1$，连边$x_i→x_j'$,$x_i'→x_j$,$x_j→x_i'$,$x_j'→x_i$
*/

const int maxn = 2e6 + 10;

namespace twosat {
    int n;
    int low[maxn], dfn[maxn], color[maxn], cnt, scc_cnt;
    bool instack[maxn];

    vector<int> g[maxn];
    stack<int> st;
    
    void init(int _n) {
        n = _n;
        cnt = scc_cnt = 0;
        for (int i = 0; i <= n * 2; ++i) {
            dfn[i] = 0;
            g[i].clear();
        }
    }

    void Tarjan(int u) {
        low[u] = dfn[u] = ++cnt;
        st.push(u);
        instack[u] = true;
        for (const auto &v : g[u]) {
            if (!dfn[v]) Tarjan(v), low[u] = min(low[u], low[v]);
            else if (instack[v]) low[u] = min(low[u], dfn[v]);
        }
        if (low[u] == dfn[u]) {
            ++scc_cnt;
            do {
                color[u] = scc_cnt;
                u = st.top();
                st.pop();
                instack[u] = false;
            } while (low[u] != dfn[u]);
        }
    }

    inline void add(int a, int b) { g[a].push_back(b); }

    inline void AND(int a, int b, int c) {
        if (c == 1) add(a, a + n), add(b, b + n);
        else add(a, b + n), add(b, a + n);
    }

    inline void OR(int a, int b, int c) {
        if (c == 0) add(a + n, a), add(b + n, b);
        else add(a + n, b), add(b + n, a);
    }

    inline void XOR(int a, int b, int c) {
        if (c == 0) add(a, b), add(a + n, b + n), add(b, a), add(b + n, a + n);
        else add(a, b + n), add(a + n, b), add(b, a + n), add(b + n, a);
    }

    bool TWO_SAT() {
        for (int i = 1; i <= (n << 1); i++) if (!dfn[i]) Tarjan(i);
        for (int i = 1; i <= n; i++)
            if (color[i] == color[i + n]) return false;
        for (int i = 1; i <= n; i++)
            printf("%d ", color[i] > color[i + n]);
        return true;
    }
}\end{lstlisting}
\subsubsection{差分约束系统}
\begin{lstlisting}
//以$x_i-x_j≤y$为约束条件，建图求最短路后得到的是最大解。所有的解都不大于且尽可能逼近$dis[x0]$
//最短路对应最大解，最长路对应最小解

const int maxn = 1000 + 10;
const int inf = 0x3f3f3f3f;

struct Edge
{
    int nex, to, w;
} edge[10 * maxn];

int head[maxn], cnt, dis[maxn], n;
bool vis[maxn];

void init()
{
    cnt = 0;
    memset(head, 0xff, sizeof head);
}

void add(int u, int v, int w)
{
    edge[cnt].nex = head[u];
    edge[cnt].to = v;
    edge[cnt].w = w;
    head[u] = ++cnt;
}

void spfa(int u)
{
    int u, v, w;
    for (int i = 1; i <= n; i++) dis[i] = inf, vis[i] = false;
    dis[u] = 0;
    queue<int> que;
    que.push(u);
    vis[u] = true;
    while (!que.empty())
    {
        u = que.front();
        que.pop();
        vis[u] = false;
        for (int i = head[u]; ~i; i = edge[i].nex)
        {
            v = edge[i].v, w = edge[i].w;
            if (dis[u] + w < dis[v])
            {
                dis[v] = dis[u] + w;
                if (!vis[v])
                {
                    que.push(v);
                    vis[v] = true;
                }
            }
        }
    }
}\end{lstlisting}
\subsubsection{支配树}
\begin{lstlisting}
const int N = 2e5 + 10;

int n, m;

struct G
{
	vector<int> edge[N];
	inline void add(int u, int v) { edge[u].push_back(v); }
}a, b, c, d;

int dfn[N], id[N], fa[N], cnt;

void dfs(int u)
{
	dfn[u] = ++ cnt; id[cnt] = u;
	int len = a.edge[u].size();
	for(auto v : a.edge[u]) if(!dfn[v]) { fa[v] = u; dfs(v); }
}

int semi[N], idom[N], belong[N], val[N];

int find(int x)
{
	if(x == belong[x]) return x;
	int tmp = find(belong[x]);
	if(dfn[semi[val[belong[x]]]] < dfn[semi[val[x]]]) val[x] = val[belong[x]];
	return belong[x] = tmp;
}

void tarjan()
{
	for(int i = cnt; i > 1; i --)
	{
		int u = id[i];
		for(auto v : b.edge[u])
		{
			if(!dfn[v]) continue;
			find(v);
			if(dfn[semi[val[v]]] < dfn[semi[u]]) semi[u] = semi[val[v]];
		}
		c.add(semi[u], u);
		belong[u] = fa[u];
		u = fa[u];
		for(auto v : c.edge[u])
		{
			find(v);
			if(semi[val[v]] == u) idom[v] = u;
			else idom[v] = val[v];
		}
	}
	for(int i = 2; i <= cnt; i ++)
	{
		int u = id[i];
		if(idom[u] != semi[u]) idom[u] = idom[idom[u]];
	}
}

int ans[N];

void dfs_ans(int u)
{
	ans[u] = 1;
	for(auto v : d.edge[u]) dfs_ans(v), ans[u] += ans[v];
}

void solve()
{
    int u, v;
    scanf("%d%d", &n, &m);
    while(m --)
    {
        scanf("%d%d", &u, &v);
        a.add(u, v);
        b.add(v, u);
    }
	for(int i = 1; i <= n; i ++) semi[i] = belong[i] = val[i] = i;
	dfs(1);
	tarjan();
	for(int i = 2; i <= n; i ++) d.add(idom[i], i);
	dfs_ans(1);
	for(int i = 1; i <= n; i ++) printf("%d ", ans[i]);
}\end{lstlisting}
\subsubsection{Stable Matching Problem}
\begin{lstlisting}
const int maxn = 1000 + 10;

int pre[maxn][maxn], order[maxn][maxn], nex[maxn];
int hus[maxn], wife[maxn];
queue<int> que;

void engage(int man, int woman) {
    int m = hus[woman];
    if (m) wife[m] = 0, q.push(m);
    wife[man] = woman;
    hus[woman] = man;
}

int solve() {
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++)
            scanf("%d", &pre[i][j]);
        nex[i] = 1;
        wife[i] = 0;
        que.push(i);
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            int x;
            scanf("%d", &x);
            order[i][x] = j;
        }
        hus[i] = 0;
    }

    while (!que.empty()) {
        int man = que.front();
        que.pop();
        int woman = pre[man][nex[man]++];
        if (!hus[woman]) engage(man, woman);
        else if (order[woman][man] < order[woman][hus[woman]]) engage(man, woman);
        else que.push(man);
    }
}\end{lstlisting}
\subsubsection{一般图最大团}
\begin{lstlisting}
#define u64 unsigned long long
#define i64 long long

const u64 BITCOUNT = sizeof(u64) * 8;

u64 count_trailing_zeroes(u64 a) {
    if (a == 0ull)
        return BITCOUNT;
    return __builtin_ctzll(a);
}
u64 disable_bit(u64 a, u64 bit) { return a & (~(1ull << bit)); }
u64 popcount(u64 a) { return __builtin_popcountll(a); }

map<u64, u64> max_clique_cache;

u64 max_clique(u64 mask, vector<u64> const &graph_matrix) { // 最大独立集传补图即可
    if (max_clique_cache.find(mask) != max_clique_cache.end())
        return max_clique_cache[mask];
    u64 a = count_trailing_zeroes(mask);
    if (a == BITCOUNT) return 0;
    u64 res1 = max_clique(disable_bit(mask, a), graph_matrix);
    u64 res2 = max_clique(mask & disable_bit(graph_matrix[a], a), graph_matrix) | (1ull << a);
    u64 res = popcount(res1) > popcount(res2) ? res1 : res2;
    max_clique_cache[mask] = res;
    return res;
}

int main() {
    vector<u64> M;
    int n;
    while (scanf("%d", &n) != EOF) {
        if (n == 0) break;
        M.clear();
        M.resize(n);
        max_clique_cache.clear();
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                int x; scanf("%d", &x);
                if (x == 1) M[i] |= 1ll << j;
            }
        }
        printf("%d\n", popcount(max_clique((1ll << n) - 1, M)));
    }
}\end{lstlisting}
\clearpage\section{DataStructrue}
\subsection{SegmentTreeDS}
\subsubsection{SGTB}
\begin{lstlisting}
int n, a[maxn];

struct node {
    int p, t, se;

    node() {}

    node(int p, int t, int se) : p(p), t(t), se(se) {}

    inline friend node combineMax(node a, node b) {
        node c;
        if (a.p < b.p) {
            c.p = b.p;
            c.t = b.t;
            c.se = max(a.p, b.se);
        } else if (a.p > b.p) {
            c.p = a.p;
            c.t = a.t;
            c.se = max(a.se, b.p);
        } else {
            c.p = a.p;
            c.t = a.t + b.t;
            c.se = max(a.se, b.se);
        }
        return c;
    }

    inline friend node combineMin(node a, node b) {
        node c;
        if (a.p > b.p) {
            c.p = b.p;
            c.t = b.t;
            c.se = min(a.p, b.se);
        } else if (a.p < b.p) {
            c.p = a.p;
            c.t = a.t;
            c.se = min(a.se, b.p);
        } else {
            c.p = a.p;
            c.t = a.t + b.t;
            c.se = min(a.se, b.se);
        }
        return c;
    }

    inline friend node operator+(node a, int p) {
        return node(a.p + p, a.t, a.se + p);
    }
};

struct SGTB {
#define inf 1e9
    node mx[maxn << 2], mi[maxn << 2];
    int tag[maxn << 2];
    ll s[maxn << 2];
# define ls (x<<1)
# define rs (x<<1|1)

    inline void up(int x) {
        mx[x] = combineMax(mx[ls], mx[rs]);
        mi[x] = combineMin(mi[ls], mi[rs]);
        s[x] = s[ls] + s[rs];
    }

    // a = max(a, t)
    inline void pushmax(int x, int l, int r, int p) {
        s[x] += 1ll * mi[x].t * (p - mi[x].p);
        mi[x].p = p;
        mx[x].p = max(mx[x].p, p);
        if (mi[x].p == mx[x].p) {
            mi[x].se = inf, mx[x].se = -inf;
            mi[x].t = mx[x].t = r - l + 1;
            s[x] = 1ll * mi[x].p * (r - l + 1);
        } else mx[x].se = max(mx[x].se, p);
    }

    // a = min(a, t)
    inline void pushmin(int x, int l, int r, int p) {
        s[x] += 1ll * mx[x].t * (p - mx[x].p);
        mx[x].p = p;
        mi[x].p = min(mi[x].p, p);
        if (mi[x].p == mx[x].p) {
            mi[x].se = inf, mx[x].se = -inf;
            mi[x].t = mx[x].t = r - l + 1;
            s[x] = 1ll * mi[x].p * (r - l + 1);
        } else mi[x].se = min(mi[x].se, p);
    }

    inline void pushtag(int x, int l, int r, int p) {
        tag[x] += p;
        s[x] += 1ll * (r - l + 1) * p;
        mx[x] = mx[x] + p, mi[x] = mi[x] + p;
    }

    inline void down(int x, int l, int r) {
        int mid = l + r >> 1;
        if (tag[x]) {
            pushtag(ls, l, mid, tag[x]);
            pushtag(rs, mid + 1, r, tag[x]);
            tag[x] = 0;
        }
        if (mx[ls].p > mx[x].p && mx[ls].se < mx[x].p) pushmin(ls, l, mid, mx[x].p);
        if (mx[rs].p > mx[x].p && mx[rs].se < mx[x].p) pushmin(rs, mid + 1, r, mx[x].p);
        if (mi[ls].p < mi[x].p && mi[ls].se > mi[x].p) pushmax(ls, l, mid, mi[x].p);
        if (mi[rs].p < mi[x].p && mi[rs].se > mi[x].p) pushmax(rs, mid + 1, r, mi[x].p);
    }

    inline void build(int x, int l, int r) {
        tag[x] = 0;
        if (l == r) {
            mx[x].p = mi[x].p = s[x] = a[l], mx[x].t = mi[x].t = 1, mx[x].se = -inf, mi[x].se = inf;
            return;
        }
        int mid = l + r >> 1;
        build(ls, l, mid);
        build(rs, mid + 1, r);
        up(x);
    }

    // add p to [L, R]
    inline void edt(int x, int l, int r, int L, int R, int p) {
        if (L <= l && r <= R) {
            pushtag(x, l, r, p);
            return;
        }
        down(x, l, r);
        int mid = l + r >> 1;
        if (L <= mid) edt(ls, l, mid, L, R, p);
        if (R > mid) edt(rs, mid + 1, r, L, R, p);
        up(x);
    }

    // ai=min(ai, p) in [L, R]
    inline void edtmin(int x, int l, int r, int L, int R, int p) {
        if (mx[x].p <= p) return;
        if (L <= l && r <= R && mx[x].se < p) {
            pushmin(x, l, r, p);
            return;
        }
        down(x, l, r);
        int mid = l + r >> 1;
        if (L <= mid) edtmin(ls, l, mid, L, R, p);
        if (R > mid) edtmin(rs, mid + 1, r, L, R, p);
        up(x);
    }

    // ai=max(ai, p) in [L, R]
    inline void edtmax(int x, int l, int r, int L, int R, int p) {
        if (mi[x].p >= p) return;
        if (L <= l && r <= R && mi[x].se > p) {
            pushmax(x, l, r, p);
            return;
        }
        down(x, l, r);
        int mid = l + r >> 1;
        if (L <= mid) edtmax(ls, l, mid, L, R, p);
        if (R > mid) edtmax(rs, mid + 1, r, L, R, p);
        up(x);
    }

    inline int gmax(int x, int l, int r, int L, int R) {
        if (L <= l && r <= R) return mx[x].p;
        down(x, l, r);
        int mid = l + r >> 1, ret = -inf;
        if (L <= mid) ret = max(ret, gmax(ls, l, mid, L, R));
        if (R > mid) ret = max(ret, gmax(rs, mid + 1, r, L, R));
        return ret;
    }

    inline int gmin(int x, int l, int r, int L, int R) {
        if (L <= l && r <= R) return mi[x].p;
        down(x, l, r);
        int mid = l + r >> 1, ret = inf;
        if (L <= mid) ret = min(ret, gmin(ls, l, mid, L, R));
        if (R > mid) ret = min(ret, gmin(rs, mid + 1, r, L, R));
        return ret;
    }

    inline ll gsum(int x, int l, int r, int L, int R) {
        if (L <= l && r <= R) return s[x];
        down(x, l, r);
        int mid = l + r >> 1;
        ll ret = 0;
        if (L <= mid) ret += gsum(ls, l, mid, L, R);
        if (R > mid) ret += gsum(rs, mid + 1, r, L, R);
        return ret;
    }

    inline void debug(int x, int l, int r) {
        printf("%d %d %d [%d %d %d] [%d %d %d] %lld\n", x, l, r, mx[x].p, mx[x].t, mx[x].se, mi[x].p, mi[x].t, mi[x].se,
               s[x]);
        if (l == r) return;
        int mid = l + r >> 1;
        debug(ls, l, mid);
        debug(rs, mid + 1, r);
    }

# undef ls
# undef rs
# undef inf
} T;\end{lstlisting}
\subsubsection{离散化区间}
\begin{lstlisting}
// 原题1e5个区间有2e5个端点，离散化出来4e5个区间
// 然后线段树需要4e5*4=16e5的大小
// 注意三个数组要开离散化数量的四倍，如果不需要sz可以不用这个数组。
int val[maxn << 4];
int lpos[maxn << 2], rpos[maxn << 2], tot, sz[maxn << 2];
vector<int> xpos;
sort(xpos.begin(), xpos.end());
xpos.erase(unique(xpos.begin(), xpos.end()), xpos.end());
tot = 1;
lpos[1] = rpos[1] = xpos[0];
sz[1] = 1;
for (int i = 1; i < xpos.size(); ++i) {
    if (xpos[i] - xpos[i - 1] != 1) {
        lpos[++tot] = xpos[i - 1] + 1;
        rpos[tot] = xpos[i] - 1;
        sz[tot] = rpos[tot] - lpos[tot] + 1;
    }
    ++tot;
    lpos[tot] = rpos[tot] = xpos[i];
    sz[tot] = 1;
}
le = lower_bound(lpos + 1, lpos + 1 + tot, p[i].x) - lpos;
re = upper_bound(rpos + 1, rpos + 1 + tot, p[i].y) - rpos - 1;\end{lstlisting}
\subsubsection{动态区间最大子段和}
\begin{lstlisting}
namespace ST {
    struct node{
        ll ans,ls,rs,sum;
    }xx[maxn << 2];
    inline void pushdown(int x){
        xx[x].sum=xx[x<<1].sum+xx[x<<1|1].sum;
        xx[x].ls=max(xx[x<<1].ls,xx[x<<1].sum+xx[x<<1|1].ls);
        xx[x].rs=max(xx[x<<1|1].rs,xx[x<<1|1].sum+xx[x<<1].rs);
        xx[x].ans=max(xx[x<<1].ans,max(xx[x<<1|1].ans,xx[x<<1].rs+xx[x<<1|1].ls));
        return;
    }
    inline void build(int k,int l,int r){
        if(l==r){
            xx[k].ls=xx[k].rs=xx[k].ans=xx[k].sum=0;
            return;
        }
        int mid=l+r>>1;
        build(k<<1,l,mid),build(k<<1|1,mid+1,r);
        pushdown(k);
        return;
    }
    inline void change(int k,int l,int r,int x,int y,int w){ // 1, 1, n
        if(x<=l&&r<=y){
            xx[k].ls += w;
            xx[k].rs += w;
            xx[k].ans += w;
            xx[k].sum += w;
//            xx[k].ls=xx[k].rs=xx[k].ans=xx[k].sum=w;
            return;
        }
        int mid=l+r>>1;
        if(x<=mid) change(k<<1,l,mid,x,y,w);
        if(mid<y) change(k<<1|1,mid+1,r,x,y,w);
        pushdown(k);
        return;
    }
    inline node query(int k,int l,int r,int x,int y){
        if(x<=l&&r<=y) {
            return xx[k];
        }
        int mid=l+r>>1;
        if(x<=mid&&!(mid<y)) return query(k<<1,l,mid,x,y);
        else if(!(x<=mid)&&mid<y) return query(k<<1|1,mid+1,r,x,y);
        else{
            node st,t1=query(k<<1,l,mid,x,y),t2=query(k<<1|1,mid+1,r,x,y);
            st.sum=t1.sum+t2.sum;
            st.ls=max(t1.ls,t1.sum+t2.ls);
            st.rs=max(t2.rs,t2.sum+t1.rs);
            st.ans=max(t1.ans,max(t2.ans,t1.rs+t2.ls));
            return st;
        }
    }
}\end{lstlisting}
\subsubsection{动态开点权值线段树}
\begin{lstlisting}
int root[100005];
int ls[1800000], rs[1800000], sum[1800000];
int sz = 0;

void insert(int &k, int l, int r, int val){
    if (!k) k = ++sz;
    if (l == r) {
        sum[k] = 1;
        return;
    }
    int mid = (l + r) >> 1;
    if (val <= mid) insert(ls[k], l, mid, val);
    else insert(rs[k], mid + 1, r, val);
    sum[k] = sum[ls[k]] + sum[rs[k]];
}

int query(int k, int l, int r, int rank) {
    if (l == r) return l;
    int mid = (l + r) >> 1;
    if (sum[ls[k]] >= rank) return query(ls[k], l, mid, rank);
    else return query(rs[k], mid + 1, r, rank - sum[ls[k]]);
}
int merge(int x, int y)
{
    if (!x) return y;
    if (!y) return x;
    ls[x] = merge(ls[x], ls[y]);
    rs[x] = merge(rs[x], rs[y]);
    sum[x] = sum[ls[x]] + sum[rs[x]];
    return x;
}
insert(root[i], 1, n, a[i]);
query(root[p], 1, n, x);\end{lstlisting}
\subsubsection{扫描线}
\begin{lstlisting}
// 范用型扫描线，del储存上界+1，add储存下界，先del后add即可
struct node {
    int lpos, rpos, linepos;
    bool operator < (const node& oth) const {
        return linepos < oth.linepos;
    }
};
vector<node> add, del;
int delpos = 0;
int res = 0;
for (int addpos = 0; addpos < add.size(); ++addpos) {
    while (delpos < del.size() && del[delpos].linepos <= add[addpos].linepos) {
        up(del[delpos].lpos, del[delpos].rpos, -1);
        delpos ++;
    }
    up(add[addpos].lpos, add[addpos].rpos, 1);
    res = max(res, val[1]);
}

// 求面积并
#define maxn 222
#define tmp (st<<1)
#define mid ((l+r)>>1)
#define lson l,mid,tmp
#define rson mid+1,r,tmp|1
using namespace std;
int cnt[maxn<<2];
double sum[maxn<<2];
double x[maxn];
struct Seg{
    double h,l,r;
    int s;
    Seg(){}
    Seg(double a,double b,double c,int d):l(a),r(b),h(c),s(d){}
    bool operator<(const Seg &cmp)const{
        return h<cmp.h;
    }
}ss[maxn];
void push_up(int st,int l,int r){
    if(cnt[st])sum[st]=x[r+1]-x[l];
    else if(l==r)sum[st]=0;
    else sum[st]=sum[tmp]+sum[tmp|1];
}
void update(int L,int R,int c,int l,int r,int st){
    if(L<=l&&r<=R){
        cnt[st]+=c;
        push_up(st,l,r);
        return ;
    }
    if(L<=mid)update(L,R,c,lson);
    if(R>mid)update(L,R,c,rson);
    push_up(st,l,r);
}
int main(){
    int n,tot=1,m;
    while(scanf("%d",&n)&&n){
        double a,b,c,d;
        m=0;
        while(n--){
            scanf("%lf%lf%lf%lf",&a,&b,&c,&d);
            x[m]=a;
            ss[m++]=Seg(a,c,b,1);
            x[m]=c;
            ss[m++]=Seg(a,c,d,-1);
        }
        sort(x,x+m);
        sort(ss,ss+m);
        double ans=0;
        for(int i=0;i<m;++i){
            int l=lower_bound(x,x+m,ss[i].l)-x;
            int r=lower_bound(x,x+m,ss[i].r)-x-1;
            update(l,r,ss[i].s,0,m-1,1);
            ans+=sum[1]*(ss[i+1].h-ss[i].h);
        }
        printf("Test case #%dnTotal explored area: %.2lfnn",tot++,ans);
    }
    return 0;
}

// 面积交
#include<bits/stdc++.h>
#define maxn 100005
#define lson l,mid,rt<<1
#define rson mid+1,r,rt<<1|1
#define pb push_back
using namespace std;

double tree[maxn<<2],tree2[maxn<<2];
int lazy[maxn<<2];
vector<double>ve;

struct seg{
    double l,r,h;
    int flag;
    seg(){}
    seg(double _l,double _r,double _h,int _flag){l=_l,r=_r,h=_h,flag=_flag;}
    bool operator<(const seg &b)const{return h<b.h;}
}s[maxn];

void push_up(int l,int r,int rt){
    if(lazy[rt]) tree[rt]=ve[r]-ve[l-1];
    else if(l==r) tree[rt]=0;
    else tree[rt]=tree[rt<<1]+tree[rt<<1|1];
}

void push_up2(int l,int r,int rt){
    if(lazy[rt]>1) tree2[rt]=ve[r]-ve[l-1];
    else if(l==r) tree2[rt]=0;
    else if(lazy[rt]==1)tree2[rt]=tree[rt<<1]+tree[rt<<1|1];
    else tree2[rt]=tree2[rt<<1]+tree2[rt<<1|1];
}

void build(int l,int r,int rt){
    tree[rt]=0,lazy[rt]=0;
    if(l==r) return;
    int mid=l+r>>1;
    build(lson);
    build(rson);
}

void add(int L,int R,int v,int l,int r,int rt){
    if(L<=l&&R>=r){
        lazy[rt]+=v;
        push_up(l,r,rt);
        push_up2(l,r,rt);
        return;
    }
    int mid=l+r>>1;
    if(L<=mid) add(L,R,v,lson);
    if(R>mid) add(L,R,v,rson);
    push_up(l,r,rt);
    push_up2(l,r,rt);
}

int getid(double x){ return lower_bound(ve.begin(),ve.end(),x)-ve.begin()+1;}

int main(){
    int n;
    int Case=1;
    int T;
    scanf("%d",&T);
    while(T--){
        scanf("%d",&n);
        ve.clear();
        int tot=0;
        double x1,y1,x2,y2;
        for(int i=1;i<=n;i++){
            scanf("%lf %lf %lf %lf",&x1,&y1,&x2,&y2);
            ve.pb(x1),ve.pb(x2);
            s[++tot]=seg(x1,x2,y1,1);
            s[++tot]=seg(x1,x2,y2,-1);
        }
        sort(ve.begin(),ve.end());
        ve.erase(unique(ve.begin(),ve.end()),ve.end());
        sort(s+1,s+tot+1);
        int N=ve.size();
        build(1,N,1);
        double ans=0;
        for(int i=1;i<tot;i++){
            int L=getid(s[i].l);
            int R=getid(s[i].r)-1;
            add(L,R,s[i].flag,1,N,1);
            ans+=tree2[1]*(s[i+1].h-s[i].h);
        }
        printf("%.2f\n",ans);
    }
}

// 求周长并
#include<bits/stdc++.h>
#define maxn 100005
#define lson l,mid,rt<<1
#define rson mid+1,r,rt<<1|1
#define pb push_back
using namespace std;

int tree[maxn<<2];
int lazy[maxn<<2];
vector<int>ve[2];
int k;

struct seg{
    int l,r,h;
    int flag;
    seg(){}
    seg(int _l,int _r,int _h,int _flag){l=_l,r=_r,h=_h,flag=_flag;}
    bool operator<(const seg &b)const{return h<b.h;}
}s[maxn];

void push_up(int l,int r,int rt){
    if(lazy[rt]) tree[rt]=ve[k][r]-ve[k][l-1];
    else if(l==r) tree[rt]=0;
    else tree[rt]=tree[rt<<1]+tree[rt<<1|1];
}

void build(int l,int r,int rt){
    tree[rt]=0,lazy[rt]=0;
    if(l==r) return;
    int mid=l+r>>1;
    build(lson);
    build(rson);
}

void add(int L,int R,int v,int l,int r,int rt){
    if(L<=l&&R>=r){
        lazy[rt]+=v;
        push_up(l,r,rt);
        return;
    }
    int mid=l+r>>1;
    if(L<=mid) add(L,R,v,lson);
    if(R>mid) add(L,R,v,rson);
    push_up(l,r,rt);
}

int getid(int x){return lower_bound(ve[k].begin(),ve[k].end(),x)-ve[k].begin()+1;}

int main(){
    int n;
    while(~scanf("%d",&n)){
        ve[0].clear();
        ve[1].clear();
        int x1,y1,x2,y2;
        for(int i=1;i<=n;i++){
            scanf("%d %d %d %d",&x1,&y1,&x2,&y2);
            ve[0].pb(x1),ve[0].pb(x2);
            ve[1].pb(y1),ve[1].pb(y2);
            s[i]=seg(x1,x2,y1,1);
            s[i+n]=seg(x1,x2,y2,-1);
            s[i+n+n]=seg(y1,y2,x1,1);
            s[i+n+n+n]=seg(y1,y2,x2,-1);
        }
        int ans=0;
        int pos=1;
        for(k=0;k<2;k++){
            sort(ve[k].begin(),ve[k].end());
            ve[k].erase(unique(ve[k].begin(),ve[k].end()),ve[k].end());
            sort(s+pos,s+pos+n+n);
            int N=ve[k].size();
            build(1,N,1);
            int pre=0;
            for(int i=pos;i<pos+n+n;i++){
                int L=getid(s[i].l);
                int R=getid(s[i].r)-1;
                add(L,R,s[i].flag,1,N,1);
                ans+=abs(tree[1]-pre);
                pre=tree[1];
            }
            pos+=n+n;
        }
        printf("%d\n",ans);
    }
}\end{lstlisting}
\subsection{HLD}
\subsubsection{HLD}
\begin{lstlisting}
#include <bits/stdc++.h>
#define ll long long
using namespace std;
/*
node 计算点权， path 下放后计算边权， edge 根据边的编号计算边权
work 中没有build需手动写
sz[]数组，以x为根的子树节点个数
top[]数组，当前节点的所在链的顶端节点
son[]数组，重儿子
deep[]数组，当前节点的深度
fa[]数组，当前节点的父亲
idx[]数组，树中每个节点剖分后的新编号
rnk[]数组，idx的逆，表示线段上中当前位置表示哪个节点
*/

const int maxn = 1e5+5;

int sz[maxn], top[maxn], son[maxn], deep[maxn], fa[maxn], idx[maxn], rnk[maxn];
int tot;
int n, le, re;
ll k;

struct HLD {
#define type int

    struct edge {
        int a, b;
        type v;

        edge(int _a, int _b, type _v = 0) : a(_a), b(_b), v(_v) {}
    };

    struct node {
        int to;
        type w;

        node() {}

        node(int _to, type _w) : to(_to), w(_w) {}
    };

    vector<int> mp[maxn];
    vector<edge> e;

    void init(int _n) {
        n = _n;
        for (int i = 0; i <= n; i++) mp[i].clear();
        e.clear();
        e.push_back(edge(0, 0));
    }

    void add_edge(int a, int b, type v = 0) {
//        e.push_back(edge(a,b,v));
        mp[a].push_back(b);
        mp[b].push_back(a);
    }

    void dfs1(int x, int pre, int h) {
        int i, to;
        deep[x] = h;
        fa[x] = pre;
        sz[x] = 1;
        for (i = 0; i < (int) (mp[x].size()); i++) {
            to = mp[x][i];
            if (to == pre) continue;
            dfs1(to, x, h + 1);
            sz[x] += sz[to];
            if (son[x] == -1 || sz[to] > sz[son[x]]) son[x] = to;
        }
    }

    void dfs2(int x, int tp) {
        int i, to;
        top[x] = tp;
        idx[x] = ++tot;
        rnk[idx[x]] = x;
        if (son[x] == -1) return;
        dfs2(son[x], tp);
        for (i = 0; i < (int) (mp[x].size()); i++) {
            to = mp[x][i];
            if (to != son[x] && to != fa[x]) dfs2(to, to);
        }
    }

    void work(int _rt = 1) {
        memset(son, -1, sizeof son);
        tot = 0;
        dfs1(_rt, 0, 0);
        dfs2(_rt, _rt);
    }

    int LCA(int x, int y) {
        while (top[x] != top[y]) {
            if (deep[top[x]] < deep[top[y]]) swap(x, y);
            x = fa[top[x]];
        }
        if (deep[x] > deep[y]) swap(x, y);
        return x;
    }

    void modify_node(int x, int y, type val) {
        while (top[x] != top[y]) {
            if (deep[top[x]] < deep[top[y]]) swap(x, y);
            le = idx[top[x]], re = idx[x];
            k = val;
            update(1, 1, n);
            x = fa[top[x]];
        }
        if (deep[x] > deep[y]) swap(x, y);
        le = idx[x], re = idx[y];
        k = val;
        update(1, 1, n);
    }

    type query_node(int x, int y) {
        type res = 0;
        while (top[x] != top[y]) {
            if (deep[top[x]] < deep[top[y]]) swap(x, y);
            le = idx[top[x]], re = idx[x];
            res += query(1, 1, n);
            x = fa[top[x]];
        }
        if (deep[x] > deep[y]) swap(x, y);
        le = idx[x], re = idx[y];
        res += query(1, 1, n);
        return res;
    }

    //path
//    void init_path()
//    {
//        v[idx[rt]]=0;
//        for(int i=1;i<n;i++)
//        {
//            if(deep[e[i].a]<deep[e[i].b]) swap(e[i].a,e[i].b);
//            a[idx[e[i].a]]=e[i].v;
//        }
//        build(n);
//    }
    void modify_edge(int id, type val) {
        if (deep[e[id].a] > deep[e[id].b]) {
            le = idx[e[id].a], re = idx[e[id].a];
            k = val;
            update(1, 1, n);
        } else {
            le = idx[e[id].b], re = idx[e[id].b];
            k = val;
            update(1, 1, n);
        }
    }

    void modify_path(int x, int y, type val) {
        while (top[x] != top[y]) {
            if (deep[top[x]] < deep[top[y]]) swap(x, y);
            le = idx[top[x]], re = idx[x];
            k = val;
            update(1, 1, n);
            x = fa[top[x]];
        }
        if (deep[x] > deep[y]) swap(x, y);
        if (x != y) {
            le = idx[x] + 1, re = idx[y];
            k = val;
            update(1, 1, n);
        }
    }

    type query_path(int x, int y) {
        type res = 0;
        while (top[x] != top[y]) {
            if (deep[top[x]] < deep[top[y]]) swap(x, y);
            le = idx[top[x]], re = idx[x];
            res += query(1, 1, n);
            x = fa[top[x]];
        }
        if (deep[x] > deep[y]) swap(x, y);
        if (x != y) {
            le = idx[x] + 1, re = idx[y];
            res += query(1, 1, n);
        }
        return res;
    }

#undef type
} hld;\end{lstlisting}
\subsection{RMQ}
\subsubsection{RMQbyIndex}
\begin{lstlisting}
int pmax(int x, int y) { return a[x] > a[y] ? x : y; }
int pmin(int x, int y) { return a[x] < a[y] ? x : y; }
void init() {
    for (int i = 1; i <= n; i++) {
        maxx[i][0] = minn[i][0] = i;
    }
    for (int j = 1; 1 << (j - 1) <= n; j++) {
        for (int i = 1; i + (1 << j) - 1 <= n; i++) {
            int t = 1 << (j - 1);
            maxx[i][j] = pmax(maxx[i][j - 1], maxx[i + t][j - 1]);
            minn[i][j] = pmin(minn[i][j - 1], minn[i + t][j - 1]);
        }
    }
}
int query(int l, int r) {
    int j = 0;
    while ((1 << (j + 1)) <= r - l + 1) j++;
    int i = r - (1 << j) + 1;
//    return pmax(maxx[l][j], maxx[i][j]);
	return pmin(minn[l][j], minn[i][j]);
}\end{lstlisting}
\subsubsection{RMQinNM}
\begin{lstlisting}
//二维RMQ
int v[302][302];
int maxx[302][302][9][9], minn[302][302][9][9];

void RMQ(int n, int m) {
    int i, j, ii, jj;
    for (i = 1; i <= n; i++) {
        for (j = 1; j <= m; j++) {
            maxx[i][j][0][0] = minn[i][j][0][0] = v[i][j];
        }
    }
    for (ii = 0; (1 << ii) <= n; ii++) {
        for (jj = 0; (1 << jj) <= m; jj++) {
            if (ii + jj) {
                for (i = 1; i + (1 << ii) - 1 <= n; i++) {
                    for (j = 1; j + (1 << jj) - 1 <= m; j++) {
                        if (ii) {
                            minn[i][j][ii][jj] = min(minn[i][j][ii - 1][jj], minn[i + (1 << (ii - 1))][j][ii - 1][jj]);
                            maxx[i][j][ii][jj] = max(maxx[i][j][ii - 1][jj], maxx[i + (1 << (ii - 1))][j][ii - 1][jj]);
                        } else {
                            minn[i][j][ii][jj] = min(minn[i][j][ii][jj - 1], minn[i][j + (1 << (jj - 1))][ii][jj - 1]);
                            maxx[i][j][ii][jj] = max(maxx[i][j][ii][jj - 1], maxx[i][j + (1 << (jj - 1))][ii][jj - 1]);
                        }
                    }
                }
            }
        }
    }
}

int query(int x1, int y1, int x2, int y2) {
    int k1 = 0;
    while ((1 << (k1 + 1)) <= x2 - x1 + 1) k1++;
    int k2 = 0;
    while ((1 << (k2 + 1)) <= y2 - y1 + 1) k2++;
    x2 = x2 - (1 << k1) + 1;
    y2 = y2 - (1 << k2) + 1;
    return max(max(maxx[x1][y1][k1][k2], maxx[x1][y2][k1][k2]), max(maxx[x2][y1][k1][k2], maxx[x2][y2][k1][k2]));
//	return min(min(minn[x1][y1][k1][k2],minn[x1][y2][k1][k2]),min(minn[x2][y1][k1][k2],minn[x2][y2][k1][k2]));
}\end{lstlisting}
\subsection{MO}
\subsubsection{分块}
\begin{lstlisting}
// 非预处理数组版
inline int belong(int x) { return (x - 1) / block + 1; }
inline int lpos(int x) { return 1 + (x - 1) * block; }
inline int rpos(int x) { return min(n, x * block); }
int sz = (n - 1) / block + 1;

// 预处理版，maxn大于1e6已经不可能处理了
const int maxb = 1005;
int n, m;
int belong[maxn], lpos[maxb], rpos[maxb];
int val[maxn], lazy[maxb];
int block;

scanf("%d", &n);
block = sqrt(n);
for (int i = 1; i <= n; ++i) {
    scanf("%d", &val[i]);
    belong[i] = (i - 1) / block + 1;
}
int sz = (n - 1) / block + 1;
for (int i = 1; i <= sz; ++i) {
    lpos[i] = 1 + (i - 1) * block;
    rpos[i] = i * block;
}
rpos[sz] = n;\end{lstlisting}
\subsubsection{带修莫队}
\begin{lstlisting}
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn = 50005;

struct MO {
    int l, r, id, oppre;
}q[maxn];

int n, m, col[maxn], block, belong[maxn], colpre[maxn];
int changepos[maxn], changepre[maxn], changenow[maxn];
int vis[maxn * 20];
int ans;
int res[maxn];
bool cmp(const MO& a, const MO& b) {
    if (belong[a.l] != belong[b.l]) return a.l < b.l;
    if (belong[a.r] != belong[b.r]) return a.r < b.r;
    return a.oppre < b.oppre;
}
void add(int x) {}

void del(int x) {}

void unmodify(int pos, int now) {
    if (q[pos].l <= changepos[now] && changepos[now] <= q[pos].r) {
        del(changenow[now]);
        add(changepre[now]);
    }
    col[changepos[now]] = changepre[now];
}

void modify(int pos, int now) {
    if (q[pos].l <= changepos[now] && changepos[now] <= q[pos].r) {
        del(changepre[now]);
        add(changenow[now]);
    }
    col[changepos[now]] = changenow[now];
}

int main() {
    scanf("%d%d", &n, &m);
    block = pow(n, 0.66666);
    for (int i = 1; i <= n; ++i) {
        scanf("%d", &col[i]);
        colpre[i] = col[i];
        belong[i] = i / block + 1;
    }
    char s[2];
    int t = 0, t2 = 0;
    for (int i = 1; i <= m; ++i) {
        scanf("%s", s);
        if (s[0] == 'Q') {
            ++t;
            scanf("%d%d", &q[t].l, &q[t].r);
            q[t].oppre = t2;
            q[t].id = t;
        } else {
            ++t2;
            scanf("%d%d", &changepos[t2], &changenow[t2]);
            changepre[t2] = colpre[changepos[t2]];
            colpre[changepos[t2]] = changenow[t2];
        }
    }
    sort(q + 1, q + 1 + t, cmp);
    int l = 1, r = 0, now = 0;
    for (int i = 1; i <= t; ++i) {
        while(r < q[i].r) add(col[++r]);
        while(r > q[i].r) del(col[r--]);
        while(l < q[i].l) del(col[l++]);
        while(l > q[i].l) add(col[--l]);
        while (now < q[i].oppre) modify(i, ++now);
        while (now > q[i].oppre) unmodify(i, now--);
        res[q[i].id] = ans;
    }
    for (int i = 1; i <= t; ++i) printf("%d\n", res[i]);
    return 0;
}\end{lstlisting}
\subsubsection{序列莫队}
\begin{lstlisting}
// const int maxn = 50005;

struct MO {
    int l, r, id;
}q[maxn];

int n, m, col[maxn], block, belong[maxn];
int vis[maxn * 10];
ll res[maxn], ans;
bool cmp(const MO& a, const MO& b) { return belong[a.l] == belong[b.l] ? a.r < b.r : a.l < b.l; }
void add(int x) {
    vis[x] ++;
    ans += 1ll * x * (vis[x] * vis[x] - (vis[x] - 1) * (vis[x] - 1));
}

void del(int x) {
    vis[x] --;
    ans -= 1ll * x * ((vis[x] + 1) * (vis[x] + 1) - vis[x] * vis[x]);
}

int main() {
    scanf("%d%d", &n, &m);
    block = sqrt(n);
    for (int i = 1; i <= n; ++i) {
        scanf("%d", &col[i]);
        belong[i] = i / block + 1;
    }
    for (int i = 1; i <= m; ++i) {
        scanf("%d%d", &q[i].l, &q[i].r);
        q[i].id = i;
    }
    sort(q + 1, q + 1 + m, cmp);
    int l = 1, r = 0;
    for (int i = 1; i <= m; ++i) {
        while(r < q[i].r) add(col[++r]);
        while(r > q[i].r) del(col[r--]);
        while(l < q[i].l) del(col[l++]);
        while(l > q[i].l) add(col[--l]);
        res[q[i].id] = ans;
    }
    for (int i = 1; i <= m; ++i) printf("%lld\n", res[i]);
    return 0;
}\end{lstlisting}
\subsubsection{弹飞绵羊}
\begin{lstlisting}
/*
每个装置设定初始弹力系数ki，当绵羊达到第i个装置时，它会往后弹ki步，
达到第i+ki个装置，若不存在第i+ki个装置，则绵羊被弹飞。
绵羊想知道当它从第i个装置起步时，被弹几次后会被弹飞。
为了使得游戏更有趣，Lostmonkey可以修改某个弹力装置的弹力系数，任何时候弹力系数均为正整数。
*/

int n, m;
int belong[maxn], lpos[maxn], rpos[maxn];
int val[maxn], nxt[maxn], k[maxn], lst[maxn];
int block;

void update(int pos) {
    int llim = lpos[belong[pos]], rlim = rpos[belong[pos]];
    for (int i = pos; i >= llim; --i) {
        if (val[i] + i > rlim) {
            k[i] = 1;
            nxt[i] = val[i] + i;
            if (val[i] + i > n) lst[i] = i;
            else lst[i] = lst[nxt[i]];
        } else {
            k[i] = 1 + k[val[i] + i];
            nxt[i] = nxt[val[i] + i];
            lst[i] = lst[val[i] + i];
        }
    }
}

void init() {
    for (int i = n; i >= 1; --i) {
        int rlim = rpos[belong[i]];
        if (val[i] + i > rlim) {
            k[i] = 1;
            nxt[i] = val[i] + i;
            if (val[i] + i > n) lst[i] = i;
            else lst[i] = lst[nxt[i]];
        } else {
            k[i] = 1 + k[val[i] + i];
            nxt[i] = nxt[val[i] + i];
            lst[i] = lst[val[i] + i];
        }
    }
}

int query(int pos) {
    int res = 0;
    while (pos <= n) {
        res += k[pos];
        if (nxt[pos] > n) printf("%d ", lst[pos]);
        pos = nxt[pos];
    }
    return res;
}

int main(int argc, char* argv[]) {
    scanf("%d%d", &n, &m);
    block = sqrt(n) * 1.6 + 1;
    for (int i = 1; i <= n; ++i) {
        scanf("%d", &val[i]);
        belong[i] = (i - 1) / block + 1;
    }
    int sz = (n - 1) / block + 1;
    for (int i = 1; i <= sz; ++i) {
        lpos[i] = 1 + (i - 1) * block;
        rpos[i] = i * block;
    }
    rpos[sz] = n;
    init();
    while (m--) {
        int op;
        scanf("%d", &op);
        if (op == 1) {
            int pos;
            scanf("%d", &pos);
            printf("%d\n", query(pos));
        } else {
            int pos, kl;
            scanf("%d%d", &pos, &kl);
            val[pos] = kl;
            update(pos);
        }
    }
    return 0;
}\end{lstlisting}
\subsubsection{树莫队}
\begin{lstlisting}
// rnk保存欧拉序
int sz[maxn], top[maxn], son[maxn], deep[maxn], fa[maxn], idx[maxn], ed[maxn], rnk[maxn*2];
int tot, n, m;
vector<int> edge[maxn];
int val[maxn];
vector<int> xpos;

inline void dfs1(int u, int pre, int h) {
    deep[u] = h;
    fa[u] = pre;
    sz[u] = 1;
    for (auto to : edge[u]) {
        if (to == pre) continue;
        dfs1(to, u, h + 1);
        sz[u] += sz[to];
        if (son[u] == 0 || sz[to] > sz[son[u]]) son[u] = to;
    }
}

inline void dfs2(int u, int tp) {
    top[u] = tp;
    idx[u] = ++tot, rnk[tot] = u;
    if (son[u] == 0) {
        ed[u] = ++tot, rnk[tot] = u;
        return;
    }
    dfs2(son[u], tp);
    for (auto to : edge[u]) {
        if (to != son[u] && to != fa[u]) dfs2(to, to);
    }
    ed[u] = ++tot, rnk[tot] = u;
}

inline int LCA(int x, int y) {
    while (top[x] != top[y]) {
        if (deep[top[x]] < deep[top[y]]) swap(x, y);
        x = fa[top[x]];
    }
    if (deep[x] > deep[y]) swap(x, y);
    return x;
}

int belong[maxn*2], block;
int res[maxn], ans;
// 每个点是否访问（欧拉序去重）
int vis[maxn];
// 标记数组
int pre[maxn];
struct MO {
    int l, r, id, lca;
    bool operator < (const MO& oth) const {
        return belong[l] == belong[oth.l] ? r < oth.r : belong[l] < belong[oth.l];
    }
}q[maxm];

inline void add(int x) {
    pre[x] ++;
    if (pre[x] == 1) ans ++;
}

inline void del(int x) {
    pre[x] --;
    if (pre[x] == 0) ans --;
}

inline void deal(int x) {
    vis[x] ? del(val[x]) : add(val[x]);
    vis[x] = !vis[x];
}

int main(int argc, char* argv[]) {
    scanf("%d%d", &n, &m);
    block = sqrt(n);
    xpos.resize(n + 1);
    for (int i = 1; i <= n; ++i) {
        scanf("%d", &val[i]);
        xpos[i] = val[i];
    }
    sort(xpos.begin(), xpos.end());
    xpos.erase(unique(xpos.begin(), xpos.end()), xpos.end());
    for (int i = 1; i <= n; ++i) val[i] = lower_bound(xpos.begin(), xpos.end(), val[i]) - xpos.begin();
    // 欧拉序长度为n两倍所以分块要分两倍大小
    for (int i = 1; i <= n * 2; ++i) {
        belong[i] = (i - 1) / block + 1;
    }
    for (int i = 1, u, v; i < n; ++i) {
        scanf("%d%d", &u, &v);
        edge[u].push_back(v);
        edge[v].push_back(u);
    }
    // 树剖预处理lca
    dfs1(1, 0, 0);
    dfs2(1, 1);
    for (int i = 1, x, y; i <= m; ++i) {
        scanf("%d%d", &x, &y);
        if (idx[x] > idx[y]) swap(x, y);
        int _lca = LCA(x, y);
        q[i].id = i;
        if (_lca == x) q[i].l = idx[x], q[i].r = idx[y], q[i].lca = 0;
        else q[i].l = ed[x], q[i].r = idx[y], q[i].lca = _lca;
//        cerr << q[i].l << " " << q[i].r << " " << q[i].id << " " << q[i].lca << endl;
    }
    sort(q + 1, q + 1 + m);
    int l = 1, r = 0;
    for (int i = 1; i <= m; ++i) {
        while(r < q[i].r) deal(rnk[++r]);
        while(r > q[i].r) deal(rnk[r--]);
        while(l < q[i].l) deal(rnk[l++]);
        while(l > q[i].l) deal(rnk[--l]);
        if (q[i].lca) deal(q[i].lca);
        res[q[i].id] = ans;
        if (q[i].lca) deal(q[i].lca);
    }
    for (int i = 1; i <= m; ++i) {
        printf("%d\n", res[i]);
    }
    return 0;
}\end{lstlisting}
\subsection{VirtualTree}
\subsubsection{VirtualTree}
\begin{lstlisting}
const int pow2 = 19;
int n;
vector<int> adj0[maxn], adj1[maxn];
int st[maxn << 1][pow2 + 1], dep[maxn], euler[maxn], euler_clock;
int stk[maxn], fa0[maxn];
vector<int> cache;
void link0(int u, int v) { adj0[u].emplace_back(v); adj0[v].emplace_back(u); }
void link1(int u, int v) { adj1[u].emplace_back(v), cache.push_back(u); }
void clearAll() {
    for (int i = 1; i <= n; ++i) {
        adj0[i].clear();
        adj1[i].clear();
    }
    euler_clock = 0;
}
void clearVT() { for (auto i : cache) adj1[i].clear(); cache.clear(); }
void dfs0(int u, int p) {
    fa0[u] = p;
    dep[u] = dep[p] + 1;
    st[++euler_clock][0] = u;
    euler[u] = euler_clock;
    for (const auto& v : adj0[u]) if (v != p) {
            dfs0(v, u);
            st[++euler_clock][0] = u;
        }
}
inline bool cmp(int u, int v) {return dep[u] < dep[v];}
inline int upper(int u, int v) {return cmp(u, v) ? u : v;}
void lca_init() {
    for (int i = 0; i != 31 - __builtin_clz(euler_clock); ++i)
        for (int j = 1; j + (1 << (i + 1)) <= euler_clock; ++j)
            st[j][i + 1] = upper(st[j][i], st[j + (1 << i)][i]);
}
inline int lca(int u, int v) {
    if (u == v) return u;
    u = euler[u];
    v = euler[v];
    if (u > v) swap(u, v);
    int temp = 31 - __builtin_clz(++v - u);
    return upper(st[u][temp], st[v - (1 << temp)][temp]);
}
// build 后 stk[1] 是该树的根节点，且为有根树
void build(vector<int>& key) {
    sort(key.begin(), key.end(), [&] (int u, int v) { return euler[u] < euler[v]; });
    key.erase(unique(key.begin(), key.end()), key.end());
    int top = 0;
    for (auto u : key) {
        if (!top) {
            stk[++top] = u;
            continue;
        }
        int p = lca(u, stk[top]);
        while (euler[p] < euler[stk[top]]) {
            if (euler[p] >= euler[stk[top - 1]]) {
                link1(p, stk[top]);
                if (stk[--top] != p) stk[++top] = p;
                break;
            }
            link1(stk[top - 1], stk[top]);
            --top;
        }
        stk[++top] = u;
    }
    while (top > 1) {
        link1(stk[top - 1], stk[top]);
        --top;
    }
}

int f[maxn];
int res;
int vis[maxn];
void dfs1(int u) {
    fa1[u] = p;
    len[u] = dep[u] - dep[p];
    for (auto v : adj1[u]) {
        dfs1(v);
    }
}

int main(int argc, char* argv[]) {
    scanf("%d", &n);
    for (int i = 1, u, v; i < n; ++i) {
        scanf("%d%d", &u, &v);
        link0(u, v);
    }
    dfs0(1, 0);
    lca_init();
    int m; scanf("%d", &m);
    for (int i = 0; i < m; ++i) {
        int sz; scanf("%d", &sz);
        vector<int> key(sz);
        for (int j = 0; j < sz; ++j) {
            scanf("%d", &key[j]);
            vis[key[j]] = 1;
        }
        build(key);
        res = 0;
        dfs1(stk[1]);
        printf("%d\n", res);
        for (int j = 0; j < sz; ++j) vis[key[j]] = 0;
        clearVT();
    }
    return 0;
}\end{lstlisting}
\subsection{PersistentDS}
\subsubsection{主席树区间k大}
\begin{lstlisting}
// const int maxn = 100005;
int n, m;
int a[maxn];
int root[maxn];
int cnt = 0;
vector<int> b;
struct node {
    int l, r, val;
}p[maxn * 40];

void update(int l, int r, int pre, int &now, int pos) {
    p[now = ++cnt] = p[pre];
    p[now].val++;
    if (l == r) {
        return;
    }
    int mid = l + r >> 1;
    if (pos <= mid) update(l, mid, p[pre].l, p[now].l, pos);
    else update(mid + 1, r, p[pre].r, p[now].r, pos);
}

/*
void build(int pre, int &now, int pos) {
    now = pre;
    for (auto i : a[pos]) {
        update(1, n, pre, now, i);
    }
}
*/

int query(int l, int r, int x, int y, int k) {
    if (l == r) return b[l - 1];
    int mid = l + r >> 1;
    int temp = p[p[y].l].val - p[p[x].l].val;
    if (k <= temp) return query(l, mid, p[x].l, p[y].l, k);
    return query(mid + 1, r, p[x].r, p[y].r, k - temp);
}

int main(int argc,char *argv[])
{
    while (scanf("%d%d", &n, &m) != EOF) {
        b.clear();
        cnt = 0;
        for (int i = 1; i <= n; ++i) scanf("%d", &a[i]), b.push_back(a[i]);
        sort(b.begin(), b.end());
        b.erase(unique(b.begin(), b.end()), b.end());
        for (int i = 1; i <= n; ++i) {
            update(1, b.size(), root[i - 1], root[i], lower_bound(b.begin(), b.end(), a[i]) - b.begin() + 1);
        }
        int L, R, k;
        while (m--) {
            scanf("%d%d%d", &L, &R, &k);
            printf("%d\n", query(1, b.size(), root[L - 1], root[R], k));
        }
    }
    return 0;
}\end{lstlisting}
\subsubsection{动态森林}
\begin{lstlisting}
const int maxn = 10010;
struct Splay {
    int ch[maxn][2], fa[maxn], tag[maxn];
    void clear(int x) { ch[x][0] = ch[x][1] = fa[x] = tag[x] = 0; }
    int getch(int x) { return ch[fa[x]][1] == x; }
    int isroot(int x) { return ch[fa[x]][0] != x && ch[fa[x]][1] != x; }
    void pushdown(int x) {
        if (tag[x]) {
            if (ch[x][0]) swap(ch[ch[x][0]][0], ch[ch[x][0]][1]), tag[ch[x][0]] ^= 1;
            if (ch[x][1]) swap(ch[ch[x][1]][0], ch[ch[x][1]][1]), tag[ch[x][1]] ^= 1;
            tag[x] = 0;
        }
    }
    void update(int x) {
        if (!isroot(x)) update(fa[x]);
        pushdown(x);
    }
    void rotate(int x) {
        int y = fa[x], z = fa[y], chx = getch(x), chy = getch(y);
        fa[x] = z;
        if (!isroot(y)) ch[z][chy] = x;
        ch[y][chx] = ch[x][chx ^ 1];
        fa[ch[x][chx ^ 1]] = y;
        ch[x][chx ^ 1] = y;
        fa[y] = x;
    }
    void splay(int x) {
        update(x);
        for (int f = fa[x]; f = fa[x], !isroot(x); rotate(x))
            if (!isroot(f)) rotate(getch(x) == getch(f) ? f : x);
    }
    void access(int x) {
        for (int f = 0; x; f = x, x = fa[x]) splay(x), ch[x][1] = f;
    }
    void makeroot(int x) {
        access(x);
        splay(x);
        swap(ch[x][0], ch[x][1]);
        tag[x] ^= 1;
    }
    int find(int x) {
        access(x);
        splay(x);
        while (ch[x][0]) x = ch[x][0];
        splay(x);
        return x;
    }
} st;

// 动态森林
namespace LCT {
    void clear(int n) { for (int i = 0; i <= n; ++i) st.clear(i); }
    bool isConnect(int u, int v) { return st.find(u) == st.find(v); }
    bool add(int u, int v) {
        if (isConnect(u, v)) return false;
        st.makeroot(u), st.fa[u] = v;
        return true;
    }
    // 无法判断是否存在直接相连的边
    void del(int u, int v) {
        st.makeroot(u);
        st.access(v);
        st.splay(v);
        if (st.ch[v][0] == u && !st.ch[u][1]) st.ch[v][0] = st.fa[u] = 0;
    }
}
using namespace LCT;
\end{lstlisting}
\subsection{Tree}
\subsubsection{LCA}
\begin{lstlisting}
// const int maxn = 1e5 + 10;

// 普通倍增lca
int n, dep[maxn], fa[maxn][30];
vector<int> edge[maxn];

void dfs(int u, int pre) {
	dep[u] = dep[pre] + 1, fa[u][0] = pre;
	for(int i = 1; (1 << i) <= n; i ++) 
		fa[u][i] = fa[fa[u][i - 1]][i - 1];
	for(auto v : edge[u]) if(v != pre) dfs(v, u);
}

int LCA(int u, int v) {
	if(dep[u] < dep[v]) swap(u, v);
	int d = dep[u] - dep[v];
	for(int i = 0; (1 << i) <= d; i ++) 
		if((1 << i) & d) u = fa[u][i];
	if(u == v) return u;
	for(int i = 20; i >= 0; i --) 
		if(fa[u][i] != fa[v][i]) 
			u = fa[u][i], v = fa[v][i];
	return fa[u][0];
}\end{lstlisting}
\subsubsection{点分治}
\begin{lstlisting}
int n, k;

// 清零 head 和 tot
const int maxm = maxn * 2;
int ver[maxm], Next[maxm], head[maxn], edge[maxm];
int tot;
void addEdge(int u, int v, int w){
    ver[++tot]=v;
    Next[tot]=head[u];
    head[u]=tot;
    edge[tot]=w;
}

int sz[maxn], vis[maxn];
int rt, mxsz, has;

void getrt(int u, int pre) {
    sz[u] = 1;
    int mxnow = 0;
    for (int i = head[u]; i; i = Next[i]) {
        int v = ver[i];
        if (v == pre || vis[v]) continue;
        getrt(v, u);
        sz[u] += sz[v];
        mxnow = max(mxnow, sz[v]);
    }
    mxnow = max(mxnow, has - sz[u]);
    if (mxnow < mxsz) {
        mxsz = mxnow, rt = u;
    }
}

int dl[maxn], r;
int val[maxn];

void getdis(int u, int pre) {
    dl[r++] = val[u];
    for (int i = head[u]; i; i = Next[i]) {
        int v = ver[i];
        if (v == pre || vis[v]) continue;
        val[v] = val[u] + edge[i];
        getdis(v, u);
    }
}

ll cal(int u, int pre) {
    r = 0;
    val[u] = pre;
    getdis(u, 0);
    ll sum = 0;
    sort(dl, dl + r);
    r --;
    int l = 0;
    while (l < r) {
        if (dl[l] + dl[r] > k) r --;
        else sum += r - l, l ++;
    }
    return sum;
}

ll res = 0;
void dfs(int u) {
    res += cal(u, 0);
    vis[u] = 1;
    for (int i = head[u]; i; i = Next[i]) {
        int v = ver[i];
        if (vis[v]) continue;
        res -= cal(v, edge[i]);
        has = sz[v];
        mxsz = 0x3f3f3f3f;
        getrt(v, 0);
        dfs(rt);
    }
}

int main(int argc, char* argv[]) {
    while (scanf("%d%d", &n, &k) != EOF && (n || k)) {
        tot = 0; memset(head, 0, sizeof head);
        memset(vis, 0, sizeof vis);
        res = 0;
        for (int i = 1, u, v, w; i < n; ++i) {
            scanf("%d%d%d", &u, &v, &w);
            addEdge(u, v, w);
            addEdge(v, u, w);
        }
        mxsz = 0x3f3f3f3f;
        has = n;
        getrt(1, 0);
        dfs(rt);
        printf("%lld\n", res);
    }
    return 0;
}\end{lstlisting}
\subsection{Splay}
\begin{lstlisting}
/*
1. 插入x数
2. 删除x数(若有多个相同的数，因只删除一个)
3. 查询x数的排名(若有多个相同的数，因输出最小的排名)
4. 查询排名为x的数
5. 求x的前驱(前驱定义为小于x，且最大的数)
6. 求x的后继(后继定义为大于x，且最小的数)
*/

const int N = 1e5 + 7;

struct Splay {
	int ch[N][2], fa[N], val[N], cnt[N], size[N], tol, root;
	inline bool chk(int x) {
		return ch[fa[x]][1] == x;
	}
	inline void pushup(int x) {
		size[x] = size[ch[x][0]] + size[ch[x][1]] + cnt[x];
	}
	void rotate(int x) {
		int y = fa[x], z = fa[y], k = chk(x), w = ch[x][k ^ 1];
		ch[y][k] = w; fa[w] = y;
		ch[z][chk(y)] = x; fa[x] = z;
		ch[x][k ^ 1] = y; fa[y] = x;
		pushup(y); pushup(x);
	}
	void splay(int x, int goal = 0) {
		while (fa[x] != goal) {
			int y = fa[x], z = fa[y];
			if (z != goal) {
				if (chk(x) == chk(y)) rotate(y);
				else rotate(x);
			}
			rotate(x);
		}
		if (!goal) root = x;
	}
	void insert(int x) {
		int cur = root, p = 0;
		while (cur && val[cur] != x) {
			p = cur;
			cur = ch[cur][x > val[cur]];
		}
		if (cur) {
			cnt[cur]++;
		} else {
			cur = ++tol;
			if (p) ch[p][x > val[p]] = cur;
			ch[cur][0] = ch[cur][1] = 0;
			fa[cur] = p; val[cur] = x;
			cnt[cur] = size[cur] = 1;
		}
		splay(cur);
	}
	void find(int x) {
		int cur = root;
		while (ch[cur][x > val[cur]] && x != val[cur])
			cur = ch[cur][x > val[cur]];
		splay(cur);
	}
	int kth(int k) {
		int cur = root;
		while (1) {
			if (ch[cur][0] && k <= size[ch[cur][0]])
				cur = ch[cur][0];
			else if (k > size[ch[cur][0]] + cnt[cur])
				k -= size[ch[cur][0]] + cnt[cur], cur = ch[cur][1];
			else 
				break;
		}
		return cur;
	}
	int pre(int x) {
		find(x);
		if (val[root] < x) return root;
		int cur = ch[root][0];
		while (ch[cur][1]) cur = ch[cur][1];
		return cur;
	}
	int succ(int x) {
		find(x);
		if (val[root] > x) return root;
		int cur = ch[root][1];
		while (ch[cur][0]) cur = ch[cur][0];
		return cur;
	}
	void del(int x) {
		int last = pre(x), nxt = succ(x);
		splay(last); splay(nxt, last);
		int del = ch[nxt][0];
		if (cnt[del] > 1)
			cnt[del]--, splay(del);
		else
			ch[nxt][0] = 0;
	}
	int getrk(int x) {
		find(x);
		return size[ch[root][0]];
	}
} splay;

int n;

int main() {
	//freopen("in.txt", "r", stdin);
	splay.insert(0x3f3f3f3f);
	splay.insert(0xcfcfcfcf);
	read(n);
	while (n--) {
		int opt, x;
		read(opt, x);
		if (opt == 1) splay.insert(x);
		else if (opt == 2) splay.del(x);
		else if (opt == 3) print(splay.getrk(x));
		else if (opt == 4) print(splay.val[splay.kth(x + 1)]);
		else if (opt == 5) print(splay.val[splay.pre(x)]);
		else print(splay.val[splay.succ(x)]);
	}
	flush();
	return 0;
}\end{lstlisting}
\subsection{Others}
\subsubsection{BITinNM}
\begin{lstlisting}
struct Fenwick_Tree {
#define type int
    type bit[maxn][maxn];
    int n, m;
    void init(int _n, int _m) {
        n = _n;
        m = _m;
        mem(bit, 0);
    }
    int lowbit(int x) { return x & (-x); }
    void update(int x, int y, type v) {
        int i, j;
        for (i = x; i <= n; i += lowbit(i)) {
            for (j = y; j <= m; j += lowbit(j)) {
                bit[i][j] += v;
            }
        }
    }
    type get(int x, int y) {
        type i, j, res = 0;
        for (i = x; i > 0; i -= lowbit(i)) {
            for (j = y; j > 0; j -= lowbit(j)) {
                res += bit[i][j];
            }
        }
        return res;
    }
    type query(int x1, int x2, int y1, int y2) {
        x1--;
        y1--;
        return get(x2, y2) - get(x1, y2) - get(x2, y1) + get(x1, y1);
    }
#undef type
} tr;

// 二维区间前缀和写法（非树状数组）
inline void range_add(int xa, int ya, int xb, int yb) { add(xa, ya, 1), add(xa, yb + 1, -1), add(xb + 1, ya, -1), add(xb + 1, yb + 1, 1); }
inline ll range_ask(int xa, int ya, int xb, int yb){ return ask(xb, yb) - ask(xb, ya - 1) - ask(xa - 1, yb) + ask(xa - 1, ya - 1); }
inline void build() {
    // 预处理出每个点的单点值
	for (int i = 1; i < n + 5; ++i) {
        for (int j = 1; j < m + 5; ++j) {
            st[i][j] += st[i - 1][j] + st[i][j - 1] - st[i - 1][j - 1];
        }
    }
    // 再求一次处理出每个点的前缀和
    for (int i = 1; i < n + 5; ++i) {
        for (int j = 1; j < m + 5; ++j) {
            if (st[i][j] > 1) st[i][j] = 1;
            st[i][j] += st[i - 1][j] + st[i][j - 1] - st[i - 1][j - 1];
        }
    }
}

// 二维树状数组区间加与求和
ll t1[maxn][maxn], t2[maxn][maxn], t3[maxn][maxn], t4[maxn][maxn];
void add(ll x, ll y, ll z){
    for(int X = x; X <= n; X += X & -X)
        for(int Y = y; Y <= m; Y += Y & -Y){
            t1[X][Y] += z;
            t2[X][Y] += z * x;
            t3[X][Y] += z * y;
            t4[X][Y] += z * x * y;
        }
}
ll ask(ll x, ll y){
    ll res = 0;
    for(int i = x; i; i -= i & -i)
        for(int j = y; j; j -= j & -j)
            res += (x + 1) * (y + 1) * t1[i][j]
                - (y + 1) * t2[i][j]
                - (x + 1) * t3[i][j]
                + t4[i][j];
    return res;
}

// 区间加，询问单点：直接维护前缀差分数组，求单点=普通求前缀和\end{lstlisting}
\subsubsection{静态区间k大划分树}
\begin{lstlisting}
// const int maxn = 100010;
int tree[20][maxn];
// 读入sorted并排序，赋值给tree的第0层
int sorted[maxn];
int toleft[20][maxn];
// 保存左子树的和
// ll sum[20][maxn];

// 1, n, 0
void build(int l, int r, int dep) {
    if (l == r) return;
    // sum[dep][0] = 0;
    toleft[dep][0] = 0;
    int mid = l + r >> 1;
    int same = mid - l + 1;
    for (int i = l; i <= r; ++i) {
        if (tree[dep][i] < sorted[mid]) same--;
    }
    int lpos = l, rpos = mid + 1;
    for (int i = l; i <= r; ++i) {
        // sum[dep][i] = sum[dep][i - 1];
        if (tree[dep][i] < sorted[mid]) {
            // sum[dep][i] += tree[dep][i];
            tree[dep + 1][lpos++] = tree[dep][i];
        }
        else if (tree[dep][i] == sorted[mid] && same > 0) {
            // sum[dep][i] += tree[dep][i];
            tree[dep + 1][lpos++] = tree[dep][i];
            same --;
        } else tree[dep + 1][rpos ++] = tree[dep][i];
        toleft[dep][i] = toleft[dep][l - 1] + lpos - l;
    }
    build(l, mid, dep + 1);
    build(mid + 1, r, dep + 1);
}

//(1~k-1)的数的和，注意每次查询前初始化
// ll ress = 0;

// L = 1, R = n， dep = 0, l,r是查询区间
int query(int L, int R, int l, int r, int dep, int k) {
    if (l == r) return tree[dep][l];
    int mid = (L + R) >> 1;
    int cnt = toleft[dep][r] - toleft[dep][l - 1];
    if (cnt >= k) {
        int newl = L + toleft[dep][l - 1] - toleft[dep][L - 1];
        int newr = newl + cnt - 1;
        return query(L, mid, newl, newr, dep + 1, k);
    } else {
        int newr = r + toleft[dep][R] - toleft[dep][r];
        int newl = newr - (r - l - cnt);
        // ress += sum[dep][r] - sum[dep][l - 1];
        return query(mid + 1, R, newl, newr, dep + 1, k - cnt);
    }
}


scan(n), scan(m);
for (int i = 1; i <= n; ++i) {
    scan(sorted[i]);
    tree[0][i] = sorted[i];
}
sort(sorted + 1, sorted + 1 + n);
build(1, n, 0);
int l, r, k;
while (m--) {
    scan(l), scan(r), scan(k);
    printf("%d\n", query(1, n, l, r, 0, k));
}\end{lstlisting}
\subsubsection{二叉堆}
\begin{lstlisting}
template<class T = int>
struct BinaryHeap {
    vector<T> Heap;
    int sz;
    BinaryHeap(int s = 0) { Heap.resize(s), sz = 0; }
    void init(int s) { Heap.resize(s), sz = 0; }
    bool less(T a, T b) { return a > b; }
    void up(int p) {
        while (p > 1) {
            if (less(Heap[p / 2], Heap[p])) {
                swap(Heap[p], Heap[p / 2]);
                p /= 2;
            } else break;
        }
    }
    void down(int p) {
        int s = p * 2;
        while (s <= sz) {
            if (s < sz && less(Heap[s], Heap[s + 1])) s++;
            if (less(Heap[p], Heap[s])) {
                swap(Heap[s], Heap[p]);
                p = s, s = p * 2;
            } else break;
        }
    }
    void insert(int val) {
        Heap[++sz] = val;
        up(sz);
    }
    void removeTop() {
        Heap[1] = Heap[sz--];
        down(1);
    }
    void remove(int pos) {
        Heap[pos] = Heap[sz--];
        up(pos), down(pos);
    }
    int getTop() {
       assert(sz > 0);
       return Heap[1];
    }
};\end{lstlisting}
\clearpage\section{String}
\subsection{KMP}
\subsubsection{KMP}
\begin{lstlisting}
// nxt[0]表示失配到完全不匹配
int nxt[maxm];

void getNext(char *s, int len) {
    int i = 0, j = -1;
    nxt[i] = j;
    while (i < len) {
        if (j == -1 || s[i] == s[j]) nxt[++i] = ++j;
        else j = nxt[j];
    }
}

// a为原串，b为模式串，下标从0开始，找第一个出现模式串的位置（起点为1），找不到返回-1
int KMP(char *a, char *b, int n, int m) {
    getNext(b, m);
    int i = 0, j = 0;
    while (i < n && j < m) {
        if (j == -1 || a[i] == b[j]) ++i, ++j;
        else j = nxt[j];
    }
    return j == m ? i - m + 1 : -1;
}\end{lstlisting}
\subsubsection{exKMP}
\begin{lstlisting}
const int maxn = 1e5 + 10;
int nex[maxn], extend[maxn];

//预处理计算Next数组
void getNext(char *str)
{
    int i = 0, j, po, len = strlen(str);
    nex[0] = len;     //初始化nex[0]
    while (str[i] == str[i + 1] && i + 1 < len) i++;   //计算nex[1]
    nex[1] = i;
    po = 1;   //初始化po的位置
    for (int i = 2; i < len; i++)
    {
        if (nex[i - po] + i < nex[po] + po)  //第一种情况，可以直接得到nex[i]的值
            nex[i] = nex[i - po];
        else    //第二种情况，要继续匹配才能得到nex[i]的值
        {
            j = nex[po] + po - i;
            if (j < 0) j = 0;    //如果i>po+nex[po],则要从头开始匹配
            while (i + j < len && str[j] == str[j + i]) j++;
            nex[i] = j;
            po = i;   //更新po的位置
        }
    }
}

void EXKMP(char *s1, char *s2)
{
    int i = 0, j, po, len = strlen(s1), l2 = strlen(s2);
    getNext(s2);
    while (s1[i] == s2[i] && i < l2 && i < len) i++;
    extend[0] = i;
    po = 0;
    for (int i = 1; i < len; i++)
    {
        if (nex[i - po] + i < extend[po] + po)
            extend[i] = nex[i - po];
        else
        {
            j = extend[po] + po - i;
            if (j < 0) j = 0;
            while (i + j < len && j < l2 && s1[j + i] == s2[j]) j++;
            extend[i] = j;
            po = i;
        }
    }
}\end{lstlisting}
\subsection{Trie}
\subsubsection{Trie}
\begin{lstlisting}
const int maxn = 2e6 + 10;

int trie[maxn][30], tot;
bool flag[maxn];

void insert_ch(char *str)
{
    int len = strlen(str);
    int root = 0;
    for (int i = 0; i < len; i++)
    {
        int id = str[i] - 'a';
        if (!trie[root][id]) trie[root][id] = ++tot;
        root = trie[root][id];
    }
    flag[root] = true;
}

bool find_ch(char *str)
{
    int len = strlen(str);
    int root = 0;
    for (int i = 0; i < len; i++)
    {
        int id = str[i] - 'a';
        if (!trie[root][id]) return false;
        root = trie[root][id];
    }
    return true;
}\end{lstlisting}
\subsubsection{Persistence Trie}
\begin{lstlisting}
const int maxn = 1e5 + 10;

int a[maxn], rt[maxn], n;

struct Trie
{
	int tot;
	int child[maxn * 32][2], sum[maxn *32];
	int insert(int x, int val)
	{
		int tmp, y;
		tmp = y= ++tot;
		for(int i = 30; i >= 0; --i)
		{
			child[y][0] = child[x][0];
			child[y][1] = child[x][1];
			sum[y] = sum[x] + 1;
			int t = val >> i & 1;
			x = child[x][t];
			child[y][t] = ++tot;
			y = child[y][t];
		}
		sum[y] = sum[x] + 1;
		return tmp;
	}
	int query(int l, int r, int val)
	{
		int tmp = 0;
		for(int i =30; i >= 0; --i)
		{
			int t = val >> i & 1;
			if(sum[child[r][t^1]] - sum[child[l][t^1]]) tmp += (1<<i), r = child[r][t^1], l = child[l][t ^ 1];
			else r = child[r][t], l = child[l][t];
		}
		return tmp;
	}
}trie;\end{lstlisting}
\subsubsection{01Trie}
\begin{lstlisting}
struct Trie {
    int tree[maxn*20][2], tot;
    int flag[maxn*20];

    void insert_ch(int x) {
        int root = 0;
        flag[0]++;
        for (int i = 30; i >= 0; --i) {
            int id = (x >> i) & 1;
            if (!tree[root][id]) {
                tree[root][id] = ++tot;
                tree[tree[root][id]][0] = tree[tree[root][id]][1] = 0;
                flag[tree[root][id]] = flag[tree[tree[root][id]][0]] = flag[tree[tree[root][id]][1]] = 0;
            }
            root = tree[root][id];
            flag[root]++;
        }
    }

    void del(int x) {
        int root = 0;
        flag[0]--;
        for (int i = 30; i >= 0; --i) {
            int id = (x >> i) & 1;
            assert(tree[root][id]);
            if (flag[tree[root][id]] == 1) {
                flag[tree[root][id]] = 0;
                tree[root][id] = 0;
                return;
            }
            root = tree[root][id];
            flag[root]--;
        }
    }

    int find_ch(int x, int flag = 0) { // flag 0 最小异或值， 1 最大异或值
        int root = 0;
        int res = 0;
        for (int i = 30; i >= 0; --i) {
            int id = ((x >> i) & 1);
            if (flag) id = !id;
            if (tree[root][id]) {
                root = tree[root][id];
                res = res << 1 | id;
            } else {
                root = tree[root][!id];
                res = res << 1 | (!id);
            }
        }
        return res;
    }

    void init() {
        tree[0][0] = tree[0][1] = 0;
        tot = 0;
    }
};\end{lstlisting}
\subsection{Manachar}
\subsubsection{Manacher}
\begin{lstlisting}
const int maxn = 1e5 + 10;

char s[maxn];

char tmp[maxn << 1];
int Len[maxn << 1];

int init(char *str)
{
    int len = strlen(str);
    tmp[0] = '@';
    for (int i = 1; i <= 2 * len; i += 2)
    {
        tmp[i] = '#';
        tmp[i + 1] = str[i / 2];
    }
    tmp[2 * len + 1] = '#';
    tmp[2 * len + 2] = '$';
    tmp[2 * len + 3] = 0;
    return 2 * len + 1;
}

int manacher(char *str)
{
    int mx = 0, ans = 0, pos = 0;
    int len = init(str);
    for (int i = 1; i <= len; i++)
    {
        if (mx > i) Len[i] = min(mx - i, Len[2 * pos - i]);
        else Len[i] = 1;
        while (tmp[i - Len[i]] == tmp[i + Len[i]]) Len[i]++;
        if (Len[i] + i > mx) mx = Len[i] + i, pos = i;
    }
}\end{lstlisting}
\subsection{Aho-Corasick Automation}
\subsubsection{AC Automation}
\begin{lstlisting}
class AC_automation
{
public:
    int trie[maxn][26], cnt;
    int tag[maxn];
    int fail[maxn], num[maxn], res[maxn], in[maxn], Map[maxn];

    void init()
    {
        memset(trie, 0, sizeof trie);
        memset(tag, 0, sizeof tag);
        memset(fail, 0, sizeof fail);
        cnt = 0;
    }

    void insert(char *str, int id)
    {
        int root = 0;
        for (int i = 0; str[i]; i++)
        {
            int id = str[i] - 'a';
            if (!trie[root][id]) trie[root][id] = ++cnt;
            root = trie[root][id];
        }
        if(!tag[root]) tag[root] = id;
        Map[id] = tag[root];
    }

    void build()
    {
        queue<int> que;
        for (int i = 0; i < 26; i++) if (trie[0][i]) que.push(trie[0][i]);
        while (!que.empty())
        {
            int k = que.front();
            que.pop();
            for (int i = 0; i < 26; i++)
            {
                if (trie[k][i])
                {
                    fail[trie[k][i]] = trie[fail[k]][i];
                    que.push(trie[k][i]);
                    in[fail[trie[k][i]]] ++;
                } else trie[k][i] = trie[fail[k]][i];
            }
        }
    }

    void toposort()
    {
        queue<int> que;
        for(int i = 1; i <= cnt; i ++) if(in[i] == 0) que.push(i);
        while(!que.empty())
        {
            int u = que.front(); que.pop();
            res[tag[u]] = num[u];
            int v = fail[u]; in[v] --;
            num[v] += num[u];
            if(in[v] == 0) que.push(v);
        }
    }

    void query(char *str, int n)
    {
        int u = 0, len = strlen(s);
        for(int i = 0; i < len; i ++)
            u = trie[u][str[i] - 'a'], num[u] ++;
        toposort();
        for(int i = 1; i <= n; i ++) printf("%d\n", res[Map[i]]);
    }
} AC;\end{lstlisting}
\subsection{Suffix Array}
\subsubsection{Suffix Array}
\begin{lstlisting}
char s[maxn];
int sa[maxn], t[maxn], t2[maxn], c[maxn], n;

//build_sa(n + 1, 130), sa, height下标从1开始,rk下标从0开始
void build_sa(int n, int m) 
{
    int *x = t, *y = t2;
    for(int i = 0; i < m; i++) c[i] = 0;
    for(int i = 0; i < n; i++) c[x[i] = s[i]]++;
    for(int i = 1; i < m; i++) c[i] += c[i - 1];
    for(int i = n - 1; i >= 0; i--) sa[--c[x[i]]] = i;
    for(int k = 1; k <= n; k <<= 1)
    {
        int p = 0;
        for(int i = n - k; i < n; i++) y[p++] = i;
        for(int i = 0; i < n; i++) if(sa[i] >= k) y[p++] = sa[i] - k;
        for(int i = 0; i < m; i++) c[i] = 0;
        for(int i = 0; i < n; i++) c[x[y[i]]]++;
        for(int i = 0; i < m; i++) c[i] += c[i - 1];
        for(int i = n - 1; i >= 0; i--) sa[--c[x[y[i]]]] = y[i];
        swap(x, y);
        p = 1; x[sa[0]] = 0;
        for(int i = 1; i < n; i++)
            x[sa[i]] = y[sa[i - 1]] == y[sa[i]] && y[sa[i - 1] + k] == y[sa[i] + k] ? p - 1 : p++;
        if(p >= n) break;
        m = p;
    }
}

int rk[maxn], height[maxn];

void getHeight()
{
    for(int i = 1; i <= n; i++) rk[sa[i]] = i;
    for(int i = 0, k = 0; i < n; i++)
    {
        if(k) k--;
        int j = sa[rk[i] - 1];
        while(s[i + k] == s[j + k]) k++;
        height[rk[i]] = k;
    }
}

int dp[maxn][20];

void RMQ()
{
    for(int i = 1; i <= n; i ++) dp[i][0] = height[i];
    for(int j = 1; (1 << j) < maxn; j ++)
        for(int i = 1; i + (1 << j) - 1 <= n; i ++)
            dp[i][j] = min(dp[i][j - 1], dp[i + (1 << (j - 1))][j - 1]);
}

int query(int l, int r)
{
    int k = 0;
    while((1 << (k + 1)) <= r - l + 1) k ++;
    return min(dp[l][k], dp[r - (1 << k) + 1][k]);
}

int lcp(int x, int y)
{
    x = rk[x], y = rk[y];
    if(x > y) swap(x, y);
    return query(x + 1, y);
}                                                                  \end{lstlisting}
\subsubsection{SA badcw}
\begin{lstlisting}
namespace SA {
    const int maxn = 2e5 + 10;
    int t1[maxn], t2[maxn], c[maxn];
    int Rank[maxn], height[maxn];
    int RMQ[maxn];
    int mm[maxn];
    int sa[maxn];
    int best[25][maxn];
    bool cmp(int *r, int a, int b, int l) {
        return r[a] == r[b] && r[a + l] == r[b + l];
    }
    void da(char str[], int sa[], int Rank[], int height[], int n, int m) {
        n++;
        int i, j, p, *x = t1, *y = t2;
        for (i = 0; i < m; i++)c[i] = 0;
        for (i = 0; i < n; i++)c[x[i] = str[i]]++;
        for (i = 1; i < m; i++)c[i] += c[i - 1];
        for (i = n - 1; i >= 0; i--)sa[--c[x[i]]] = i;
        for (j = 1; j <= n; j <<= 1) {
            p = 0;
            for (i = n - j; i < n; i++)y[p++] = i;
            for (i = 0; i < n; i++)if (sa[i] >= j)y[p++] = sa[i] - j;
            for (i = 0; i < m; i++)c[i] = 0;
            for (i = 0; i < n; i++)c[x[y[i]]]++;
            for (i = 1; i < m; i++)c[i] += c[i - 1];
            for (i = n - 1; i >= 0; i--)sa[--c[x[y[i]]]] = y[i];
            swap(x, y);
            p = 1;
            x[sa[0]] = 0;
            for (i = 1; i < n; i++)
                x[sa[i]] = cmp(y, sa[i - 1], sa[i], j) ? p - 1 : p++;
            if (p >= n)break;
            m = p;
        }
        int k = 0;
        n--;
        for (i = 0; i <= n; i++)Rank[sa[i]] = i;
        for (i = 0; i < n; i++) {
            if (k)k--;
            j = sa[Rank[i] - 1];
            while (str[i + k] == str[j + k])k++;
            height[Rank[i]] = k;
        }
    }
    void initRMQ(int n) {
        for (int i = 1; i <= n; i++)
            RMQ[i] = height[i];
        mm[0] = -1;
        for (int i = 1; i <= n; i++)
            mm[i] = ((i & (i - 1)) == 0) ? mm[i - 1] + 1 : mm[i - 1];
        for (int i = 1; i <= n; i++)best[0][i] = i;
        for (int i = 1; i <= mm[n]; i++)
            for (int j = 1; j + (1 << i) - 1 <= n; j++) {
                int a = best[i - 1][j];
                int b = best[i - 1][j + (1 << (i - 1))];
                if (RMQ[a] < RMQ[b])best[i][j] = a;
                else best[i][j] = b;
            }
    }
    int askRMQ(int a, int b) {
        int t;
        t = mm[b - a + 1];
        b -= (1 << t) - 1;
        a = best[t][a];
        b = best[t][b];
        return RMQ[a] < RMQ[b] ? a : b;
    }
    int lcp(int a, int b) {
        a = Rank[a];
        b = Rank[b];
        if (a > b) swap(a, b);
        //cout << askRMQ(a + 1, b) << endl;
        return height[askRMQ(a + 1, b)];
    }
    void preprocess(char *str, int n, int m) {
        da(str, sa, Rank, height, n, m);
        initRMQ(n);
    }
}
\end{lstlisting}
\subsection{PalindromicTree}
\subsubsection{PalindromicTree}
\begin{lstlisting}
const int maxn = 2e6+6;
const int N = 26;
const int mod = 51123987;

struct Palindromic_Tree {
//    vector<pair<int, int> > next[maxn];
    int next[maxn][N];//next指针，next指针和字典树类似，指向的串为当前串两端加上同一个字符构成
    int fail[maxn]{};//fail指针，失配后跳转到fail指针指向的节点
    int cnt[maxn]{}; //表示节点i表示的本质不同的串的个数（建树时求出的不是完全的，最后count()函数跑一遍以后才是正确的）
    int num[maxn]{}; //表示以节点i表示的最长回文串的最右端点为回文串结尾的回文串个数
    int len[maxn]{};//len[i]表示节点i表示的回文串的长度（一个节点表示一个回文串）
    int S[maxn]{};//存放添加的字符
    int last{};//指向新添加一个字母后所形成的最长回文串表示的节点。
    int n{};//表示添加的字符个数。
    int p{};//表示添加的节点个数。
    //0向前加，1向后加字符
    //int last[2];
    //int lpos, rpos;

    int newnode(int l) {//新建节点
//        next[p].clear();
        for (int i = 0; i < N; ++i) next[p][i] = 0;
        cnt[p] = 0;
        num[p] = 0;
        len[p] = l;
        return p++;
    }

    void init() {//初始化
        n = last = p = 0;
        newnode(0);
        newnode(-1);
        S[n] = -1;//开头放一个字符集中没有的字符，减少特判
        fail[0] = 1;
        // lpos 为字符串最大长度
        // last[0] = last[1] = 0;
        // lpos = 100000, rpos = lpos - 1;
        // S[lpos - 1] = S[rpos + 1] = -1;
    }

    int get_fail(int x) {//和KMP一样，失配后找一个尽量最长的
        // op 0 向前， 1 向后
        // if (op == 0) while (S[lpos + len[x] + 1] != S[lpos]) x = fail[x];
        // else while(S[rpos - len[x] - 1] != S[rpos]) x = fail[x];
        while (S[n - len[x] - 1] != S[n]) x = fail[x];
        return x;
    }

//    int find(int u, int c) {
//        vector<pair<int, int> > & x = next[u];
//        int sz = x.size();
//        for(int i = 0; i < sz; ++i) {
//            if(x[i].first == c) return x[i].second;
//        }
//        return 0;
//    }

    int add(int c) {
        // 注意清空左右字符
        // if (op == 0) S[--lpos] = c, S[lpos - 1] = -1;
        // else S[++rpos] = c, S[rpos + 1] = -1;
        S[++n] = c;
        int cur = get_fail(last);//通过上一个回文串找这个回文串的匹配位置
//        int x = find(cur, c);
//        if (!x) {
        if (!next[cur][c]) {//如果这个回文串没有出现过，说明出现了一个新的本质不同的回文串
            int now = newnode(len[cur] + 2);//新建节点
//            x = now;
//            fail[now] = find(get_fail(fail[cur]), c);
//            next[cur].emplace_back(make_pair(c, now));
            fail[now] = next[get_fail(fail[cur])][c];//和AC自动机一样建立fail指针，以便失配后跳转
            next[cur][c] = now;
            num[now] = num[fail[now]] + 1;
        }
//        last = x;
        // 修改最终长度
        // if (len[last[op]] == rpos - lpos + 1) last[op ^ 1] = last[op];
        last = next[cur][c];
        cnt[last]++;
        return num[last];
    }

    void count() {
        for (int i = p - 1; i >= 0; --i) cnt[fail[i]] += cnt[i];
        //父亲累加儿子的cnt，因为如果fail[v]=u，则u一定是v的子回文串！
    }
} solve;

char s[maxn];

// 求相交回文串数量
ll a[maxn], b[maxn];
int main() {
    solve.init();
    int n;
    scanf("%d", &n);
    scanf("%s", s);
    for (int i = 0; i < n; ++i) a[i] = solve.add(s[i] - 'a');
    solve.init();
    for (int i = n - 1; i >= 0; --i) b[i] = (b[i + 1] + solve.add(s[i] - 'a')) % mod;
    ll res = (b[0] * (b[0] - 1) / 2) % mod;
    for (int i = 0; i < n; ++i) res = ((res - (a[i] * b[i + 1]) + mod) % mod) % mod;
    printf("%lld\n", res);
    return 0;
}
\end{lstlisting}
\subsection{Hash}
\subsubsection{hash}
\begin{lstlisting}
// hash常用素数
// 61, 83, 113, 151, 211
// 91815541, 38734667, 68861641
// 917120411, 687840301, 386910137, 515880193
// 1222827239, 1610612741

typedef unsigned long long ull;
struct mhash {
    // 自然溢出无模数 805306457
    ull base[maxn];
    ull hash_index[maxn];
    ull seed; //31, 131
    void inithash(ull seedt = 31) {
        base[0] = 1;
        seed = seedt;
        for (int i = 1; i < maxn; ++i) base[i] = base[i - 1] * seed;
    }
    void H(char *p, int n) { // from 1 to n
        hash_index[0] = 0;
        for (int i = 1; i <= n; ++i) hash_index[i] = hash_index[i - 1] * seed + p[i] - 'a';
    }
    ull gethash(int s, int e) {
        return hash_index[e] - hash_index[s - 1] * base[e - s + 1];
    }
};

// 26个素数，解决加法hash
int prime[] = {34183,13513,152993,13591,19687,350869,111187,766091,769297,
               633469,752273,298651,617191,880421,136067,
               1408397,726899,458921,2133701,2599847,2730947,4696343,10267237,
               18941059,34078909,69208409};\end{lstlisting}
\subsubsection{doubleHash}
\begin{lstlisting}
namespace Hash{

    template<class __A,class __B>
    class Hash{
    private:
        static const int size=2000000;
        __B *hash; __A *O; int sz;
    public:
        Hash(int hash_size=size){ sz=hash_size;
            hash=(__B *)malloc(sizeof(__B)*sz);
            O=(__A *)malloc(sizeof(__A)*sz);
            memset(O,0xff,sizeof(__A)*sz);
        }~Hash(){free(O);free(hash);}
        __B &operator [](const __A &_O){
            int loc=_O%sz;
            while(~O[loc]&&O[loc]!=_O){
                ++loc;
                if(loc>sz)loc=0;
            }if(!~O[loc])O[loc]=_O;
            return hash[loc];
        }
        void clear(){memset(O,0xff,sizeof(__A)*sz);}
    };

    struct StringDoubleHashResult{
        int32_t *H1,*H2,c_len,len;
        StringDoubleHashResult(int32_t sz=0){
            len=sz; c_len=0; //cur_len;
            if(len<=0){
                H1=H2=0;
                return;
            }
            H1=(int32_t *)malloc(sizeof(int32_t)*sz);
            H2=(int32_t *)malloc(sizeof(int32_t)*sz);
        }
        ~StringDoubleHashResult(){}
        void clear(){free(H1);free(H2);len=0;H1=H2=0;}
        void resize(int new_len){
            int32_t *T1=(int32_t *)malloc(sizeof(int32_t)*new_len);
            int32_t *T2=(int32_t *)malloc(sizeof(int32_t)*new_len);
            for(int i=0;i<c_len;++i)T1[i]=H1[i],T2[i]=H2[i];
            free(H1);free(H2); H1=T1; H2=T2; len=new_len;
        }
        void erase(int ers_len){//erase suffix
            c_len-=ers_len;
            if(c_len<0)c_len=0;
        }
        //erase prefix not better than reculc
    };

    namespace hash_random{
        const int mod_tot=5;
        const int mod[]={1000000009,1000000007,998244353,917120411,515880193};
    };

    class StringDoubleHash{
    private:
        static const int enable_random=1;
        int32_t sz,HA1,HA2;
        long long B,C;
        int32_t *H1,*H2;
    public:
        StringDoubleHash(int32_t SZ=2e6+5,int32_t ha1=-1,int32_t ha2=-1,int32_t b=-1,int32_t c=-1){
            sz=SZ;
            if(enable_random){
                std::mt19937 rnd(time(0)+19990630);
                int z1= rnd() % hash_random::mod_tot;
                int z2= (z1 +rnd()%(hash_random::mod_tot - 1) + 1) % hash_random::mod_tot;
                if(ha1<0)ha1=hash_random::mod[z1];
                if(ha2<0)ha2=hash_random::mod[z2];
                if(b<0)b=rnd()%114514+23333;
                if(c<0)c=rnd()%1919810+23333;
            } else {
                if(ha1<0)ha1=1e9+7;
                if(ha2<0)ha2=1e9+9;
                if(b<0)b=114514;
                if(c<0)c=1919810;
            }
            HA1=ha1; HA2=ha2; B=b; C=c;
            //cerr<<HA1<<" "<<HA2<<" "<<B<<" "<<C<<endl;
            H1=(int32_t *)malloc(sizeof(int32_t)*sz);
            H2=(int32_t *)malloc(sizeof(int32_t)*sz);
            init_hash_val();
        }
        ~StringDoubleHash(){free(H1);free(H2);}
        void init_hash_val(){
            H1[0]=H2[0]=1;
            for(int32_t i=1;i<sz;++i){
                H1[i]=(H1[i-1]*B)%HA1;
                H2[i]=(H2[i-1]*B)%HA2;
            }
        }
        template <class _Tp>
        StringDoubleHashResult culc_hash(const _Tp &s,int32_t len,int32_t tot_len=-1){
            if(tot_len<0)tot_len=len;
            StringDoubleHashResult R(tot_len);
            if(len<=0)return R;
            R.H1[0]=(s[0]+C)%HA1;
            R.H2[0]=(s[0]+C)%HA2;
            for(int32_t i=1;i<len;++i){
                R.H1[i]=(R.H1[i-1]*B+s[i]+C)%HA1;
                R.H2[i]=(R.H2[i-1]*B+s[i]+C)%HA2;
            }
            R.c_len=len;
            return R;
        }
        // s is the char* first, len is the append length
        template <class _Tp>
        void append(StringDoubleHashResult &R,const _Tp &s,int32_t len){
            if(len<=0)return;
            int t_len=R.len;
            while(R.c_len+len>t_len)t_len<<=1;
            if(t_len>R.len)R.resize(t_len);
            for(int32_t i=R.c_len;i<R.c_len+len;++i){
                if(i==0){
                    R.H1[i]=(s[i-R.c_len]+C)%HA1;
                    R.H2[i]=(s[i-R.c_len]+C)%HA2;
                } else {
                    R.H1[i]=(R.H1[i-1]*B+s[i-R.c_len]+C)%HA1;
                    R.H2[i]=(R.H2[i-1]*B+s[i-R.c_len]+C)%HA2;
                }
            }
            R.c_len+=len;
        }
        void append(StringDoubleHashResult &R, char s){
            int t_len=R.len;
            while(R.c_len+1>t_len)t_len<<=1;
            if(t_len>R.len)R.resize(t_len);
            for(int32_t i=R.c_len;i<R.c_len+1;++i){
                if(i==0){
                    R.H1[i]=(s+C)%HA1;
                    R.H2[i]=(s+C)%HA2;
                } else {
                    R.H1[i]=(R.H1[i-1]*B+s+C)%HA1;
                    R.H2[i]=(R.H2[i-1]*B+s+C)%HA2;
                }
            }
            R.c_len+=1;
        }
        //return hash [l,r)
        ll gethash(const StringDoubleHashResult &R, int32_t l,int32_t r){
            if(l>r||l<0||r-->R.c_len)return -1;//fail
            ll v1=l>0?R.H1[l-1]*(long long)H1[r-l+1]%HA1:0;
            ll v2=l>0?R.H2[l-1]*(long long)H2[r-l+1]%HA2:0;
            v1=R.H1[r]-v1; v2=R.H2[r]-v2;
            if(v1<0)v1+=HA1; if(v2<0)v2+=HA2;
            return v1<<32|v2;
        }
        //merge two hashes as one(s1+s2), but need s2's length
        ll merge_hash(const long long &hs1,const long long &hs2,int lenr){
            int32_t m1=hs1>>32,m2=hs1&0xffffffffLL;
            int32_t m3=hs2>>32,m4=hs2&0xffffffffLL;
            m1=m1*(long long)H1[lenr]%HA1+m3;
            if(m1>=HA1)m1-=HA1;
            m2=m2*(long long)H2[lenr]%HA2+m4;
            if(m2>=HA2)m2-=HA2;
            return (long long)m1<<32|m2;
        }
    };
};\end{lstlisting}
\subsubsection{二维hash}
\begin{lstlisting}
#define ull unsigned long long
const int maxn = 1005;
ull hs[maxn][maxn];
char a[maxn][maxn];
int n, m;
ull base1 = 131, base2 = 13331;
ull pwb1[maxn] = {1}, pwb2[maxn] = {1};

void init() {
    for (int i = 1; i < maxn; ++i) {
        pwb1[i] = pwb1[i - 1] * base1;
        pwb2[i] = pwb2[i - 1] * base2;
    }
}

void Hash() {
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            hs[i][j]=hs[i][j-1]*base1+a[i][j] - 'a';
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            hs[i][j]+=hs[i-1][j]*base2;
}

// 右下角(i,j)，行列长度n,m
ull getHs(int i, int j, int lenn, int lenm) {
    return hs[i][j] - hs[i - lenn][j] * pwb2[lenn] - 
            hs[i][j - lenm] * pwb1[lenm] +
            hs[i - lenn][j - lenm] * pwb2[lenn] * pwb1[lenm];
}\end{lstlisting}
\subsubsection{树hash同构}
\begin{lstlisting}
// n=1e5的话base开2e6+9，可以输出看到top不比n小即可
const int base = 2e6+9;
// vis大小要开到素数大小， turn表示当前树的编号，p是预处理数组
int vis[base + 1], top, turn, p[base + 1];
// 程序开头调用一次
void init() {
    top = 0;
    for (int i = 2; i <= base; ++i) {
        if (!vis[i]) {
            p[++top] = i;
        }
        for (int j = 1; j <= top && i * p[j] <= base; ++j) {
            vis[i * p[j]] = 1;
            if (i % p[j] == 0) break;
        }
    }
    assert(top >= maxn);
}

vector<int> edge[maxn];
// h[x]表示x这棵子树的hash值， g[x]表示以x为根的hash值
int h[maxn], g[maxn], sz[maxn];

struct TreeHash {
    int n;
    // 如果树比较多，在类内部开edge可能会炸内存，可以改到外面做前向星
    // 除了hs是答案其他都可以改到外部，只有edge需要清零
    // vector<int> edge[maxn];
    // int h[maxn], g[maxn], sz[maxn];
    vector<int> hs;

    void init(int n_ = 0) {
        n = n_;
        hs.clear();
    }

    void dfs1(int u, int pre) {
        sz[u] = 1;
        h[u] = 1;
        for (auto v : edge[u]) {
            if (v == pre) continue;
            dfs1(v, u);
            h[u] = (h[u] + 1ll * h[v] * p[sz[v]] % mod) % mod;
            sz[u] += sz[v];
        }
    }

    void dfs2(int u, int pre, int V, int needres = 1) {
        g[u] = (h[u] + 1ll * V * p[n - sz[u]] % mod) % mod;
        if (needres) hs.push_back(g[u]);
        for (auto v : edge[u]) {
            if (v == pre) continue;
            dfs2(v, u, (g[u] - 1ll * h[v] * p[sz[v]] % mod + mod) % mod);
        }
    }

    void work(int needres = 1) {
        // 无根树选一个不存在的点当pre即可，当多棵无根树判重时需要sort
        dfs1(1, 0);
        dfs2(1, 0, 0, needres);
        sort(hs.begin(), hs.end());
    }
};

// 获取删掉某叶子节点后以与该叶子节点相邻点开头的hash值
// int res = (hs[edge[i][0]] - 2 + mod) % mod;\end{lstlisting}
\subsection{Suffix Automation}
\subsubsection{SAM}
\begin{lstlisting}
const int maxn = 2e4 + 10;

struct SuffixAutomation
{
	int last, cnt;
	int ch[maxn << 1][26], fa[maxn << 1], len[maxn << 1], pos[maxn << 1];
    int sz[maxn << 1], a[maxn << 1], c[maxn << 1];

	void init()
	{
	    last = cnt = 1;
	    memset(ch[1], 0, sizeof ch[1]);
	    fa[1] = len[1] = 0;
        a[1] = c[1] = 0;
    }

    int inline newnode(int idx)
    {
        ++cnt;
        memset(ch[cnt], 0, sizeof ch[cnt]);
        fa[cnt] = len[cnt] = sz[cnt] = a[cnt] = c[cnt] = 0;
        pos[cnt] = idx;
        return cnt;
    }

	void ins(int c)
	{
		int p = last , np = newnode(pos[last] + 1);
		last = np, len[np] = len[p] + 1;
		for(; p && !ch[p][c]; p = fa[p]) ch[p][c] = np;
		if(!p) fa[np] = 1;
		else
		{
			int q = ch[p][c];
			if(len[p] + 1 == len[q]) fa[np] = q;
			else
			{
				int nq = newnode(pos[p] + 1);
				len[nq] = len[p] + 1;
				memcpy(ch[nq], ch[q], sizeof ch[q]);
				fa[nq] = fa[q], fa[q] = fa[np] = nq;
				for(; ch[p][c] == q; p = fa[p]) ch[p][c] = nq;
			}
		}
        sz[np] = 1;
	}

	int solve(int n)
	{
        /*求两个串的LCS:
            对一个字符串建立SAM，记录一个当前匹配的长度Len和当前节点v，枚举另一个字符串的每个字符；
            如果p有字符v的转移边出边，则使Len加一，并使p转移到出边指向的节点上;
            否则不断向父节点上跳，直到当前节点有字符p的转移出边，或者跳到根节点；
        */
        int p = 1, ans = 0, now_len = 0;
        for(int i = 0; s2[i]; i ++)
        {
            if(ch[p][s2[i] - 'a']) p = ch[p][s2[i] - 'a'], now_len ++;
            else
            {
                for(;p && !ch[p][s2[i] -'a'] ; p = fa[p]) ;
                if(p == 0) now_len = 0, p = 1;
                else now_len = len[p] + 1, p = ch[p][s2[i] - 'a'];
            }
            ans = max(now_len, ans);
        }
    }

    void Toposort()
    {
        long long ans = 0;
        for(int i = 1; i <= cnt; i ++) c[len[i]] ++;
        for(int i = 1; i <= cnt; i ++) c[i] += c[i - 1];
        for(int i = 1; i <= cnt; i ++) a[c[len[i]] --] = i;
        for(int i = cnt; i; i --) sz[fa[a[i]]] += sz[a[i]];
    }
}sam;
\end{lstlisting}
\subsection{Others}
\subsubsection{最小表示法}
\begin{lstlisting}
// 0起始
int Gao(char a[], int len) {
    int i = 0, j = 1, k = 0;
    while (i < len && j < len && k < len) {
        int cmp = a[(j + k) % len] - a[(i + k) % len];
        if (cmp == 0) k++;
        else {
            if (cmp > 0) j += k + 1;
            else i += k + 1;
            if (i == j) j ++;
            k = 0;
        }
    }
    return min(i, j);
}\end{lstlisting}
\subsubsection{Lyndon}
\begin{lstlisting}
void duval(char s[])
{
	int n = strlen(s), i = 0;
	vector<int> res; //Lyndon串的开头
	while(i < n)
	{
		int j = i, k = i + 1;
		while(j < n && s[j] <= s[k])
		{
			if(s[j] < s[k]) j = i;
			else j ++;
			k ++;
		}
		while(i <= j) 
		{
			res.push_back(i);
			i += k - j;
		}
	}
}\end{lstlisting}
\clearpage\section{dp}
\subsection{BitDP}
\subsubsection{数位dp计和}
\begin{lstlisting}
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int mod = 998244353;
pair<ll, ll> dp[20][1<<10];
bool vis[20][1<<10];
int k;
int t[20];
ll base[20];

pair<ll, ll> dfs(int pos, int state, bool limit, bool lead) {
    if (pos == -1) return __builtin_popcount(state) <= k ? make_pair(1, 0) : make_pair(0, 0);
    if (!limit && !lead && vis[pos][state]) return dp[pos][state];
    int up = limit ? t[pos] : 9;
    pair<ll, ll> res = {0, 0};
    for (int i = 0; i <= up; ++i) {
        int n_s = state;
        if (lead && i == 0) n_s = 0;
        else n_s = state | (1 << i);
        auto tmp = dfs(pos - 1, n_s, limit && i == t[pos], lead && i == 0);
        ll pre = 1ll * i * base[pos] % mod;
        (res.first += tmp.first) %= mod;
        (res.second += tmp.second + pre * tmp.first) %= mod;
    }
    if (!limit && !lead) dp[pos][state] = res, vis[pos][state] = 1;
    return res;
}

ll solve(ll x) {
    int pos = 0;
    do {
        t[pos ++] = x % 10;
    } while (x /= 10);
    return dfs(pos - 1, 0, true, true).second;
}

int main(int argc,char *argv[])
{
    base[0] = 1;
    for (int i = 1; i < 20; ++i) base[i] = base[i - 1] * 10;
    ll l, r;
    scanf("%lld%lld%d", &l, &r, &k);
    printf("%lld\n", (solve(r) - solve(l - 1) + mod) % mod);
    return 0;
}
\end{lstlisting}
\subsubsection{两个数数位dp}
\begin{lstlisting}
// 二进制数位dp，求a $\in$ 1～x 和 b $\in$ 1~y，满足 $a & b > c || a ^ b < c$的对数
ll dp[maxn][2][2][2][2];
int a[maxn], b[maxn], c[maxn];


void cal(int *xt, ll x) {
    int has = 0;
    while (x) {
        xt[has++] = x % 2;
        x /= 2;
    }
}

ll dfs(int pos, int o1, int o2, int lim1, int lim2) {
    if (pos < 0) return 1;
    ll &t = dp[pos][o1][o2][lim1][lim2];
    if (t != -1) return t;
    int up1 = o1 ? a[pos] : 1;
    int up2 = o2 ? b[pos] : 1;
    ll res = 0;
    for (int i = 0; i <= up1; ++i) {
        for (int j = 0; j <= up2; ++j) {
            int t1 = i & j;
            int t2 = i ^ j;
            if (lim1 && t1 > c[pos]) continue;
            if (lim2 && t2 < c[pos]) continue;
            res += dfs(pos - 1, o1 && i == up1, o2 && j == up2, lim1 && t1 == c[pos], lim2 && t2 == c[pos]);
        }
    }
    return t = res;
}

ll solve(ll x, ll y, ll z) {
    memset(dp, -1ll, sizeof dp);
    for (int i = 0; i < 33; ++i) a[i] = b[i] = c[i] = 0;
    cal(a, x);
    cal(b, y);
    cal(c, z);
    return dfs(32, 1, 1, 1, 1);
}

int main(int argc, char *argv[]) {
    int T;
    scanf("%d", &T);
    ll x, y, z;
    for (int kase = 1; kase <= T; ++kase) {
        scanf("%lld%lld%lld", &x, &y, &z);
        ll res = solve(x, y, z);
        res -= max(0ll, y - z + 1);
        res -= max(0ll, x - z + 1);
        printf("%lld\n", x * y - res);
    }
    return 0;
}\end{lstlisting}
\subsection{Subsequence}
\subsubsection{MaxSum}
\begin{lstlisting}
// 传入序列a和长度n，返回最大子序列和
int MaxSeqSum(int a[], int n)
{
    int rt = 0, cur = 0;
    for (int i = 0; i < n; i++)
        cur += a[i], rt = max(cur, rt), cur = max(0, cur);
    return rt;
}\end{lstlisting}
\subsubsection{LIS}
\begin{lstlisting}
// 简单写法(下标从0开始,只返回长度)
int dp[N];
int LIS(int a[], int n)
{
    memset(dp, 0x3f, sizeof(dp));
    for (int i = 0; i < n; i++) *lower_bound(dp, dp + n, a[i]) = a[i];
    return lower_bound(dp, dp + n, INF) - dp;
}

// 小常数nlogn求序列用树状数组维护dp即可
// dp[i] = max(dp[j]) + 1 (j < i && a[j] < a[i])\end{lstlisting}
\subsubsection{LongestCommonIncrease}
\begin{lstlisting}
// 序列下标从1开始
int LCIS(int a[], int b[], int n, int m)
{
    memset(dp, 0, sizeof(dp));
    for (int i = 1; i <= n; i++)
    {
        int ma = 0;
        for (int j = 1; j <= m; j++)
        {
            dp[i][j] = dp[i - 1][j];
            if (a[i] > b[j]) ma = max(ma, dp[i - 1][j]);
            if (a[i] == b[j]) dp[i][j] = ma + 1;
        }
    }
    return *max_element(dp[n] + 1, dp[n] + 1 + m);
}\end{lstlisting}
\subsubsection{LCS}
\begin{lstlisting}
#include <stdio.h>
#include <string.h>

#define M 30005
#define SIZE 128
#define WORDMAX 3200
#define BIT 32

char s1[M], s2[M];
int nword;
unsigned int str[SIZE][WORDMAX];
unsigned int tmp1[WORDMAX], tmp2[WORDMAX];

void pre(int len)
{
    int i, j;
    memset(str, 0, sizeof(str));
    for(i = 0; i < len; i ++)
        str[s1[i]][i / BIT] |= 1 << (i % BIT);
}

void cal(unsigned int *a, unsigned int *b, char ch)
{
    int i, bottom = 1, top;
    unsigned int x, y;
    for(i = 0; i < nword; i ++)
    {
        y = a[i];
        x = y | str[ch][i];
        top = (y >> (BIT - 1)) & 1;
        y = (y << 1) | bottom;
        if(x < y) top = 1;
        b[i] = x & ((x - y) ^ x);
        bottom = top;
    }
}

int bitcnt(unsigned int *a)
{
    int i, j, res = 0, t;
    unsigned int b[5] = {0x55555555, 0x33333333, 0x0f0f0f0f, 0x00ff00ff, 0x0000ffff}, x;
    for(i = 0; i < nword; i ++)
    {
        x = a[i];
        t = 1;
        for(j = 0; j < 5; j ++, t <<= 1)
            x = (x & b[j]) + ((x >> t) & b[j]);
        res += x;
    }
    return res;
}

void process()
{
    int i, j, len1, len2;
    unsigned int *a, *b, *t;
    len1 = strlen(s1);
    len2 = strlen(s2);
    nword = (len1 + BIT - 1) / BIT;
    pre(len1);
    memset(tmp1, 0, sizeof(tmp1));
    a = &tmp1[0];
    b = &tmp2[0];
    for(i = 0; i < len2; i ++)
    {
        cal(a, b, s2[i]);
        t = a; a = b; b = t;
    }
    printf("%d\n", bitcnt(a));
}

int main()
{
    while(scanf("%s%s", s1, s2) != EOF)
        process();
    return 0;
}
\end{lstlisting}
\subsection{Others}
\paragraph{问题}
设 $f(i) = \min(y[k] - s[i] \times x[k]), k \in [1,i-1]$, 现在要求出所有$f(i), i \in [1,n]$

考虑两个决策$j$和$k$，如果$j$比$k$优，则

$$y[j] - s[i] \times x[j] < y[k] - s[i] \times x[k]$$

化简得:

$$\frac{y_j - y_k}{x_j - x_k} < s_i$$

不等式左边是个斜率，我们把它设为$\text{slope}(j,k)$

我们可以维护一个单调递增的队列，为什么呢？

因为如果$\text{slope}(q[i-1],q[i]) > \text{slope}(q[i],q[i+1])$，那么当前者成立时，后者必定成立。 即$q[i]$决策优于$q[i-1]$决策时，$q[i+1]$必然优于$q[i]$，因此$q[i]$就没有存在的必要了。 所以我们要维护递增的队列。

那么每次的决策点$i$，都要满足
$$\begin{cases}
    \text{slope}(q[i-1],q[i]) < s[i] \\
    \text{slope}(q[i],q[i+1]) \ge s[i]
\end{cases}$$

一般情况去二分这个$i$即可。

如果$s[i]$是单调不降的，那么对于决策$j$和$k$($j < k$)来说，如果决策$k$优于决策$j$，那么对于$i \in [k+1,n]$，都存在决策$k$优于决策$j$， 因此决策$j$就可以舍弃了。 这样的话我们可以用单调队列进行优化，可以少个$\log$。

\paragraph{单调队列滑动窗口最大值}
\begin{lstlisting}
// k为滑动窗口的大小，数列下标从1开始，d为序列长度+1
deque<int> q;
for (int i = 0, j = 0; i + k <= d; i++)
{
    while (j < i + k)
    {
        while (!q.empty() && a[q.back()] < a[j]) q.pop_back();
        q.push_back(j++);
    }
    while (q.front() < i) q.pop_front();
    // a[q.front()]为当前滑动窗口的最大值
}
\end{lstlisting}\subsubsection{矩阵快速幂}
\begin{lstlisting}
const int sz = 5;
struct Matrix {
    ll a[sz][sz];
    Matrix() { memset(a, 0, sizeof a); }
    void pr() {
        printf("*\n");
        for (int i = 0; i < sz; ++i) {
            for (int j = 0; j < sz; ++j) {
                printf("%lld ", a[i][j]);
            }
            printf("\n");
        }
    }
    void tr() {
        for (int i = 0; i < sz; ++i) {
            for (int j = i + 1; j < sz; ++j) {
                swap(a[i][j], a[j][i]);
            }
        }
    }
} res, t1;

void init() {
    ;
}

Matrix mul(Matrix a, Matrix b) {
    Matrix res;
    // assert(a.m == b.n)
    for (int i = 0; i < sz; i++) // a.n
        for (int j = 0; j < sz; j++) // b.m
            for (int k = 0; k < sz; k++) // a.m, b.n
                (res.a[i][j] += a.a[i][k] * b.a[k][j] % mod) %= mod;
    return res;
}

Matrix Pow(ll n) {
    init();
    //for(int i = 0; i < cur; i++) res.a[i][i] = 1;
    while (n > 0) {
        if (n & 1) res = mul(res, t1);
        t1 = mul(t1, t1);
        n >>= 1;
    }
    return res;
}\end{lstlisting}
\subsubsection{单调栈}
\begin{lstlisting}
// 求左边第一个比a[i]小的和右边最后一个不比a[i]小的位置
for (int i = 1; i <= n; i++) {
    while (top && a[sta[top - 1]] >= a[i]) top--;
    la[i] = (top == 0) ? 1 : sta[top - 1] + 1;
    sta[top++] = i;
}
top = 0;
for (int i = n; i >= 1; i--) {
    while (top && a[sta[top - 1]] >= a[i]) top--;
    ra[i] = (top == 0) ? n : sta[top - 1] - 1;
    sta[top++] = i;
}\end{lstlisting}
\subsubsection{单调队列}
\begin{lstlisting}
// 循环序列的最大子段和
int a[maxn];
int pre[maxn * 2];
int qu[maxn * 2];
int n, resl, resr, res, k;

int main(int argc, char* argv[]) {
    int T;
    scanf("%d", &T);
    for (int kase = 1; kase <= T; ++kase) {
        scanf("%d%d", &n, &k);
        for (int i = 1; i <= n; ++i) {
            scanf("%d", &a[i]);
            pre[i] = pre[i - 1] + a[i];
        }
        for (int i = n + 1; i <= 2 * n; ++i) {
            pre[i] = pre[i - 1] + a[i - n];
        }
        res = -0x3f3f3f3f;
        resl = resr = -1;
        int l = 1, r = 0;
        for (int i = 1; i <= 2 * n; ++i) {
            while (l <= r && pre[qu[r]] >= pre[i - 1]) r--;
            qu[++r] = i - 1;
            while (l <= r && qu[l] < i - k) l++;
            int tmp = pre[i] - pre[qu[l]];
            if (tmp > res) {
                res = tmp;
                resl = qu[l] + 1;
                resr = i;
            }
        }
        if (resl > n) resl -= n;
        if (resr > n) resr -= n;
        printf("%d %d %d\n", res, resl, resr);
    }
    return 0;
}\end{lstlisting}
\clearpage\section{Geometry}
\subsection{geo}
\begin{lstlisting}
#define mp make_pair
#define fi first
#define se second
#define pb push_back
typedef double db;
const db eps=1e-6;
const db pi=acos(-1);
int sign(db k){
    if (k>eps) return 1; else if (k<-eps) return -1; return 0;
}
int cmp(db k1,db k2){return sign(k1-k2);}
int inmid(db k1,db k2,db k3){return sign(k1-k3)*sign(k2-k3)<=0;}// k3 在 [k1,k2] 内 
struct point{
    db x,y;
    point operator + (const point &k1) const{return (point){k1.x+x,k1.y+y};}
    point operator - (const point &k1) const{return (point){x-k1.x,y-k1.y};}
    point operator * (db k1) const{return (point){x*k1,y*k1};}
    point operator / (db k1) const{return (point){x/k1,y/k1};}
    int operator == (const point &k1) const{return cmp(x,k1.x)==0&&cmp(y,k1.y)==0;}
    // 逆时针旋转 
    point turn(db k1){return (point){x*cos(k1)-y*sin(k1),x*sin(k1)+y*cos(k1)};}
    point turn90(){return (point){-y,x};}
    bool operator < (const point k1) const{
        int a=cmp(x,k1.x);
        if (a==-1) return 1; else if (a==1) return 0; else return cmp(y,k1.y)==-1;
    }
    db abs(){return sqrt(x*x+y*y);}
    db abs2(){return x*x+y*y;}
    db dis(point k1){return ((*this)-k1).abs();}
    point unit(){db w=abs(); return (point){x/w,y/w};}
    void scan(){double k1,k2; scanf("%lf%lf",&k1,&k2); x=k1; y=k2;}
    void print(){printf("%.11lf %.11lf\n",x,y);}
    db getw(){return atan2(y,x);} 
    point getdel(){if (sign(x)==-1||(sign(x)==0&&sign(y)==-1)) return (*this)*(-1); else return (*this);}
	int getP() const{return sign(y)==1||(sign(y)==0&&sign(x)==-1);}
};
int inmid(point k1,point k2,point k3){return inmid(k1.x,k2.x,k3.x)&&inmid(k1.y,k2.y,k3.y);}
db cross(point k1,point k2){return k1.x*k2.y-k1.y*k2.x;}
db dot(point k1,point k2){return k1.x*k2.x+k1.y*k2.y;}
db rad(point k1,point k2){return atan2(cross(k1,k2),dot(k1,k2));}
// -pi -> pi
int compareangle (point k1,point k2){
    return k1.getP()<k2.getP()||(k1.getP()==k2.getP()&&sign(cross(k1,k2))>0);
}
point proj(point k1,point k2,point q){ // q 到直线 k1,k2 的投影 
    point k=k2-k1; return k1+k*(dot(q-k1,k)/k.abs2());
}
point reflect(point k1,point k2,point q){return proj(k1,k2,q)*2-q;}
int clockwise(point k1,point k2,point k3){// k1 k2 k3 逆时针 1 顺时针 -1 否则 0  
    return sign(cross(k2-k1,k3-k1));
}
int checkLL(point k1,point k2,point k3,point k4){// 求直线 (L) 线段 (S)k1,k2 和 k3,k4 的交点 
    return cmp(cross(k3-k1,k4-k1),cross(k3-k2,k4-k2))!=0;
}
point getLL(point k1,point k2,point k3,point k4){
    db w1=cross(k1-k3,k4-k3),w2=cross(k4-k3,k2-k3); return (k1*w2+k2*w1)/(w1+w2);
}
int intersect(db l1,db r1,db l2,db r2){
    if (l1>r1) swap(l1,r1); if (l2>r2) swap(l2,r2); return cmp(r1,l2)!=-1&&cmp(r2,l1)!=-1;
}
int checkSS(point k1,point k2,point k3,point k4){
    return intersect(k1.x,k2.x,k3.x,k4.x)&&intersect(k1.y,k2.y,k3.y,k4.y)&&
    sign(cross(k3-k1,k4-k1))*sign(cross(k3-k2,k4-k2))<=0&&
    sign(cross(k1-k3,k2-k3))*sign(cross(k1-k4,k2-k4))<=0;
}
db disSP(point k1,point k2,point q){
    point k3=proj(k1,k2,q);
    if (inmid(k1,k2,k3)) return q.dis(k3); else return min(q.dis(k1),q.dis(k2));
}
db disSS(point k1,point k2,point k3,point k4){
    if (checkSS(k1,k2,k3,k4)) return 0;
    else return min(min(disSP(k1,k2,k3),disSP(k1,k2,k4)),min(disSP(k3,k4,k1),disSP(k3,k4,k2)));
}
int onS(point k1,point k2,point q){return inmid(k1,k2,q)&&sign(cross(k1-q,k2-k1))==0;}
struct circle{
    point o; db r;
    void scan(){o.scan(); scanf("%lf",&r);}
    int inside(point k){return cmp(r,o.dis(k));}
};
struct line{
    // p[0]->p[1]
    point p[2];
    line(point k1,point k2){p[0]=k1; p[1]=k2;}
    point& operator [] (int k){return p[k];}
    int include(point k){return sign(cross(p[1]-p[0],k-p[0]))>0;}
    point dir(){return p[1]-p[0];}
    line push(){ // 向外 ( 左手边 ) 平移 eps 
        const db eps = 1e-6;
        point delta=(p[1]-p[0]).turn90().unit()*eps;
        return {p[0]-delta,p[1]-delta};
    }
};
point getLL(line k1,line k2){return getLL(k1[0],k1[1],k2[0],k2[1]);}
int parallel(line k1,line k2){return sign(cross(k1.dir(),k2.dir()))==0;}
int sameDir(line k1,line k2){return parallel(k1,k2)&&sign(dot(k1.dir(),k2.dir()))==1;}
int operator < (line k1,line k2){
    if (sameDir(k1,k2)) return k2.include(k1[0]); 
    return compareangle(k1.dir(),k2.dir());
}
int checkpos(line k1,line k2,line k3){return k3.include(getLL(k1,k2));}
vector<point> halfPlaneIS(vector<line> &l) {// 求半平面交 , 半平面是逆时针方向 , 输出按照逆时针，点数小于等于2表示无法构成半平面交
    sort(l.begin(), l.end());
    deque<line> q;
    for (int i = 0; i < (int)l.size(); ++i) {
        if (i && sameDir(l[i], l[i - 1])) continue;
        while (q.size() > 1 && !checkpos(q[q.size() - 2], q[q.size() - 1], l[i])) q.pop_back();
        while (q.size() > 1 && !checkpos(q[1], q[0], l[i])) q.pop_front();
        q.push_back(l[i]);
    }
    while (q.size() > 2 && !checkpos(q[q.size() - 2], q[q.size() - 1], q[0])) q.pop_back();
    while (q.size() > 2 && !checkpos(q[1], q[0], q[q.size() - 1])) q.pop_front();
    vector<point> ret;
    for (int i = 0; i < (int)q.size(); ++i) ret.push_back(getLL(q[i], q[(i + 1) % q.size()]));
    return ret;
}
// vector<line> getHL(vector<line> &L){ // 求半平面交 , 半平面是逆时针方向 , 输出按照逆时针
//     sort(L.begin(),L.end()); deque<line> q;
//     for (int i=0;i<(int)L.size();i++){
//         if (i&&sameDir(L[i],L[i-1])) continue;
//         while (q.size()>1&&!checkpos(q[q.size()-2],q[q.size()-1],L[i])) q.pop_back();
//         while (q.size()>1&&!checkpos(q[1],q[0],L[i])) q.pop_front();
//         q.push_back(L[i]);
//     }
//     while (q.size()>2&&!checkpos(q[q.size()-2],q[q.size()-1],q[0])) q.pop_back();
//     while (q.size()>2&&!checkpos(q[1],q[0],q[q.size()-1])) q.pop_front();
//     vector<line>ans; for (int i=0;i<q.size();i++) ans.push_back(q[i]);
//     return ans;
// }
db closepoint(vector<point>&A,int l,int r){ // 最近点对 , 先要按照 x 坐标排序 
    if (r-l<=5){
        db ans=1e20;
        for (int i=l;i<=r;i++) for (int j=i+1;j<=r;j++) ans=min(ans,A[i].dis(A[j]));
        return ans;
    }
    int mid=l+r>>1; db ans=min(closepoint(A,l,mid),closepoint(A,mid+1,r));
    vector<point>B; for (int i=l;i<=r;i++) if (abs(A[i].x-A[mid].x)<=ans) B.push_back(A[i]);
    sort(B.begin(),B.end(),[](point k1,point k2){return k1.y<k2.y;});
    for (int i=0;i<B.size();i++) for (int j=i+1;j<B.size()&&B[j].y-B[i].y<ans;j++) ans=min(ans,B[i].dis(B[j]));
    return ans;
}
int checkposCC(circle k1,circle k2){// 返回两个圆的公切线数量
    if (cmp(k1.r,k2.r)==-1) swap(k1,k2);
    db dis=k1.o.dis(k2.o);  int w1=cmp(dis,k1.r+k2.r),w2=cmp(dis,k1.r-k2.r);
    if (w1>0) return 4; else if (w1==0) return 3; else if (w2>0) return 2; 
    else if (w2==0) return 1; else return 0;
}
vector<point> getCL(circle k1,point k2,point k3){ // 沿着 k2->k3 方向给出 , 相切给出两个 
    point k=proj(k2,k3,k1.o); db d=k1.r*k1.r-(k-k1.o).abs2();
    if (sign(d)==-1) return {};
    point del=(k3-k2).unit()*sqrt(max((db)0.0,d)); return {k-del,k+del};
}
vector<point> getCC(circle k1,circle k2){// 沿圆 k1 逆时针给出 , 相切给出两个 
    int pd=checkposCC(k1,k2); if (pd==0||pd==4) return {};
    db a=(k2.o-k1.o).abs2(),cosA=(k1.r*k1.r+a-k2.r*k2.r)/(2*k1.r*sqrt(max(a,(db)0.0)));
    db b=k1.r*cosA,c=sqrt(max((db)0.0,k1.r*k1.r-b*b));
    point k=(k2.o-k1.o).unit(),m=k1.o+k*b,del=k.turn90()*c;
    return {m-del,m+del};
} 
vector<point> TangentCP(circle k1,point k2){// 沿圆 k1 逆时针给出 
    db a=(k2-k1.o).abs(),b=k1.r*k1.r/a,c=sqrt(max((db)0.0,k1.r*k1.r-b*b));
    point k=(k2-k1.o).unit(),m=k1.o+k*b,del=k.turn90()*c;
    return {m-del,m+del};
} 
vector<line> TangentoutCC(circle k1,circle k2){
    int pd=checkposCC(k1,k2); if (pd==0) return {}; 
    if (pd==1){point k=getCC(k1,k2)[0]; return {(line){k,k}};}
    if (cmp(k1.r,k2.r)==0){
        point del=(k2.o-k1.o).unit().turn90().getdel();
        return {(line){k1.o-del*k1.r,k2.o-del*k2.r},(line){k1.o+del*k1.r,k2.o+del*k2.r}};
    } else {
        point p=(k2.o*k1.r-k1.o*k2.r)/(k1.r-k2.r);
        vector<point>A=TangentCP(k1,p),B=TangentCP(k2,p);
        vector<line>ans; for (int i=0;i<A.size();i++) ans.push_back((line){A[i],B[i]}); 
        return ans;
    }
}
vector<line> TangentinCC(circle k1,circle k2){
    int pd=checkposCC(k1,k2); if (pd<=2) return {};
    if (pd==3){point k=getCC(k1,k2)[0]; return {(line){k,k}};} 
    point p=(k2.o*k1.r+k1.o*k2.r)/(k1.r+k2.r);
    vector<point>A=TangentCP(k1,p),B=TangentCP(k2,p);
    vector<line>ans; for (int i=0;i<A.size();i++) ans.push_back((line){A[i],B[i]}); 
    return ans;
}
vector<line> TangentCC(circle k1,circle k2){
    int flag=0; if (k1.r<k2.r) swap(k1,k2),flag=1;
    vector<line>A=TangentoutCC(k1,k2),B=TangentinCC(k1,k2);
    for (line k:B) A.push_back(k); 
    if (flag) for (line &k:A) swap(k[0],k[1]);
    return A;
}
db getarea(circle k1,point k2,point k3){
    // 圆 k1 与三角形 k2 k3 k1.o 的有向面积交
    point k=k1.o; k1.o=k1.o-k; k2=k2-k; k3=k3-k;
    int pd1=k1.inside(k2),pd2=k1.inside(k3); 
    vector<point>A=getCL(k1,k2,k3);
    if (pd1>=0){
        if (pd2>=0) return cross(k2,k3)/2;
        return k1.r*k1.r*rad(A[1],k3)/2+cross(k2,A[1])/2;
    } else if (pd2>=0){ 
        return k1.r*k1.r*rad(k2,A[0])/2+cross(A[0],k3)/2;
    }else {
        int pd=cmp(k1.r,disSP(k2,k3,k1.o));
        if (pd<=0) return k1.r*k1.r*rad(k2,k3)/2;
        return cross(A[0],A[1])/2+k1.r*k1.r*(rad(k2,A[0])+rad(A[1],k3))/2;
    }
}
circle getcircle(point k1,point k2,point k3){
    db a1=k2.x-k1.x,b1=k2.y-k1.y,c1=(a1*a1+b1*b1)/2;
    db a2=k3.x-k1.x,b2=k3.y-k1.y,c2=(a2*a2+b2*b2)/2;
    db d=a1*b2-a2*b1;
    point o=(point){k1.x+(c1*b2-c2*b1)/d,k1.y+(a1*c2-a2*c1)/d};
    return (circle){o,k1.dis(o)};
}
circle getScircle(vector<point> A){
    random_shuffle(A.begin(),A.end());
    circle ans=(circle){A[0],0};
    for (int i=1;i<A.size();i++)
        if (ans.inside(A[i])==-1){
            ans=(circle){A[i],0};
            for (int j=0;j<i;j++)
                if (ans.inside(A[j])==-1){
                    ans.o=(A[i]+A[j])/2; ans.r=ans.o.dis(A[i]);
                    for (int k=0;k<j;k++)
                        if (ans.inside(A[k])==-1)
                            ans=getcircle(A[i],A[j],A[k]);
                }
        }
    return ans;
}
db area(vector<point> A){ // 多边形用 vector<point> 表示 , 逆时针 
    db ans=0;
    for (int i=0;i<A.size();i++) ans+=cross(A[i],A[(i+1)%A.size()]);
    return ans/2;
}
int checkconvex(vector<point>A){
    int n=A.size(); A.push_back(A[0]); A.push_back(A[1]);
    for (int i=0;i<n;i++) if (sign(cross(A[i+1]-A[i],A[i+2]-A[i]))==-1) return 0;
    return 1;
}
int contain(vector<point>A,point q){ // 2 内部 1 边界 0 外部
    int pd=0; A.push_back(A[0]);
    for (int i=1;i<A.size();i++){
        point u=A[i-1],v=A[i];
        if (onS(u,v,q)) return 1; if (cmp(u.y,v.y)>0) swap(u,v);
        if (cmp(u.y,q.y)>=0||cmp(v.y,q.y)<0) continue;
        if (sign(cross(u-v,q-v))<0) pd^=1;
    }
    return pd<<1;
}
vector<point> ConvexHull(vector<point>A,int flag=1){ // flag=0 不严格 flag=1 严格 
    int n=A.size(); vector<point>ans(n*2); 
    sort(A.begin(),A.end()); int now=-1;
    for (int i=0;i<A.size();i++){
        while (now>0&&sign(cross(ans[now]-ans[now-1],A[i]-ans[now-1]))<flag) now--;
        ans[++now]=A[i];
    } int pre=now;
    for (int i=n-2;i>=0;i--){
        while (now>pre&&sign(cross(ans[now]-ans[now-1],A[i]-ans[now-1]))<flag) now--;
        ans[++now]=A[i];
    } ans.resize(now); return ans;
}
db convexDiameter(vector<point>A){
    int now=0,n=A.size(); db ans=0;
    for (int i=0;i<A.size();i++){
        now=max(now,i);
        while (1){
            db k1=A[i].dis(A[now%n]),k2=A[i].dis(A[(now+1)%n]);
            ans=max(ans,max(k1,k2)); if (k2>k1) now++; else break;
        }
    }
    return ans;
}
vector<point> convexcut(vector<point>A,point k1,point k2){
    // 保留 k1,k2,p 逆时针的所有点
    int n=A.size(); A.push_back(A[0]); vector<point>ans;
    for (int i=0;i<n;i++){
        int w1=clockwise(k1,k2,A[i]),w2=clockwise(k1,k2,A[i+1]);
        if (w1>=0) ans.push_back(A[i]);
        if (w1*w2<0) ans.push_back(getLL(k1,k2,A[i],A[i+1]));
    }
    return ans;
}
int checkPoS(vector<point>A,point k1,point k2){
    // 多边形 A 和直线 ( 线段 )k1->k2 严格相交 , 注释部分为线段
    struct ins{
        point m,u,v;
        int operator < (const ins& k) const {return m<k.m;}
    }; vector<ins>B;
    //if (contain(A,k1)==2||contain(A,k2)==2) return 1;
    vector<point>poly=A; A.push_back(A[0]); 
    for (int i=1;i<A.size();i++) if (checkLL(A[i-1],A[i],k1,k2)){
        point m=getLL(A[i-1],A[i],k1,k2); 
        if (inmid(A[i-1],A[i],m)/*&&inmid(k1,k2,m)*/) B.push_back((ins){m,A[i-1],A[i]});
    }
    if (B.size()==0) return 0; sort(B.begin(),B.end()); 
    int now=1; while (now<B.size()&&B[now].m==B[0].m) now++; 
    if (now==B.size()) return 0;
    int flag=contain(poly,(B[0].m+B[now].m)/2);
    if (flag==2) return 1;
    point d=B[now].m-B[0].m;
    for (int i=now;i<B.size();i++){
        if (!(B[i].m==B[i-1].m)&&flag==2) return 1;
        int tag=sign(cross(B[i].v-B[i].u,B[i].m+d-B[i].u));
        if (B[i].m==B[i].u||B[i].m==B[i].v) flag+=tag; else flag+=tag*2;
    }
    //return 0;
    return flag==2;
}
int checkinp(point r,point l,point m){
	if (compareangle(l,r)){return compareangle(l,m)&&compareangle(m,r);}
	return compareangle(l,m)||compareangle(m,r);
}
int checkPosFast(vector<point>A,point k1,point k2){ // 快速检查线段是否和多边形严格相交
	if (contain(A,k1)==2||contain(A,k2)==2) return 1; if (k1==k2) return 0;
	A.push_back(A[0]); A.push_back(A[1]);
	for (int i=1;i+1<A.size();i++)
		if (checkLL(A[i-1],A[i],k1,k2)){
			point now=getLL(A[i-1],A[i],k1,k2);
			if (inmid(A[i-1],A[i],now)==0||inmid(k1,k2,now)==0) continue;
			if (now==A[i]){
				if (A[i]==k2) continue;
				point pre=A[i-1],ne=A[i+1];
				if (checkinp(pre-now,ne-now,k2-now)) return 1;
			} else if (now==k1){
				if (k1==A[i-1]||k1==A[i]) continue;
				if (checkinp(A[i-1]-k1,A[i]-k1,k2-k1)) return 1;
			} else if (now==k2||now==A[i-1]) continue;
			else return 1;
		}
	return 0;
}
// 拆分凸包成上下凸壳 凸包尽量都随机旋转一个角度来避免出现相同横坐标 
// 尽量特判只有一个点的情况 凸包逆时针
void getUDP(vector<point>A,vector<point>&U,vector<point>&D){
    db l=1e100,r=-1e100;
    for (int i=0;i<A.size();i++) l=min(l,A[i].x),r=max(r,A[i].x);
    int wherel,wherer;
    for (int i=0;i<A.size();i++) if (cmp(A[i].x,l)==0) wherel=i;
    for (int i=A.size();i;i--) if (cmp(A[i-1].x,r)==0) wherer=i-1;
    U.clear(); D.clear(); int now=wherel;
    while (1){D.push_back(A[now]); if (now==wherer) break; now++; if (now>=A.size()) now=0;}
    now=wherel;
    while (1){U.push_back(A[now]); if (now==wherer) break; now--; if (now<0) now=A.size()-1;}
}
// 需要保证凸包点数大于等于 3,2 内部 ,1 边界 ,0 外部
int containCoP(const vector<point>&U,const vector<point>&D,point k){
    db lx=U[0].x,rx=U[U.size()-1].x;
    if (k==U[0]||k==U[U.size()-1]) return 1;
    if (cmp(k.x,lx)==-1||cmp(k.x,rx)==1) return 0;
    int where1=lower_bound(U.begin(),U.end(),(point){k.x,-1e100})-U.begin();
    int where2=lower_bound(D.begin(),D.end(),(point){k.x,-1e100})-D.begin();
    int w1=clockwise(U[where1-1],U[where1],k),w2=clockwise(D[where2-1],D[where2],k);
    if (w1==1||w2==-1) return 0; else if (w1==0||w2==0) return 1; return 2;
}
// d 是方向 , 输出上方切点和下方切点
pair<point,point> getTangentCow(const vector<point> &U,const vector<point> &D,point d){
    if (sign(d.x)<0||(sign(d.x)==0&&sign(d.y)<0)) d=d*(-1);
    point whereU,whereD;
    if (sign(d.x)==0) return mp(U[0],U[U.size()-1]);
    int l=0,r=U.size()-1,ans=0;
    while (l<r){int mid=l+r>>1; if (sign(cross(U[mid+1]-U[mid],d))<=0) l=mid+1,ans=mid+1; else r=mid;}
    whereU=U[ans]; l=0,r=D.size()-1,ans=0;
    while (l<r){int mid=l+r>>1; if (sign(cross(D[mid+1]-D[mid],d))>=0) l=mid+1,ans=mid+1; else r=mid;}
    whereD=D[ans]; return mp(whereU,whereD);
}
// 先检查 contain, 逆时针给出
pair<point,point> getTangentCoP(const vector<point>&U,const vector<point>&D,point k){
    db lx=U[0].x,rx=U[U.size()-1].x;
    if (k.x<lx){
        int l=0,r=U.size()-1,ans=U.size()-1;
        while (l<r){int mid=l+r>>1; if (clockwise(k,U[mid],U[mid+1])==1) l=mid+1; else ans=mid,r=mid;}
        point w1=U[ans]; l=0,r=D.size()-1,ans=D.size()-1;
        while (l<r){int mid=l+r>>1; if (clockwise(k,D[mid],D[mid+1])==-1) l=mid+1; else ans=mid,r=mid;}
        point w2=D[ans]; return mp(w1,w2);
    } else if (k.x>rx){
        int l=1,r=U.size(),ans=0;
        while (l<r){int mid=l+r>>1; if (clockwise(k,U[mid],U[mid-1])==-1) r=mid; else ans=mid,l=mid+1;}
        point w1=U[ans]; l=1,r=D.size(),ans=0;
        while (l<r){int mid=l+r>>1; if (clockwise(k,D[mid],D[mid-1])==1) r=mid; else ans=mid,l=mid+1;}
        point w2=D[ans]; return mp(w2,w1);
    } else {
        int where1=lower_bound(U.begin(),U.end(),(point){k.x,-1e100})-U.begin();
        int where2=lower_bound(D.begin(),D.end(),(point){k.x,-1e100})-D.begin();
        if ((k.x==lx&&k.y>U[0].y)||(where1&&clockwise(U[where1-1],U[where1],k)==1)){
            int l=1,r=where1+1,ans=0;
            while (l<r){int mid=l+r>>1; if (clockwise(k,U[mid],U[mid-1])==1) ans=mid,l=mid+1; else r=mid;}
            point w1=U[ans]; l=where1,r=U.size()-1,ans=U.size()-1;
            while (l<r){int mid=l+r>>1; if (clockwise(k,U[mid],U[mid+1])==1) l=mid+1; else ans=mid,r=mid;}
            point w2=U[ans]; return mp(w2,w1);
        } else {
            int l=1,r=where2+1,ans=0;
            while (l<r){int mid=l+r>>1; if (clockwise(k,D[mid],D[mid-1])==-1) ans=mid,l=mid+1; else r=mid;}
            point w1=D[ans]; l=where2,r=D.size()-1,ans=D.size()-1;
            while (l<r){int mid=l+r>>1; if (clockwise(k,D[mid],D[mid+1])==-1) l=mid+1; else ans=mid,r=mid;}
            point w2=D[ans]; return mp(w1,w2);
        }
    }
}
struct P3{
    db x,y,z;
    P3 operator + (P3 k1){return (P3){x+k1.x,y+k1.y,z+k1.z};}
    P3 operator - (P3 k1){return (P3){x-k1.x,y-k1.y,z-k1.z};}
    P3 operator * (db k1){return (P3){x*k1,y*k1,z*k1};}
    P3 operator / (db k1){return (P3){x/k1,y/k1,z/k1};}
    db abs2(){return x*x+y*y+z*z;}
    db abs(){return sqrt(x*x+y*y+z*z);}
    P3 unit(){return (*this)/abs();}
    int operator < (const P3 k1) const{
        if (cmp(x,k1.x)!=0) return x<k1.x;
        if (cmp(y,k1.y)!=0) return y<k1.y;
        return cmp(z,k1.z)==-1;
    }
    int operator == (const P3 k1){
        return cmp(x,k1.x)==0&&cmp(y,k1.y)==0&&cmp(z,k1.z)==0;
    }
    void scan(){
        double k1,k2,k3; scanf("%lf%lf%lf",&k1,&k2,&k3);
        x=k1; y=k2; z=k3;
    }
};
P3 cross(P3 k1,P3 k2){return (P3){k1.y*k2.z-k1.z*k2.y,k1.z*k2.x-k1.x*k2.z,k1.x*k2.y-k1.y*k2.x};}
db dot(P3 k1,P3 k2){return k1.x*k2.x+k1.y*k2.y+k1.z*k2.z;}
//p=(3,4,5),l=(13,19,21),theta=85 ans=(2.83,4.62,1.77)
P3 turn3D(db k1,P3 l,P3 p){
    l=l.unit(); P3 ans; db c=cos(k1),s=sin(k1);
    ans.x=p.x*(l.x*l.x*(1-c)+c)+p.y*(l.x*l.y*(1-c)-l.z*s)+p.z*(l.x*l.z*(1-c)+l.y*s);
    ans.y=p.x*(l.x*l.y*(1-c)+l.z*s)+p.y*(l.y*l.y*(1-c)+c)+p.z*(l.y*l.z*(1-c)-l.x*s);
    ans.z=p.x*(l.x*l.z*(1-c)-l.y*s)+p.y*(l.y*l.z*(1-c)+l.x*s)+p.z*(l.x*l.x*(1-c)+c);
    return ans;
}
typedef vector<P3> VP;
typedef vector<VP> VVP;
db Acos(db x){return acos(max(-(db)1,min(x,(db)1)));}
// 球面距离 , 圆心原点 , 半径 1
db Odist(P3 a,P3 b){db r=Acos(dot(a,b)); return r;}
db r; P3 rnd;
vector<db> solve(db a,db b,db c){
    db r=sqrt(a*a+b*b),th=atan2(b,a);
    if (cmp(c,-r)==-1) return {0};
    else if (cmp(r,c)<=0) return {1};
    else {
        db tr=pi-Acos(c/r); return {th+pi-tr,th+pi+tr};
    }
}
vector<db> jiao(P3 a,P3 b){
    // dot(rd+x*cos(t)+y*sin(t),b) >= cos(r)
    if (cmp(Odist(a,b),2*r)>0) return {0};
    P3 rd=a*cos(r),z=a.unit(),y=cross(z,rnd).unit(),x=cross(y,z).unit();
    vector<db> ret = solve(-(dot(x,b)*sin(r)),-(dot(y,b)*sin(r)),-(cos(r)-dot(rd,b))); 
    return ret;
}
db norm(db x,db l=0,db r=2*pi){ // change x into [l,r)
    while (cmp(x,l)==-1) x+=(r-l); while (cmp(x,r)>=0) x-=(r-l);
    return x;
}
db disLP(P3 k1,P3 k2,P3 q){
    return (cross(k2-k1,q-k1)).abs()/(k2-k1).abs();
}
db disLL(P3 k1,P3 k2,P3 k3,P3 k4){
    P3 dir=cross(k2-k1,k4-k3); if (sign(dir.abs())==0) return disLP(k1,k2,k3);
    return fabs(dot(dir.unit(),k1-k2));
}
VP getFL(P3 p,P3 dir,P3 k1,P3 k2){
    db a=dot(k2-p,dir),b=dot(k1-p,dir),d=a-b;
    if (sign(fabs(d))==0) return {};
    return {(k1*a-k2*b)/d};
}
VP getFF(P3 p1,P3 dir1,P3 p2,P3 dir2){// 返回一条线
    P3 e=cross(dir1,dir2),v=cross(dir1,e);
    db d=dot(dir2,v); if (sign(abs(d))==0) return {};
    P3 q=p1+v*dot(dir2,p2-p1)/d; return {q,q+e};
}
// 3D Covex Hull Template
db getV(P3 k1,P3 k2,P3 k3,P3 k4){ // get the Volume
    return dot(cross(k2-k1,k3-k1),k4-k1);
}
db rand_db(){return 1.0*rand()/RAND_MAX;}
VP convexHull2D(VP A,P3 dir){
    P3 x={(db)rand(),(db)rand(),(db)rand()}; x=x.unit();
    x=cross(x,dir).unit(); P3 y=cross(x,dir).unit();
    P3 vec=dir.unit()*dot(A[0],dir);
    vector<point>B;
    for (int i=0;i<A.size();i++) B.push_back((point){dot(A[i],x),dot(A[i],y)});
    B=ConvexHull(B); A.clear();
    for (int i=0;i<B.size();i++) A.push_back(x*B[i].x+y*B[i].y+vec);
    return A;
}
namespace CH3{
    VVP ret; set<pair<int,int> >e;
    int n; VP p,q;
    void wrap(int a,int b){
        if (e.find({a,b})==e.end()){
            int c=-1;
            for (int i=0;i<n;i++) if (i!=a&&i!=b){
                if (c==-1||sign(getV(q[c],q[a],q[b],q[i]))>0) c=i;
            }
            if (c!=-1){
                ret.push_back({p[a],p[b],p[c]});
                e.insert({a,b}); e.insert({b,c}); e.insert({c,a});
                wrap(c,b); wrap(a,c);
            }
        }
    }
    VVP ConvexHull3D(VP _p){
        p=q=_p; n=p.size();
        ret.clear(); e.clear();
        for (auto &i:q) i=i+(P3){rand_db()*1e-4,rand_db()*1e-4,rand_db()*1e-4};
        for (int i=1;i<n;i++) if (q[i].x<q[0].x) swap(p[0],p[i]),swap(q[0],q[i]);
        for (int i=2;i<n;i++) if ((q[i].x-q[0].x)*(q[1].y-q[0].y)>(q[i].y-q[0].y)*(q[1].x-q[0].x)) swap(q[1],q[i]),swap(p[1],p[i]);
        wrap(0,1);
        return ret;
    }
}
VVP reduceCH(VVP A){
    VVP ret; map<P3,VP> M;
    for (VP nowF:A){
        P3 dir=cross(nowF[1]-nowF[0],nowF[2]-nowF[0]).unit();
        for (P3 k1:nowF) M[dir].pb(k1);
    }
    for (pair<P3,VP> nowF:M) ret.pb(convexHull2D(nowF.se,nowF.fi));
    return ret;
}
//  把一个面变成 ( 点 , 法向量 ) 的形式
pair<P3,P3> getF(VP F){
    return mp(F[0],cross(F[1]-F[0],F[2]-F[0]).unit());
}
// 3D Cut 保留 dot(dir,x-p)>=0 的部分
VVP ConvexCut3D(VVP A,P3 p,P3 dir){
    VVP ret; VP sec;
    for (VP nowF: A){
        int n=nowF.size(); VP ans; int dif=0;
        for (int i=0;i<n;i++){
            int d1=sign(dot(dir,nowF[i]-p));
            int d2=sign(dot(dir,nowF[(i+1)%n]-p));
            if (d1>=0) ans.pb(nowF[i]);
            if (d1*d2<0){
                P3 q=getFL(p,dir,nowF[i],nowF[(i+1)%n])[0];
                ans.push_back(q); sec.push_back(q);
            }
            if (d1==0) sec.push_back(nowF[i]); else dif=1;
            dif|=(sign(dot(dir,cross(nowF[(i+1)%n]-nowF[i],nowF[(i+1)%n]-nowF[i])))==-1);
        }
        if (ans.size()>0&&dif) ret.push_back(ans);
    }
    if (sec.size()>0) ret.push_back(convexHull2D(sec,dir));
    return ret;
}
db vol(VVP A){
    if (A.size()==0) return 0; P3 p=A[0][0]; db ans=0;
    for (VP nowF:A)
        for (int i=2;i<nowF.size();i++)
            ans+=abs(getV(p,nowF[0],nowF[i-1],nowF[i]));
    return ans/6;
}
VVP init(db INF) {
    VVP pss(6,VP(4));
    pss[0][0] = pss[1][0] = pss[2][0] = {-INF, -INF, -INF};
    pss[0][3] = pss[1][1] = pss[5][2] = {-INF, -INF, INF};
    pss[0][1] = pss[2][3] = pss[4][2] = {-INF, INF, -INF};
    pss[0][2] = pss[5][3] = pss[4][1] = {-INF, INF, INF};
    pss[1][3] = pss[2][1] = pss[3][2] = {INF, -INF, -INF};
    pss[1][2] = pss[5][1] = pss[3][3] = {INF, -INF, INF};
    pss[2][2] = pss[4][3] = pss[3][1] = {INF, INF, -INF};
    pss[5][0] = pss[4][0] = pss[3][0] = {INF, INF, INF};
    return pss;
}
\end{lstlisting}
\clearpage\section{Others}
\subsection{mint类}
\begin{lstlisting}
const int mod = 998244353;

struct mint {
  int n;
  mint(int n_ = 0) : n(n_) {}
};

mint operator+(mint a, mint b) { return (a.n += b.n) >= mod ? a.n - mod : a.n; }
mint operator-(mint a, mint b) { return (a.n -= b.n) < 0 ? a.n + mod : a.n; }
mint operator*(mint a, mint b) { return 1LL * a.n * b.n % mod; }
mint &operator+=(mint &a, mint b) { return a = a + b; }
mint &operator-=(mint &a, mint b) { return a = a - b; }
mint &operator*=(mint &a, mint b) { return a = a * b; }
ostream &operator<<(ostream &o, mint a) { return o << a.n; }
\end{lstlisting}
\subsection{不重叠区间贪心}
\begin{lstlisting}
#include <bits/stdc++.h>
#define ll long long
using namespace std;

const int maxn = 5e5+5;
pair<int, int> a[maxn];
int main() {
    int n;
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i].second >> a[i].first;
    }
    sort(a + 1, a + 1 + n);
    int res = 1;
    int tmp = a[1].first;
//    printf("%d %d\n", a[1].second, a[1].first);
    for (int i = 2; i <= n; ++i) {
        if (a[i].second > tmp) {
            res ++;
//            printf("%d %d\n", a[i].second, a[i].first);
            tmp = a[i].first;
        }
    }
    printf("%d\n", res);
    return 0;
}

\end{lstlisting}
\subsection{BigInt类}
\begin{lstlisting}
const double PI = acos(-1.0);
struct Complex{
    double x,y;
    Complex(double _x = 0.0,double _y = 0.0){
        x = _x;
        y = _y;
    }
    Complex operator-(const Complex &b)const{
        return Complex(x - b.x,y - b.y);
    }
    Complex operator+(const Complex &b)const{
        return Complex(x + b.x,y + b.y);
    }
    Complex operator*(const Complex &b)const{
        return Complex(x*b.x - y*b.y,x*b.y + y*b.x);
    }
};
void change(Complex y[],int len){
    int i,j,k;
    for(int i = 1,j = len/2;i<len-1;i++){
        if(i < j)    swap(y[i],y[j]);
        k = len/2;
        while(j >= k){
            j = j - k;
            k = k/2;
        }
        if(j < k)    j+=k;
    }
}
void fft(Complex y[],int len,int on){
    change(y,len);
    for(int h = 2;h <= len;h<<=1){
        Complex wn(cos(on*2*PI/h),sin(on*2*PI/h));
        for(int j = 0;j < len;j += h){
            Complex w(1,0);
            for(int k = j;k < j + h/2;k++){
                Complex u = y[k];
                Complex t = w*y[k + h/2];
                y[k] = u + t;
                y[k + h/2] = u - t;
                w = w*wn;
            }
        }
    }
    if(on == -1){
        for(int i = 0;i < len;i++){
            y[i].x /= len;
        }
    }
}
class BigInt
{
#define Value(x, nega) ((nega) ? -(x) : (x))
#define At(vec, index) ((index) < vec.size() ? vec[(index)] : 0)
    static int absComp(const BigInt &lhs, const BigInt &rhs)
    {
        if (lhs.size() != rhs.size())
            return lhs.size() < rhs.size() ? -1 : 1;
        for (int i = lhs.size() - 1; i >= 0; --i)
            if (lhs[i] != rhs[i])
                return lhs[i] < rhs[i] ? -1 : 1;
        return 0;
    }
    using Long = long long;
    const static int Exp = 9;
    const static Long Mod = 1000000000;
    mutable std::vector<Long> val;
    mutable bool nega = false;
    void trim() const
    {
        while (val.size() && val.back() == 0)
            val.pop_back();
        if (val.empty())
            nega = false;
    }
    int size() const { return val.size(); }
    Long &operator[](int index) const { return val[index]; }
    Long &back() const { return val.back(); }
    BigInt(int size, bool nega) : val(size), nega(nega) {}
    BigInt(const std::vector<Long> &val, bool nega) : val(val), nega(nega) {}

public:
    friend std::ostream &operator<<(std::ostream &os, const BigInt &n)
    {
        if (n.size())
        {
            if (n.nega)
                putchar('-');
            for (int i = n.size() - 1; i >= 0; --i)
            {
                if (i == n.size() - 1)
                    printf("%lld", n[i]);
                else
                    printf("%0*lld", n.Exp, n[i]);
            }
        }
        else
            putchar('0');
        return os;
    }
    friend BigInt operator+(const BigInt &lhs, const BigInt &rhs)
    {
        BigInt ret(lhs);
        return ret += rhs;
    }
    friend BigInt operator-(const BigInt &lhs, const BigInt &rhs)
    {
        BigInt ret(lhs);
        return ret -= rhs;
    }
    BigInt(Long x = 0)
    {
        if (x < 0)
            x = -x, nega = true;
        while (x >= Mod)
            val.push_back(x % Mod), x /= Mod;
        if (x)
            val.push_back(x);
    }
    BigInt(const char *s)
    {
        int bound = 0, pos;
        if (s[0] == '-')
            nega = true, bound = 1;
        Long cur = 0, pow = 1;
        for (pos = strlen(s) - 1; pos >= Exp + bound - 1; pos -= Exp, val.push_back(cur), cur = 0, pow = 1)
            for (int i = pos; i > pos - Exp; --i)
                cur += (s[i] - '0') * pow, pow *= 10;
        for (cur = 0, pow = 1; pos >= bound; --pos)
            cur += (s[pos] - '0') * pow, pow *= 10;
        if (cur)
            val.push_back(cur);
    }
    BigInt &operator=(const char *s){
        BigInt n(s);
        *this = n;
        return n;
    }
    BigInt &operator=(const Long x){
        BigInt n(x);
        *this = n;
        return n;
    }
    friend std::istream &operator>>(std::istream &is, BigInt &n){
        string s;
        is >> s;
        n=(char*)s.data();
        return is;
    }
    BigInt &operator+=(const BigInt &rhs)
    {
        const int cap = std::max(size(), rhs.size()) + 1;
        val.resize(cap);
        int carry = 0;
        for (int i = 0; i < cap - 1; ++i)
        {
            val[i] = Value(val[i], nega) + Value(At(rhs, i), rhs.nega) + carry, carry = 0;
            if (val[i] >= Mod)
                val[i] -= Mod, carry = 1;
            else if (val[i] < 0)
                val[i] += Mod, carry = -1;
        }
        if ((val.back() = carry) == -1) //assert(val.back() == 1 or 0 or -1)
        {
            nega = true, val.pop_back();
            bool tailZero = true;
            for (int i = 0; i < cap - 1; ++i)
            {
                if (tailZero && val[i])
                    val[i] = Mod - val[i], tailZero = false;
                else
                    val[i] = Mod - 1 - val[i];
            }
        }
        trim();
        return *this;
    }
    friend BigInt operator-(const BigInt &rhs)
    {
        BigInt ret(rhs);
        ret.nega ^= 1;
        return ret;
    }
    BigInt &operator-=(const BigInt &rhs)
    {
        rhs.nega ^= 1;
        *this += rhs;
        rhs.nega ^= 1;
        return *this;
    }
    friend BigInt operator*(const BigInt &lhs, const BigInt &rhs)
    {
        int len=1;
        BigInt ll=lhs,rr=rhs;
        ll.nega = lhs.nega ^ rhs.nega;
        while(len<2*lhs.size()||len<2*rhs.size())len<<=1;
        ll.val.resize(len),rr.val.resize(len);
        Complex x1[len],x2[len];
        for(int i=0;i<len;i++){
            Complex nx(ll[i],0.0),ny(rr[i],0.0);
            x1[i]=nx;
            x2[i]=ny;
        }
        fft(x1,len,1);
        fft(x2,len,1);
        for(int i = 0 ; i < len; i++)
            x1[i] = x1[i] * x2[i];
        fft( x1 , len , -1 );
        for(int i = 0 ; i < len; i++)
            ll[i] = int( x1[i].x + 0.5 );
        for(int i = 0 ; i < len; i++){
            ll[i+1]+=ll[i]/Mod;
            ll[i]%=Mod;
        }
        ll.trim();
        return ll;
    }
    friend BigInt operator*(const BigInt &lhs, const Long &x){
        BigInt ret=lhs;
        bool negat = ( x < 0 );
        Long xx = (negat) ? -x : x;
        ret.nega ^= negat;
        ret.val.push_back(0);
        ret.val.push_back(0);
        for(int i = 0; i < ret.size(); i++)
            ret[i]*=xx;
        for(int i = 0; i < ret.size(); i++){
            ret[i+1]+=ret[i]/Mod;
            ret[i] %= Mod;
        }
        ret.trim();
        return ret;
    }
    BigInt &operator*=(const BigInt &rhs) { return *this = *this * rhs; }
    BigInt &operator*=(const Long &x) { return *this = *this * x; }
    friend BigInt operator/(const BigInt &lhs, const BigInt &rhs)
    {
        static std::vector<BigInt> powTwo{BigInt(1)};
        static std::vector<BigInt> estimate;
        estimate.clear();
        if (absComp(lhs, rhs) < 0)
            return BigInt();
        BigInt cur = rhs;
        int cmp;
        while ((cmp = absComp(cur, lhs)) <= 0)
        {
            estimate.push_back(cur), cur += cur;
            if (estimate.size() >= powTwo.size())
                powTwo.push_back(powTwo.back() + powTwo.back());
        }
        if (cmp == 0)
            return BigInt(powTwo.back().val, lhs.nega ^ rhs.nega);
        BigInt ret = powTwo[estimate.size() - 1];
        cur = estimate[estimate.size() - 1];
        for (int i = estimate.size() - 1; i >= 0 && cmp != 0; --i)
            if ((cmp = absComp(cur + estimate[i], lhs)) <= 0)
                cur += estimate[i], ret += powTwo[i];
        ret.nega = lhs.nega ^ rhs.nega;
        return ret;
    }
    friend BigInt operator/(const BigInt &num,const Long &x){
        bool negat = ( x < 0 );
        Long xx = (negat) ? -x : x;
        BigInt ret;
        Long k = 0;
        ret.val.resize( num.size() );
        ret.nega = (num.nega ^ negat);
        for(int i = num.size() - 1 ;i >= 0; i--){
            ret[i] = ( k * Mod + num[i]) / xx;
            k = ( k * Mod + num[i]) % xx;
        }
        ret.trim();
        return ret;
    }
    bool operator==(const BigInt &rhs) const
    {
        return nega == rhs.nega && val == rhs.val;
    }
    bool operator!=(const BigInt &rhs) const { return nega != rhs.nega || val != rhs.val; }
    bool operator>=(const BigInt &rhs) const { return !(*this < rhs); }
    bool operator>(const BigInt &rhs) const { return !(*this <= rhs); }
    bool operator<=(const BigInt &rhs) const
    {
        if (nega && !rhs.nega)
            return true;
        if (!nega && rhs.nega)
            return false;
        int cmp = absComp(*this, rhs);
        return nega ? cmp >= 0 : cmp <= 0;
    }
    bool operator<(const BigInt &rhs) const
    {
        if (nega && !rhs.nega)
            return true;
        if (!nega && rhs.nega)
            return false;
        return (absComp(*this, rhs) < 0) ^ nega;
    }
    void swap(const BigInt &rhs) const
    {
        std::swap(val, rhs.val);
        std::swap(nega, rhs.nega);
    }
};
BigInt ba,bb;
int main(){
    cin>>ba>>bb;
    cout << ba + bb << '\n';//和
    cout << ba - bb << '\n';//差
    cout << ba * bb << '\n';//积
    BigInt d;
    cout << (d = ba / bb) << '\n';//商
    cout << ba - d * bb << '\n';//余
    return 0;
}\end{lstlisting}
\subsection{date}
\begin{lstlisting}
string dayOfWeek[] = {"Mo", "Tu", "We", "Th", "Fr", "Sa", "Su"};
// converts Gregorian date to integer (Julian day number)
int DateToInt (int m, int d, int y){
    return
        1461 * (y + 4800 + (m - 14) / 12) / 4 +
        367 * (m - 2 - (m - 14) / 12 * 12) / 12 -
        3 * ((y + 4900 + (m - 14) / 12) / 100) / 4 +
        d - 32075;
}

// converts integer (Julian day number) to Gregorian date: month/day/year
void IntToDate (int jd, int &m, int &d, int &y){
    int x, n, i, j;
    x = jd + 68569;
    n = 4 * x / 146097;
    x -= (146097 * n + 3) / 4;
    i = (4000 * (x + 1)) / 1461001;
    x -= 1461 * i / 4 - 31;
    j = 80 * x / 2447;
    d = x - 2447 * j / 80;
    x = j / 11;
    m = j + 2 - 12 * x;
    y = 100 * (n - 49) + i + x;
}
// converts integer (Julian day number) to day of week
string IntToDay (int jd){
    return dayOfWeek[jd % 7];
}\end{lstlisting}
\subsection{Frac类}
\begin{lstlisting}
struct Frac {
    ll a, b;
    void getJian() {
        ll gcd = abs(__gcd(a, b));
        a /= gcd;
        b /= gcd;
        if (b < 0) {
            a = -a;
            b = -b;
        }
    }
    Frac(ll a_ = 1, ll b_ = 1) {
        a = a_;
        b = b_;
        getJian();
    }
    Frac operator + (const Frac& oth) {
        ll bt = b * oth.b;
        ll at = a * oth.b + oth.a * b;
        return Frac(at, bt);
    }
    Frac operator * (const Frac& oth) {
        a *= oth.a;
        b *= oth.b;
        getJian();
        return *this;
    }
    bool operator < (const Frac& oth) const {
        return a * oth.b < b * oth.a;
    }
    bool operator == (const Frac& oth) const {
        return a * oth.b == b * oth.a;
    }
    bool operator <= (const Frac& oth) const {
        return a * oth.b <= b * oth.a;
    }
};\end{lstlisting}
\subsection{模拟退火(最小圆覆盖)}
\begin{lstlisting}
const int maxn = 1e5 + 10;
const double eps = 1e-8;
const double delta = 0.98;
const double inf = 1e18;

struct Point { double x, y; } p[maxn];

double dis(Point A, Point B) { return sqrt((A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y)); };

double Simulate_Annea(int n)
{
	Point S;
	S.x = S.y = 0;
	double t = 1000;
	double res = inf;
	while(t > eps)
	{
		int k = 0;
		for(int i = 0; i < n; i ++) if(dis(S, p[i]) > dis(S, p[k])) k = i;
		double d = dis(S, p[k]);
		res = min(res, d);
		S.x += (p[k].x - S.x) / d * t;
		S.y += (p[k].y - S.y) / d * t;
		t *= delta;
	}
	return res;
}

int main()
{
    int n;
    scanf("%d", &n);
    for(int i = 0; i < n; i ++) scanf("%lf%lf", &p[i].x, &p[i].y);
    printf("%.3f\n", Simulate_Annea(n));
    return 0;
}
\end{lstlisting}
\subsection{string类}
\begin{lstlisting}
const int maxn = 1005;
struct String{
    int nex[maxn];
    char x[maxn];
    int len;
    int getLength() {
        return len;
    }
    void getNext() {
        int n = len, i = 0, j = -1;
        nex[0] = -1;
        while (i < n) {
            if (j == -1 || x[i] == x[j]) nex[++i] = ++j;
            else j = -1;
        }
    }
    void input() {
        scanf("%s", x);
        len = strlen(x);
    }
    void inputAndCal() {
        scanf("%s", x);
        len = strlen(x);
        getNext();
    }
    void show() {
        printf("%s\n", x);
    }
    bool operator < (const String&oth) const {
        return strcmp(x, oth.x) < 0;
    }
    char operator [] (const int a) const {
        return x[a];
    }
    bool substring(String b) {//b is the substring of a
        int m = len, n = b.getLength();
        int i = 0, j = 0;
        while (i < m && j < n) {
            if (j == -1 || x[i] == b[j]) ++i, ++j;
            else j = b.nex[j];
            if (j == n) return true;
        }
        return false;
    }
};\end{lstlisting}
\subsection{前缀异或和}
\begin{lstlisting}
ll xor_sum(ll n) {
    ll t=n&3;
    if (t&1) return t/2ull^1;
    return t/2ull^n;
}\end{lstlisting}
\subsection{约瑟夫环第k个}
\begin{lstlisting}
ll kth(ll n, ll m, ll k) { // n个人，m间隔，第k个出列的人
    if (m == 1) return k;
    ll res = (m - 1) % (n - k + 1);
    for (ll i = n - k + 2, stp = 0; i <= n; i += stp, res += stp * m) {
        if (res + m >= i) {
            res = (res + m) % i;
            i++;
            stp = 0;
        } else {
            stp = (i - res - 2) / (m - 1);
            if (i + stp > n) {
                res += (n - (i - 1)) * m;
                break;
            }
        }
    }
    return res + 1;
}

ll dieInXturn(int n, int k, int x) { // n个人，m间隔，第k个人出列时间
    ll tmp = 0;
    while (n) {
        x = (x + n) % n;
        if (k > n)x += (k - x - 1 + n - 1) / n * n;
        if ((x + 1) % k == 0) {
            tmp += (x + 1) / k;
            break;
        } else {
            if (k > n) {
                tmp += x / k;
                ll ttmp = x;
                x = x - (x / n + 1) * (x / k) + (x + n) / n * n - k;
                n -= ttmp / k;

            } else {
                tmp += n / k;
                x = x - x / k;
                x += n - n / k * k;
                n -= n / k;
            }
        }
    }
    return tmp;
}\end{lstlisting}
\subsection{二分}
\begin{lstlisting}
// a为二分数组，x为需要查找的数，返回最左端和最右端
pair<int, int> F(vector<int> a, int x) {
    int l = 0, r = a.size() - 1;
    int lres = -1;
    while (l <= r) {
        int mid = l + r >> 1;
        int tt = a[mid];
        if (tt >= x) {
            r = mid - 1;
        } else if (tt < x) {
            l = mid + 1;
        }
    }
    if (l >= a.size() || a[l] != x) return make_pair(-1, -1);
    lres = l;
    l = 0, r = a.size() - 1;
    while (l <= r) {
        int mid = l + r >> 1;
        int tt = a[mid];
        if (tt > x) {
            r = mid - 1;
        } else if (tt <= x) {
            l = mid + 1;
        }
    }
    return make_pair(lres, r);
}\end{lstlisting}
\subsection{猛男IO挂}
\begin{lstlisting}
const int LEN = 100000;
struct fastio {
    int it, len;
    char s[LEN + 5];
    fastio() {
        it = len = 0;
    }
    char get() {
        if (it < len) return s[it++];
        it = 0, len = fread(s, 1, LEN, stdin);
        return len ? s[it++] : EOF;
    }
    bool notend() {
        char c;
        for (c = get(); c == ' ' || c == '\n'; c = get());
        if (it) it--;
        return c != EOF;
    }
    void put(char c) {
        if (it == LEN) fwrite(s, 1, LEN, stdout), it = 0;
        s[it++] = c;
    }
    void flush() {
        fwrite(s, 1, it, stdout);
    }
} buff, bufo;
inline int getint() {
    char c;
    int res = 0, sig = 1;
    for (c = buff.get(); c < '0' || c > '9'; c = buff.get()) if (c == '-') sig = -1;
    for (; c >= '0' && c <= '9'; c = buff.get()) res = res * 10 + (c - '0');
    return sig * res;
}
inline ll getll() {
    char c;
    ll res = 0, sig = 1;
    for (c = buff.get(); c < '0' || c > '9'; c = buff.get()) if (c == '-') sig = -1;
    for (; c >= '0' && c <= '9'; c = buff.get()) res = res * 10 + (c - '0');
    return sig * res;
}
inline void putint(int x, char suf) {
    if (!x) bufo.put('0');
    else {
        if (x < 0) bufo.put('-'), x = -x;
        int k = 0;
        char s[15];
        while (x) {
            s[++k] = x % 10 + '0';
            x /= 10;
        }
        for (; k; k--) bufo.put(s[k]);
    }
    bufo.put(suf);
}
inline void putll(ll x, char suf) {
    if (!x) bufo.put('0');
    else {
        if (x < 0) bufo.put('-'), x = -x;
        int k = 0;
        char s[25];
        while (x) {
            s[++k] = x % 10 + '0';
            x /= 10;
        }
        for (; k; k--) bufo.put(s[k]);
    }
    bufo.put(suf);
}
inline char get_char() {
    char c;
    for (c = buff.get(); c == ' ' || c == '\n'; c = buff.get());
    return c;
}\end{lstlisting}
\subsection{贪心结论}
\begin{lstlisting}
// n个区间，挪到使得某个点被所有区间覆盖需要的最少步数时，选择的点是所有区间端点的中位数（mid~mid+1答案都是一样的）

// 2 * n 的格子填数，使得列上的最大和最小的填充方法：最大配最小，次大配次小，以此类推

// n个数，重排后使得相同位置上数不同的最大值为：如果max<=(sum - max)则为sum，如果max>(sum-max)则为2*(sum-max)

// 不重叠区间贪心
pair<int, int> a[maxn];
int main() {
    int n;
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i].second >> a[i].first;
    }
    sort(a + 1, a + 1 + n);
    int res = 1;
    int tmp = a[1].first;
//    printf("%d %d\n", a[1].second, a[1].first);
    for (int i = 2; i <= n; ++i) {
        if (a[i].second > tmp) {
            res ++;
//            printf("%d %d\n", a[i].second, a[i].first);
            tmp = a[i].first;
        }
    }
    printf("%d\n", res);
    return 0;
}
\end{lstlisting}
\subsection{builtin}
\begin{lstlisting}
__builtin_popcount(unsigned int n) // 1的个数
__builtin_parity(unsigned int n) // 奇数个1返回1，偶数个返回0
__builtin_ctz(unsigned int n) // 判断n的二进制末尾后面0的个数
__builtin_clz(unsigned int n) //返回前导0的个数
\end{lstlisting}
\subsection{n以内k因子的个数}
\begin{lstlisting}
// 返回1～n中k因子的个数
ll dig(ll n, ll k) {
    if (k == 1) return n;
    ll res = 0;
    while (n > 0) {
        res += n / k;
        n /= k;
    }
    return res;
}
\end{lstlisting}
\subsection{每个点左右两边最长不重子序列}
\begin{lstlisting}
int r = 1;
for (int i = 1; i <= n; ++i) {
    while (r <= n && !vis[a[r]]) vis[a[r++]] = 1;
    vis[a[i]] = 0;
    R[i] = r - 1;
}
int l = n;
for (int i = n; i >= 1; --i) {
    while (l >= 1 && !vis[a[l]]) vis[a[l--]] = 1;
    vis[a[i]] = 0;
    L[i] = l + 1;
}\end{lstlisting}

\end{document}
